{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Locks = function () {\n  function Locks() {\n    this.locks = {};\n  }\n\n  Locks.prototype.add = function (id, x) {\n    this.locks[id] = x;\n  };\n\n  Locks.prototype.clear = function () {\n    this.locks = {};\n  };\n\n  Locks.prototype.isEmpty = function () {\n    for (var l in this.locks) return false;\n\n    return true;\n  };\n\n  Locks.prototype.apply = function (f) {\n    for (var l in this.locks) {\n      f(Number(l), this.locks[l]);\n    }\n  };\n\n  return Locks;\n}();\n\nexports.Locks = Locks;\n\nvar Descent = function () {\n  function Descent(x, D, G) {\n    if (G === void 0) {\n      G = null;\n    }\n\n    this.D = D;\n    this.G = G;\n    this.threshold = 0.0001;\n    this.numGridSnapNodes = 0;\n    this.snapGridSize = 100;\n    this.snapStrength = 1000;\n    this.scaleSnapByMaxH = false;\n    this.random = new PseudoRandom();\n    this.project = null;\n    this.x = x;\n    this.k = x.length;\n    var n = this.n = x[0].length;\n    this.H = new Array(this.k);\n    this.g = new Array(this.k);\n    this.Hd = new Array(this.k);\n    this.a = new Array(this.k);\n    this.b = new Array(this.k);\n    this.c = new Array(this.k);\n    this.d = new Array(this.k);\n    this.e = new Array(this.k);\n    this.ia = new Array(this.k);\n    this.ib = new Array(this.k);\n    this.xtmp = new Array(this.k);\n    this.locks = new Locks();\n    this.minD = Number.MAX_VALUE;\n    var i = n,\n        j;\n\n    while (i--) {\n      j = n;\n\n      while (--j > i) {\n        var d = D[i][j];\n\n        if (d > 0 && d < this.minD) {\n          this.minD = d;\n        }\n      }\n    }\n\n    if (this.minD === Number.MAX_VALUE) this.minD = 1;\n    i = this.k;\n\n    while (i--) {\n      this.g[i] = new Array(n);\n      this.H[i] = new Array(n);\n      j = n;\n\n      while (j--) {\n        this.H[i][j] = new Array(n);\n      }\n\n      this.Hd[i] = new Array(n);\n      this.a[i] = new Array(n);\n      this.b[i] = new Array(n);\n      this.c[i] = new Array(n);\n      this.d[i] = new Array(n);\n      this.e[i] = new Array(n);\n      this.ia[i] = new Array(n);\n      this.ib[i] = new Array(n);\n      this.xtmp[i] = new Array(n);\n    }\n  }\n\n  Descent.createSquareMatrix = function (n, f) {\n    var M = new Array(n);\n\n    for (var i = 0; i < n; ++i) {\n      M[i] = new Array(n);\n\n      for (var j = 0; j < n; ++j) {\n        M[i][j] = f(i, j);\n      }\n    }\n\n    return M;\n  };\n\n  Descent.prototype.offsetDir = function () {\n    var _this = this;\n\n    var u = new Array(this.k);\n    var l = 0;\n\n    for (var i = 0; i < this.k; ++i) {\n      var x = u[i] = this.random.getNextBetween(0.01, 1) - 0.5;\n      l += x * x;\n    }\n\n    l = Math.sqrt(l);\n    return u.map(function (x) {\n      return x *= _this.minD / l;\n    });\n  };\n\n  Descent.prototype.computeDerivatives = function (x) {\n    var _this = this;\n\n    var n = this.n;\n    if (n < 1) return;\n    var i;\n    var d = new Array(this.k);\n    var d2 = new Array(this.k);\n    var Huu = new Array(this.k);\n    var maxH = 0;\n\n    for (var u = 0; u < n; ++u) {\n      for (i = 0; i < this.k; ++i) Huu[i] = this.g[i][u] = 0;\n\n      for (var v = 0; v < n; ++v) {\n        if (u === v) continue;\n        var maxDisplaces = n;\n\n        while (maxDisplaces--) {\n          var sd2 = 0;\n\n          for (i = 0; i < this.k; ++i) {\n            var dx = d[i] = x[i][u] - x[i][v];\n            sd2 += d2[i] = dx * dx;\n          }\n\n          if (sd2 > 1e-9) break;\n          var rd = this.offsetDir();\n\n          for (i = 0; i < this.k; ++i) x[i][v] += rd[i];\n        }\n\n        var l = Math.sqrt(sd2);\n        var D = this.D[u][v];\n        var weight = this.G != null ? this.G[u][v] : 1;\n\n        if (weight > 1 && l > D || !isFinite(D)) {\n          for (i = 0; i < this.k; ++i) this.H[i][u][v] = 0;\n\n          continue;\n        }\n\n        if (weight > 1) {\n          weight = 1;\n        }\n\n        var D2 = D * D;\n        var gs = 2 * weight * (l - D) / (D2 * l);\n        var l3 = l * l * l;\n        var hs = 2 * -weight / (D2 * l3);\n        if (!isFinite(gs)) console.log(gs);\n\n        for (i = 0; i < this.k; ++i) {\n          this.g[i][u] += d[i] * gs;\n          Huu[i] -= this.H[i][u][v] = hs * (l3 + D * (d2[i] - sd2) + l * sd2);\n        }\n      }\n\n      for (i = 0; i < this.k; ++i) maxH = Math.max(maxH, this.H[i][u][u] = Huu[i]);\n    }\n\n    var r = this.snapGridSize / 2;\n    var g = this.snapGridSize;\n    var w = this.snapStrength;\n    var k = w / (r * r);\n    var numNodes = this.numGridSnapNodes;\n\n    for (var u = 0; u < numNodes; ++u) {\n      for (i = 0; i < this.k; ++i) {\n        var xiu = this.x[i][u];\n        var m = xiu / g;\n        var f = m % 1;\n        var q = m - f;\n        var a = Math.abs(f);\n        var dx = a <= 0.5 ? xiu - q * g : xiu > 0 ? xiu - (q + 1) * g : xiu - (q - 1) * g;\n\n        if (-r < dx && dx <= r) {\n          if (this.scaleSnapByMaxH) {\n            this.g[i][u] += maxH * k * dx;\n            this.H[i][u][u] += maxH * k;\n          } else {\n            this.g[i][u] += k * dx;\n            this.H[i][u][u] += k;\n          }\n        }\n      }\n    }\n\n    if (!this.locks.isEmpty()) {\n      this.locks.apply(function (u, p) {\n        for (i = 0; i < _this.k; ++i) {\n          _this.H[i][u][u] += maxH;\n          _this.g[i][u] -= maxH * (p[i] - x[i][u]);\n        }\n      });\n    }\n  };\n\n  Descent.dotProd = function (a, b) {\n    var x = 0,\n        i = a.length;\n\n    while (i--) x += a[i] * b[i];\n\n    return x;\n  };\n\n  Descent.rightMultiply = function (m, v, r) {\n    var i = m.length;\n\n    while (i--) r[i] = Descent.dotProd(m[i], v);\n  };\n\n  Descent.prototype.computeStepSize = function (d) {\n    var numerator = 0,\n        denominator = 0;\n\n    for (var i = 0; i < this.k; ++i) {\n      numerator += Descent.dotProd(this.g[i], d[i]);\n      Descent.rightMultiply(this.H[i], d[i], this.Hd[i]);\n      denominator += Descent.dotProd(d[i], this.Hd[i]);\n    }\n\n    if (denominator === 0 || !isFinite(denominator)) return 0;\n    return 1 * numerator / denominator;\n  };\n\n  Descent.prototype.reduceStress = function () {\n    this.computeDerivatives(this.x);\n    var alpha = this.computeStepSize(this.g);\n\n    for (var i = 0; i < this.k; ++i) {\n      this.takeDescentStep(this.x[i], this.g[i], alpha);\n    }\n\n    return this.computeStress();\n  };\n\n  Descent.copy = function (a, b) {\n    var m = a.length,\n        n = b[0].length;\n\n    for (var i = 0; i < m; ++i) {\n      for (var j = 0; j < n; ++j) {\n        b[i][j] = a[i][j];\n      }\n    }\n  };\n\n  Descent.prototype.stepAndProject = function (x0, r, d, stepSize) {\n    Descent.copy(x0, r);\n    this.takeDescentStep(r[0], d[0], stepSize);\n    if (this.project) this.project[0](x0[0], x0[1], r[0]);\n    this.takeDescentStep(r[1], d[1], stepSize);\n    if (this.project) this.project[1](r[0], x0[1], r[1]);\n\n    for (var i = 2; i < this.k; i++) this.takeDescentStep(r[i], d[i], stepSize);\n  };\n\n  Descent.mApply = function (m, n, f) {\n    var i = m;\n\n    while (i-- > 0) {\n      var j = n;\n\n      while (j-- > 0) f(i, j);\n    }\n  };\n\n  Descent.prototype.matrixApply = function (f) {\n    Descent.mApply(this.k, this.n, f);\n  };\n\n  Descent.prototype.computeNextPosition = function (x0, r) {\n    var _this = this;\n\n    this.computeDerivatives(x0);\n    var alpha = this.computeStepSize(this.g);\n    this.stepAndProject(x0, r, this.g, alpha);\n\n    if (this.project) {\n      this.matrixApply(function (i, j) {\n        return _this.e[i][j] = x0[i][j] - r[i][j];\n      });\n      var beta = this.computeStepSize(this.e);\n      beta = Math.max(0.2, Math.min(beta, 1));\n      this.stepAndProject(x0, r, this.e, beta);\n    }\n  };\n\n  Descent.prototype.run = function (iterations) {\n    var stress = Number.MAX_VALUE,\n        converged = false;\n\n    while (!converged && iterations-- > 0) {\n      var s = this.rungeKutta();\n      converged = Math.abs(stress / s - 1) < this.threshold;\n      stress = s;\n    }\n\n    return stress;\n  };\n\n  Descent.prototype.rungeKutta = function () {\n    var _this = this;\n\n    this.computeNextPosition(this.x, this.a);\n    Descent.mid(this.x, this.a, this.ia);\n    this.computeNextPosition(this.ia, this.b);\n    Descent.mid(this.x, this.b, this.ib);\n    this.computeNextPosition(this.ib, this.c);\n    this.computeNextPosition(this.c, this.d);\n    var disp = 0;\n    this.matrixApply(function (i, j) {\n      var x = (_this.a[i][j] + 2.0 * _this.b[i][j] + 2.0 * _this.c[i][j] + _this.d[i][j]) / 6.0,\n          d = _this.x[i][j] - x;\n      disp += d * d;\n      _this.x[i][j] = x;\n    });\n    return disp;\n  };\n\n  Descent.mid = function (a, b, m) {\n    Descent.mApply(a.length, a[0].length, function (i, j) {\n      return m[i][j] = a[i][j] + (b[i][j] - a[i][j]) / 2.0;\n    });\n  };\n\n  Descent.prototype.takeDescentStep = function (x, d, stepSize) {\n    for (var i = 0; i < this.n; ++i) {\n      x[i] = x[i] - stepSize * d[i];\n    }\n  };\n\n  Descent.prototype.computeStress = function () {\n    var stress = 0;\n\n    for (var u = 0, nMinus1 = this.n - 1; u < nMinus1; ++u) {\n      for (var v = u + 1, n = this.n; v < n; ++v) {\n        var l = 0;\n\n        for (var i = 0; i < this.k; ++i) {\n          var dx = this.x[i][u] - this.x[i][v];\n          l += dx * dx;\n        }\n\n        l = Math.sqrt(l);\n        var d = this.D[u][v];\n        if (!isFinite(d)) continue;\n        var rl = d - l;\n        var d2 = d * d;\n        stress += rl * rl / d2;\n      }\n    }\n\n    return stress;\n  };\n\n  Descent.zeroDistance = 1e-10;\n  return Descent;\n}();\n\nexports.Descent = Descent;\n\nvar PseudoRandom = function () {\n  function PseudoRandom(seed) {\n    if (seed === void 0) {\n      seed = 1;\n    }\n\n    this.seed = seed;\n    this.a = 214013;\n    this.c = 2531011;\n    this.m = 2147483648;\n    this.range = 32767;\n  }\n\n  PseudoRandom.prototype.getNext = function () {\n    this.seed = (this.seed * this.a + this.c) % this.m;\n    return (this.seed >> 16) / this.range;\n  };\n\n  PseudoRandom.prototype.getNextBetween = function (min, max) {\n    return min + this.getNext() * (max - min);\n  };\n\n  return PseudoRandom;\n}();\n\nexports.PseudoRandom = PseudoRandom;","map":null,"metadata":{},"sourceType":"script"}