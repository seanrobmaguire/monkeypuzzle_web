{"ast":null,"code":"/*\n * qTip2 - Pretty powerful tooltips - v3.0.3\n * http://qtip2.com\n *\n * Copyright (c) 2016 \n * Released under the MIT licenses\n * http://jquery.org/license\n *\n * Date: Wed May 11 2016 10:31 GMT+0100+0100\n * Plugins: tips modal viewport svg imagemap ie6\n * Styles: core basic css3\n */\n\n/*global window: false, jQuery: false, console: false, define: false */\n\n/* Cache window, document, undefined */\n(function (window, document, undefined) {\n  // Uses AMD or browser globals to create a jQuery plugin.\n  (function (factory) {\n    \"use strict\";\n\n    if (typeof define === 'function' && define.amd) {\n      define(['jquery'], factory);\n    } else if (jQuery && !jQuery.fn.qtip) {\n      factory(jQuery);\n    }\n  })(function ($) {\n    \"use strict\"; // Enable ECMAScript \"strict\" operation for this function. See more: http://ejohn.org/blog/ecmascript-5-strict-mode-json-and-more/\n\n    ; // Munge the primitives - Paul Irish tip\n\n    var TRUE = true,\n        FALSE = false,\n        NULL = null,\n        // Common variables\n    X = 'x',\n        Y = 'y',\n        WIDTH = 'width',\n        HEIGHT = 'height',\n        // Positioning sides\n    TOP = 'top',\n        LEFT = 'left',\n        BOTTOM = 'bottom',\n        RIGHT = 'right',\n        CENTER = 'center',\n        // Position adjustment types\n    FLIP = 'flip',\n        FLIPINVERT = 'flipinvert',\n        SHIFT = 'shift',\n        // Shortcut vars\n    QTIP,\n        PROTOTYPE,\n        CORNER,\n        CHECKS,\n        PLUGINS = {},\n        NAMESPACE = 'qtip',\n        ATTR_HAS = 'data-hasqtip',\n        ATTR_ID = 'data-qtip-id',\n        WIDGET = ['ui-widget', 'ui-tooltip'],\n        SELECTOR = '.' + NAMESPACE,\n        INACTIVE_EVENTS = 'click dblclick mousedown mouseup mousemove mouseleave mouseenter'.split(' '),\n        CLASS_FIXED = NAMESPACE + '-fixed',\n        CLASS_DEFAULT = NAMESPACE + '-default',\n        CLASS_FOCUS = NAMESPACE + '-focus',\n        CLASS_HOVER = NAMESPACE + '-hover',\n        CLASS_DISABLED = NAMESPACE + '-disabled',\n        replaceSuffix = '_replacedByqTip',\n        oldtitle = 'oldtitle',\n        trackingBound,\n        // Browser detection\n    BROWSER = {\n      /*\n       * IE version detection\n       *\n       * Adapted from: http://ajaxian.com/archives/attack-of-the-ie-conditional-comment\n       * Credit to James Padolsey for the original implemntation!\n       */\n      ie: function () {\n        /* eslint-disable no-empty */\n        var v, i;\n\n        for (v = 4, i = document.createElement('div'); (i.innerHTML = '<!--[if gt IE ' + v + ']><i></i><![endif]-->') && i.getElementsByTagName('i')[0]; v += 1) {}\n\n        return v > 4 ? v : NaN;\n        /* eslint-enable no-empty */\n      }(),\n\n      /*\n       * iOS version detection\n       */\n      iOS: parseFloat(('' + (/CPU.*OS ([0-9_]{1,5})|(CPU like).*AppleWebKit.*Mobile/i.exec(navigator.userAgent) || [0, ''])[1]).replace('undefined', '3_2').replace('_', '.').replace('_', '')) || FALSE\n    };\n    ;\n\n    function QTip(target, options, id, attr) {\n      // Elements and ID\n      this.id = id;\n      this.target = target;\n      this.tooltip = NULL;\n      this.elements = {\n        target: target\n      }; // Internal constructs\n\n      this._id = NAMESPACE + '-' + id;\n      this.timers = {\n        img: {}\n      };\n      this.options = options;\n      this.plugins = {}; // Cache object\n\n      this.cache = {\n        event: {},\n        target: $(),\n        disabled: FALSE,\n        attr: attr,\n        onTooltip: FALSE,\n        lastClass: ''\n      }; // Set the initial flags\n\n      this.rendered = this.destroyed = this.disabled = this.waiting = this.hiddenDuringWait = this.positioning = this.triggering = FALSE;\n    }\n\n    PROTOTYPE = QTip.prototype;\n\n    PROTOTYPE._when = function (deferreds) {\n      return $.when.apply($, deferreds);\n    };\n\n    PROTOTYPE.render = function (show) {\n      if (this.rendered || this.destroyed) {\n        return this;\n      } // If tooltip has already been rendered, exit\n\n\n      var self = this,\n          options = this.options,\n          cache = this.cache,\n          elements = this.elements,\n          text = options.content.text,\n          title = options.content.title,\n          button = options.content.button,\n          posOptions = options.position,\n          deferreds = []; // Add ARIA attributes to target\n\n      $.attr(this.target[0], 'aria-describedby', this._id); // Create public position object that tracks current position corners\n\n      cache.posClass = this._createPosClass((this.position = {\n        my: posOptions.my,\n        at: posOptions.at\n      }).my); // Create tooltip element\n\n      this.tooltip = elements.tooltip = $('<div/>', {\n        'id': this._id,\n        'class': [NAMESPACE, CLASS_DEFAULT, options.style.classes, cache.posClass].join(' '),\n        'width': options.style.width || '',\n        'height': options.style.height || '',\n        'tracking': posOptions.target === 'mouse' && posOptions.adjust.mouse,\n\n        /* ARIA specific attributes */\n        'role': 'alert',\n        'aria-live': 'polite',\n        'aria-atomic': FALSE,\n        'aria-describedby': this._id + '-content',\n        'aria-hidden': TRUE\n      }).toggleClass(CLASS_DISABLED, this.disabled).attr(ATTR_ID, this.id).data(NAMESPACE, this).appendTo(posOptions.container).append( // Create content element\n      elements.content = $('<div />', {\n        'class': NAMESPACE + '-content',\n        'id': this._id + '-content',\n        'aria-atomic': TRUE\n      })); // Set rendered flag and prevent redundant reposition calls for now\n\n      this.rendered = -1;\n      this.positioning = TRUE; // Create title...\n\n      if (title) {\n        this._createTitle(); // Update title only if its not a callback (called in toggle if so)\n\n\n        if (!$.isFunction(title)) {\n          deferreds.push(this._updateTitle(title, FALSE));\n        }\n      } // Create button\n\n\n      if (button) {\n        this._createButton();\n      } // Set proper rendered flag and update content if not a callback function (called in toggle)\n\n\n      if (!$.isFunction(text)) {\n        deferreds.push(this._updateContent(text, FALSE));\n      }\n\n      this.rendered = TRUE; // Setup widget classes\n\n      this._setWidget(); // Initialize 'render' plugins\n\n\n      $.each(PLUGINS, function (name) {\n        var instance;\n\n        if (this.initialize === 'render' && (instance = this(self))) {\n          self.plugins[name] = instance;\n        }\n      }); // Unassign initial events and assign proper events\n\n      this._unassignEvents();\n\n      this._assignEvents(); // When deferreds have completed\n\n\n      this._when(deferreds).then(function () {\n        // tooltiprender event\n        self._trigger('render'); // Reset flags\n\n\n        self.positioning = FALSE; // Show tooltip if not hidden during wait period\n\n        if (!self.hiddenDuringWait && (options.show.ready || show)) {\n          self.toggle(TRUE, cache.event, FALSE);\n        }\n\n        self.hiddenDuringWait = FALSE;\n      }); // Expose API\n\n\n      QTIP.api[this.id] = this;\n      return this;\n    };\n\n    PROTOTYPE.destroy = function (immediate) {\n      // Set flag the signify destroy is taking place to plugins\n      // and ensure it only gets destroyed once!\n      if (this.destroyed) {\n        return this.target;\n      }\n\n      function process() {\n        if (this.destroyed) {\n          return;\n        }\n\n        this.destroyed = TRUE;\n        var target = this.target,\n            title = target.attr(oldtitle),\n            timer; // Destroy tooltip if rendered\n\n        if (this.rendered) {\n          this.tooltip.stop(1, 0).find('*').remove().end().remove();\n        } // Destroy all plugins\n\n\n        $.each(this.plugins, function () {\n          this.destroy && this.destroy();\n        }); // Clear timers\n\n        for (timer in this.timers) {\n          if (this.timers.hasOwnProperty(timer)) {\n            clearTimeout(this.timers[timer]);\n          }\n        } // Remove api object and ARIA attributes\n\n\n        target.removeData(NAMESPACE).removeAttr(ATTR_ID).removeAttr(ATTR_HAS).removeAttr('aria-describedby'); // Reset old title attribute if removed\n\n        if (this.options.suppress && title) {\n          target.attr('title', title).removeAttr(oldtitle);\n        } // Remove qTip events associated with this API\n\n\n        this._unassignEvents(); // Remove ID from used id objects, and delete object references\n        // for better garbage collection and leak protection\n\n\n        this.options = this.elements = this.cache = this.timers = this.plugins = this.mouse = NULL; // Delete epoxsed API object\n\n        delete QTIP.api[this.id];\n      } // If an immediate destroy is needed\n\n\n      if ((immediate !== TRUE || this.triggering === 'hide') && this.rendered) {\n        this.tooltip.one('tooltiphidden', $.proxy(process, this));\n        !this.triggering && this.hide();\n      } // If we're not in the process of hiding... process\n      else {\n          process.call(this);\n        }\n\n      return this.target;\n    };\n\n    ;\n\n    function invalidOpt(a) {\n      return a === NULL || $.type(a) !== 'object';\n    }\n\n    function invalidContent(c) {\n      return !($.isFunction(c) || c && c.attr || c.length || $.type(c) === 'object' && (c.jquery || c.then));\n    } // Option object sanitizer\n\n\n    function sanitizeOptions(opts) {\n      var content, text, ajax, once;\n\n      if (invalidOpt(opts)) {\n        return FALSE;\n      }\n\n      if (invalidOpt(opts.metadata)) {\n        opts.metadata = {\n          type: opts.metadata\n        };\n      }\n\n      if ('content' in opts) {\n        content = opts.content;\n\n        if (invalidOpt(content) || content.jquery || content.done) {\n          text = invalidContent(content) ? FALSE : content;\n          content = opts.content = {\n            text: text\n          };\n        } else {\n          text = content.text;\n        } // DEPRECATED - Old content.ajax plugin functionality\n        // Converts it into the proper Deferred syntax\n\n\n        if ('ajax' in content) {\n          ajax = content.ajax;\n          once = ajax && ajax.once !== FALSE;\n          delete content.ajax;\n\n          content.text = function (event, api) {\n            var loading = text || $(this).attr(api.options.content.attr) || 'Loading...',\n                deferred = $.ajax($.extend({}, ajax, {\n              context: api\n            })).then(ajax.success, NULL, ajax.error).then(function (newContent) {\n              if (newContent && once) {\n                api.set('content.text', newContent);\n              }\n\n              return newContent;\n            }, function (xhr, status, error) {\n              if (api.destroyed || xhr.status === 0) {\n                return;\n              }\n\n              api.set('content.text', status + ': ' + error);\n            });\n            return !once ? (api.set('content.text', loading), deferred) : loading;\n          };\n        }\n\n        if ('title' in content) {\n          if ($.isPlainObject(content.title)) {\n            content.button = content.title.button;\n            content.title = content.title.text;\n          }\n\n          if (invalidContent(content.title || FALSE)) {\n            content.title = FALSE;\n          }\n        }\n      }\n\n      if ('position' in opts && invalidOpt(opts.position)) {\n        opts.position = {\n          my: opts.position,\n          at: opts.position\n        };\n      }\n\n      if ('show' in opts && invalidOpt(opts.show)) {\n        opts.show = opts.show.jquery ? {\n          target: opts.show\n        } : opts.show === TRUE ? {\n          ready: TRUE\n        } : {\n          event: opts.show\n        };\n      }\n\n      if ('hide' in opts && invalidOpt(opts.hide)) {\n        opts.hide = opts.hide.jquery ? {\n          target: opts.hide\n        } : {\n          event: opts.hide\n        };\n      }\n\n      if ('style' in opts && invalidOpt(opts.style)) {\n        opts.style = {\n          classes: opts.style\n        };\n      } // Sanitize plugin options\n\n\n      $.each(PLUGINS, function () {\n        this.sanitize && this.sanitize(opts);\n      });\n      return opts;\n    } // Setup builtin .set() option checks\n\n\n    CHECKS = PROTOTYPE.checks = {\n      builtin: {\n        // Core checks\n        '^id$': function (obj, o, v, prev) {\n          var id = v === TRUE ? QTIP.nextid : v,\n              newId = NAMESPACE + '-' + id;\n\n          if (id !== FALSE && id.length > 0 && !$('#' + newId).length) {\n            this._id = newId;\n\n            if (this.rendered) {\n              this.tooltip[0].id = this._id;\n              this.elements.content[0].id = this._id + '-content';\n              this.elements.title[0].id = this._id + '-title';\n            }\n          } else {\n            obj[o] = prev;\n          }\n        },\n        '^prerender': function (obj, o, v) {\n          v && !this.rendered && this.render(this.options.show.ready);\n        },\n        // Content checks\n        '^content.text$': function (obj, o, v) {\n          this._updateContent(v);\n        },\n        '^content.attr$': function (obj, o, v, prev) {\n          if (this.options.content.text === this.target.attr(prev)) {\n            this._updateContent(this.target.attr(v));\n          }\n        },\n        '^content.title$': function (obj, o, v) {\n          // Remove title if content is null\n          if (!v) {\n            return this._removeTitle();\n          } // If title isn't already created, create it now and update\n\n\n          v && !this.elements.title && this._createTitle();\n\n          this._updateTitle(v);\n        },\n        '^content.button$': function (obj, o, v) {\n          this._updateButton(v);\n        },\n        '^content.title.(text|button)$': function (obj, o, v) {\n          this.set('content.' + o, v); // Backwards title.text/button compat\n        },\n        // Position checks\n        '^position.(my|at)$': function (obj, o, v) {\n          if ('string' === typeof v) {\n            this.position[o] = obj[o] = new CORNER(v, o === 'at');\n          }\n        },\n        '^position.container$': function (obj, o, v) {\n          this.rendered && this.tooltip.appendTo(v);\n        },\n        // Show checks\n        '^show.ready$': function (obj, o, v) {\n          v && (!this.rendered && this.render(TRUE) || this.toggle(TRUE));\n        },\n        // Style checks\n        '^style.classes$': function (obj, o, v, p) {\n          this.rendered && this.tooltip.removeClass(p).addClass(v);\n        },\n        '^style.(width|height)': function (obj, o, v) {\n          this.rendered && this.tooltip.css(o, v);\n        },\n        '^style.widget|content.title': function () {\n          this.rendered && this._setWidget();\n        },\n        '^style.def': function (obj, o, v) {\n          this.rendered && this.tooltip.toggleClass(CLASS_DEFAULT, !!v);\n        },\n        // Events check\n        '^events.(render|show|move|hide|focus|blur)$': function (obj, o, v) {\n          this.rendered && this.tooltip[($.isFunction(v) ? '' : 'un') + 'bind']('tooltip' + o, v);\n        },\n        // Properties which require event reassignment\n        '^(show|hide|position).(event|target|fixed|inactive|leave|distance|viewport|adjust)': function () {\n          if (!this.rendered) {\n            return;\n          } // Set tracking flag\n\n\n          var posOptions = this.options.position;\n          this.tooltip.attr('tracking', posOptions.target === 'mouse' && posOptions.adjust.mouse); // Reassign events\n\n          this._unassignEvents();\n\n          this._assignEvents();\n        }\n      }\n    }; // Dot notation converter\n\n    function convertNotation(options, notation) {\n      var i = 0,\n          obj,\n          option = options,\n          // Split notation into array\n      levels = notation.split('.'); // Loop through\n\n      while (option = option[levels[i++]]) {\n        if (i < levels.length) {\n          obj = option;\n        }\n      }\n\n      return [obj || options, levels.pop()];\n    }\n\n    PROTOTYPE.get = function (notation) {\n      if (this.destroyed) {\n        return this;\n      }\n\n      var o = convertNotation(this.options, notation.toLowerCase()),\n          result = o[0][o[1]];\n      return result.precedance ? result.string() : result;\n    };\n\n    function setCallback(notation, args) {\n      var category, rule, match;\n\n      for (category in this.checks) {\n        if (!this.checks.hasOwnProperty(category)) {\n          continue;\n        }\n\n        for (rule in this.checks[category]) {\n          if (!this.checks[category].hasOwnProperty(rule)) {\n            continue;\n          }\n\n          if (match = new RegExp(rule, 'i').exec(notation)) {\n            args.push(match);\n\n            if (category === 'builtin' || this.plugins[category]) {\n              this.checks[category][rule].apply(this.plugins[category] || this, args);\n            }\n          }\n        }\n      }\n    }\n\n    var rmove = /^position\\.(my|at|adjust|target|container|viewport)|style|content|show\\.ready/i,\n        rrender = /^prerender|show\\.ready/i;\n\n    PROTOTYPE.set = function (option, value) {\n      if (this.destroyed) {\n        return this;\n      }\n\n      var rendered = this.rendered,\n          reposition = FALSE,\n          options = this.options,\n          name; // Convert singular option/value pair into object form\n\n      if ('string' === typeof option) {\n        name = option;\n        option = {};\n        option[name] = value;\n      } else {\n        option = $.extend({}, option);\n      } // Set all of the defined options to their new values\n\n\n      $.each(option, function (notation, val) {\n        if (rendered && rrender.test(notation)) {\n          delete option[notation];\n          return;\n        } // Set new obj value\n\n\n        var obj = convertNotation(options, notation.toLowerCase()),\n            previous;\n        previous = obj[0][obj[1]];\n        obj[0][obj[1]] = val && val.nodeType ? $(val) : val; // Also check if we need to reposition\n\n        reposition = rmove.test(notation) || reposition; // Set the new params for the callback\n\n        option[notation] = [obj[0], obj[1], val, previous];\n      }); // Re-sanitize options\n\n      sanitizeOptions(options);\n      /*\n       * Execute any valid callbacks for the set options\n       * Also set positioning flag so we don't get loads of redundant repositioning calls.\n       */\n\n      this.positioning = TRUE;\n      $.each(option, $.proxy(setCallback, this));\n      this.positioning = FALSE; // Update position if needed\n\n      if (this.rendered && this.tooltip[0].offsetWidth > 0 && reposition) {\n        this.reposition(options.position.target === 'mouse' ? NULL : this.cache.event);\n      }\n\n      return this;\n    };\n\n    ;\n\n    PROTOTYPE._update = function (content, element) {\n      var self = this,\n          cache = this.cache; // Make sure tooltip is rendered and content is defined. If not return\n\n      if (!this.rendered || !content) {\n        return FALSE;\n      } // Use function to parse content\n\n\n      if ($.isFunction(content)) {\n        content = content.call(this.elements.target, cache.event, this) || '';\n      } // Handle deferred content\n\n\n      if ($.isFunction(content.then)) {\n        cache.waiting = TRUE;\n        return content.then(function (c) {\n          cache.waiting = FALSE;\n          return self._update(c, element);\n        }, NULL, function (e) {\n          return self._update(e, element);\n        });\n      } // If content is null... return false\n\n\n      if (content === FALSE || !content && content !== '') {\n        return FALSE;\n      } // Append new content if its a DOM array and show it if hidden\n\n\n      if (content.jquery && content.length > 0) {\n        element.empty().append(content.css({\n          display: 'block',\n          visibility: 'visible'\n        }));\n      } // Content is a regular string, insert the new content\n      else {\n          element.html(content);\n        } // Wait for content to be loaded, and reposition\n\n\n      return this._waitForContent(element).then(function (images) {\n        if (self.rendered && self.tooltip[0].offsetWidth > 0) {\n          self.reposition(cache.event, !images.length);\n        }\n      });\n    };\n\n    PROTOTYPE._waitForContent = function (element) {\n      var cache = this.cache; // Set flag\n\n      cache.waiting = TRUE; // If imagesLoaded is included, ensure images have loaded and return promise\n\n      return ($.fn.imagesLoaded ? element.imagesLoaded() : new $.Deferred().resolve([])).done(function () {\n        cache.waiting = FALSE;\n      }).promise();\n    };\n\n    PROTOTYPE._updateContent = function (content, reposition) {\n      this._update(content, this.elements.content, reposition);\n    };\n\n    PROTOTYPE._updateTitle = function (content, reposition) {\n      if (this._update(content, this.elements.title, reposition) === FALSE) {\n        this._removeTitle(FALSE);\n      }\n    };\n\n    PROTOTYPE._createTitle = function () {\n      var elements = this.elements,\n          id = this._id + '-title'; // Destroy previous title element, if present\n\n      if (elements.titlebar) {\n        this._removeTitle();\n      } // Create title bar and title elements\n\n\n      elements.titlebar = $('<div />', {\n        'class': NAMESPACE + '-titlebar ' + (this.options.style.widget ? createWidgetClass('header') : '')\n      }).append(elements.title = $('<div />', {\n        'id': id,\n        'class': NAMESPACE + '-title',\n        'aria-atomic': TRUE\n      })).insertBefore(elements.content) // Button-specific events\n      .delegate('.qtip-close', 'mousedown keydown mouseup keyup mouseout', function (event) {\n        $(this).toggleClass('ui-state-active ui-state-focus', event.type.substr(-4) === 'down');\n      }).delegate('.qtip-close', 'mouseover mouseout', function (event) {\n        $(this).toggleClass('ui-state-hover', event.type === 'mouseover');\n      }); // Create button if enabled\n\n      if (this.options.content.button) {\n        this._createButton();\n      }\n    };\n\n    PROTOTYPE._removeTitle = function (reposition) {\n      var elements = this.elements;\n\n      if (elements.title) {\n        elements.titlebar.remove();\n        elements.titlebar = elements.title = elements.button = NULL; // Reposition if enabled\n\n        if (reposition !== FALSE) {\n          this.reposition();\n        }\n      }\n    };\n\n    ;\n\n    PROTOTYPE._createPosClass = function (my) {\n      return NAMESPACE + '-pos-' + (my || this.options.position.my).abbrev();\n    };\n\n    PROTOTYPE.reposition = function (event, effect) {\n      if (!this.rendered || this.positioning || this.destroyed) {\n        return this;\n      } // Set positioning flag\n\n\n      this.positioning = TRUE;\n      var cache = this.cache,\n          tooltip = this.tooltip,\n          posOptions = this.options.position,\n          target = posOptions.target,\n          my = posOptions.my,\n          at = posOptions.at,\n          viewport = posOptions.viewport,\n          container = posOptions.container,\n          adjust = posOptions.adjust,\n          method = adjust.method.split(' '),\n          tooltipWidth = tooltip.outerWidth(FALSE),\n          tooltipHeight = tooltip.outerHeight(FALSE),\n          targetWidth = 0,\n          targetHeight = 0,\n          type = tooltip.css('position'),\n          position = {\n        left: 0,\n        top: 0\n      },\n          visible = tooltip[0].offsetWidth > 0,\n          isScroll = event && event.type === 'scroll',\n          win = $(window),\n          doc = container[0].ownerDocument,\n          mouse = this.mouse,\n          pluginCalculations,\n          offset,\n          adjusted,\n          newClass; // Check if absolute position was passed\n\n      if ($.isArray(target) && target.length === 2) {\n        // Force left top and set position\n        at = {\n          x: LEFT,\n          y: TOP\n        };\n        position = {\n          left: target[0],\n          top: target[1]\n        };\n      } // Check if mouse was the target\n      else if (target === 'mouse') {\n          // Force left top to allow flipping\n          at = {\n            x: LEFT,\n            y: TOP\n          }; // Use the mouse origin that caused the show event, if distance hiding is enabled\n\n          if ((!adjust.mouse || this.options.hide.distance) && cache.origin && cache.origin.pageX) {\n            event = cache.origin;\n          } // Use cached event for resize/scroll events\n          else if (!event || event && (event.type === 'resize' || event.type === 'scroll')) {\n              event = cache.event;\n            } // Otherwise, use the cached mouse coordinates if available\n            else if (mouse && mouse.pageX) {\n                event = mouse;\n              } // Calculate body and container offset and take them into account below\n\n\n          if (type !== 'static') {\n            position = container.offset();\n          }\n\n          if (doc.body.offsetWidth !== (window.innerWidth || doc.documentElement.clientWidth)) {\n            offset = $(document.body).offset();\n          } // Use event coordinates for position\n\n\n          position = {\n            left: event.pageX - position.left + (offset && offset.left || 0),\n            top: event.pageY - position.top + (offset && offset.top || 0)\n          }; // Scroll events are a pain, some browsers\n\n          if (adjust.mouse && isScroll && mouse) {\n            position.left -= (mouse.scrollX || 0) - win.scrollLeft();\n            position.top -= (mouse.scrollY || 0) - win.scrollTop();\n          }\n        } // Target wasn't mouse or absolute...\n        else {\n            // Check if event targetting is being used\n            if (target === 'event') {\n              if (event && event.target && event.type !== 'scroll' && event.type !== 'resize') {\n                cache.target = $(event.target);\n              } else if (!event.target) {\n                cache.target = this.elements.target;\n              }\n            } else if (target !== 'event') {\n              cache.target = $(target.jquery ? target : this.elements.target);\n            }\n\n            target = cache.target; // Parse the target into a jQuery object and make sure there's an element present\n\n            target = $(target).eq(0);\n\n            if (target.length === 0) {\n              return this;\n            } // Check if window or document is the target\n            else if (target[0] === document || target[0] === window) {\n                targetWidth = BROWSER.iOS ? window.innerWidth : target.width();\n                targetHeight = BROWSER.iOS ? window.innerHeight : target.height();\n\n                if (target[0] === window) {\n                  position = {\n                    top: (viewport || target).scrollTop(),\n                    left: (viewport || target).scrollLeft()\n                  };\n                }\n              } // Check if the target is an <AREA> element\n              else if (PLUGINS.imagemap && target.is('area')) {\n                  pluginCalculations = PLUGINS.imagemap(this, target, at, PLUGINS.viewport ? method : FALSE);\n                } // Check if the target is an SVG element\n                else if (PLUGINS.svg && target && target[0].ownerSVGElement) {\n                    pluginCalculations = PLUGINS.svg(this, target, at, PLUGINS.viewport ? method : FALSE);\n                  } // Otherwise use regular jQuery methods\n                  else {\n                      targetWidth = target.outerWidth(FALSE);\n                      targetHeight = target.outerHeight(FALSE);\n                      position = target.offset();\n                    } // Parse returned plugin values into proper variables\n\n\n            if (pluginCalculations) {\n              targetWidth = pluginCalculations.width;\n              targetHeight = pluginCalculations.height;\n              offset = pluginCalculations.offset;\n              position = pluginCalculations.position;\n            } // Adjust position to take into account offset parents\n\n\n            position = this.reposition.offset(target, position, container); // Adjust for position.fixed tooltips (and also iOS scroll bug in v3.2-4.0 & v4.3-4.3.2)\n\n            if (BROWSER.iOS > 3.1 && BROWSER.iOS < 4.1 || BROWSER.iOS >= 4.3 && BROWSER.iOS < 4.33 || !BROWSER.iOS && type === 'fixed') {\n              position.left -= win.scrollLeft();\n              position.top -= win.scrollTop();\n            } // Adjust position relative to target\n\n\n            if (!pluginCalculations || pluginCalculations && pluginCalculations.adjustable !== FALSE) {\n              position.left += at.x === RIGHT ? targetWidth : at.x === CENTER ? targetWidth / 2 : 0;\n              position.top += at.y === BOTTOM ? targetHeight : at.y === CENTER ? targetHeight / 2 : 0;\n            }\n          } // Adjust position relative to tooltip\n\n\n      position.left += adjust.x + (my.x === RIGHT ? -tooltipWidth : my.x === CENTER ? -tooltipWidth / 2 : 0);\n      position.top += adjust.y + (my.y === BOTTOM ? -tooltipHeight : my.y === CENTER ? -tooltipHeight / 2 : 0); // Use viewport adjustment plugin if enabled\n\n      if (PLUGINS.viewport) {\n        adjusted = position.adjusted = PLUGINS.viewport(this, position, posOptions, targetWidth, targetHeight, tooltipWidth, tooltipHeight); // Apply offsets supplied by positioning plugin (if used)\n\n        if (offset && adjusted.left) {\n          position.left += offset.left;\n        }\n\n        if (offset && adjusted.top) {\n          position.top += offset.top;\n        } // Apply any new 'my' position\n\n\n        if (adjusted.my) {\n          this.position.my = adjusted.my;\n        }\n      } // Viewport adjustment is disabled, set values to zero\n      else {\n          position.adjusted = {\n            left: 0,\n            top: 0\n          };\n        } // Set tooltip position class if it's changed\n\n\n      if (cache.posClass !== (newClass = this._createPosClass(this.position.my))) {\n        cache.posClass = newClass;\n        tooltip.removeClass(cache.posClass).addClass(newClass);\n      } // tooltipmove event\n\n\n      if (!this._trigger('move', [position, viewport.elem || viewport], event)) {\n        return this;\n      }\n\n      delete position.adjusted; // If effect is disabled, target it mouse, no animation is defined or positioning gives NaN out, set CSS directly\n\n      if (effect === FALSE || !visible || isNaN(position.left) || isNaN(position.top) || target === 'mouse' || !$.isFunction(posOptions.effect)) {\n        tooltip.css(position);\n      } // Use custom function if provided\n      else if ($.isFunction(posOptions.effect)) {\n          posOptions.effect.call(tooltip, this, $.extend({}, position));\n          tooltip.queue(function (next) {\n            // Reset attributes to avoid cross-browser rendering bugs\n            $(this).css({\n              opacity: '',\n              height: ''\n            });\n\n            if (BROWSER.ie) {\n              this.style.removeAttribute('filter');\n            }\n\n            next();\n          });\n        } // Set positioning flag\n\n\n      this.positioning = FALSE;\n      return this;\n    }; // Custom (more correct for qTip!) offset calculator\n\n\n    PROTOTYPE.reposition.offset = function (elem, pos, container) {\n      if (!container[0]) {\n        return pos;\n      }\n\n      var ownerDocument = $(elem[0].ownerDocument),\n          quirks = !!BROWSER.ie && document.compatMode !== 'CSS1Compat',\n          parent = container[0],\n          scrolled,\n          position,\n          parentOffset,\n          overflow;\n\n      function scroll(e, i) {\n        pos.left += i * e.scrollLeft();\n        pos.top += i * e.scrollTop();\n      } // Compensate for non-static containers offset\n\n\n      do {\n        if ((position = $.css(parent, 'position')) !== 'static') {\n          if (position === 'fixed') {\n            parentOffset = parent.getBoundingClientRect();\n            scroll(ownerDocument, -1);\n          } else {\n            parentOffset = $(parent).position();\n            parentOffset.left += parseFloat($.css(parent, 'borderLeftWidth')) || 0;\n            parentOffset.top += parseFloat($.css(parent, 'borderTopWidth')) || 0;\n          }\n\n          pos.left -= parentOffset.left + (parseFloat($.css(parent, 'marginLeft')) || 0);\n          pos.top -= parentOffset.top + (parseFloat($.css(parent, 'marginTop')) || 0); // If this is the first parent element with an overflow of \"scroll\" or \"auto\", store it\n\n          if (!scrolled && (overflow = $.css(parent, 'overflow')) !== 'hidden' && overflow !== 'visible') {\n            scrolled = $(parent);\n          }\n        }\n      } while (parent = parent.offsetParent); // Compensate for containers scroll if it also has an offsetParent (or in IE quirks mode)\n\n\n      if (scrolled && (scrolled[0] !== ownerDocument[0] || quirks)) {\n        scroll(scrolled, 1);\n      }\n\n      return pos;\n    }; // Corner class\n\n\n    var C = (CORNER = PROTOTYPE.reposition.Corner = function (corner, forceY) {\n      corner = ('' + corner).replace(/([A-Z])/, ' $1').replace(/middle/gi, CENTER).toLowerCase();\n      this.x = (corner.match(/left|right/i) || corner.match(/center/) || ['inherit'])[0].toLowerCase();\n      this.y = (corner.match(/top|bottom|center/i) || ['inherit'])[0].toLowerCase();\n      this.forceY = !!forceY;\n      var f = corner.charAt(0);\n      this.precedance = f === 't' || f === 'b' ? Y : X;\n    }).prototype;\n\n    C.invert = function (z, center) {\n      this[z] = this[z] === LEFT ? RIGHT : this[z] === RIGHT ? LEFT : center || this[z];\n    };\n\n    C.string = function (join) {\n      var x = this.x,\n          y = this.y;\n      var result = x !== y ? x === 'center' || y !== 'center' && (this.precedance === Y || this.forceY) ? [y, x] : [x, y] : [x];\n      return join !== false ? result.join(' ') : result;\n    };\n\n    C.abbrev = function () {\n      var result = this.string(false);\n      return result[0].charAt(0) + (result[1] && result[1].charAt(0) || '');\n    };\n\n    C.clone = function () {\n      return new CORNER(this.string(), this.forceY);\n    };\n\n    ;\n\n    PROTOTYPE.toggle = function (state, event) {\n      var cache = this.cache,\n          options = this.options,\n          tooltip = this.tooltip; // Try to prevent flickering when tooltip overlaps show element\n\n      if (event) {\n        if (/over|enter/.test(event.type) && cache.event && /out|leave/.test(cache.event.type) && options.show.target.add(event.target).length === options.show.target.length && tooltip.has(event.relatedTarget).length) {\n          return this;\n        } // Cache event\n\n\n        cache.event = $.event.fix(event);\n      } // If we're currently waiting and we've just hidden... stop it\n\n\n      this.waiting && !state && (this.hiddenDuringWait = TRUE); // Render the tooltip if showing and it isn't already\n\n      if (!this.rendered) {\n        return state ? this.render(1) : this;\n      } else if (this.destroyed || this.disabled) {\n        return this;\n      }\n\n      var type = state ? 'show' : 'hide',\n          opts = this.options[type],\n          posOptions = this.options.position,\n          contentOptions = this.options.content,\n          width = this.tooltip.css('width'),\n          visible = this.tooltip.is(':visible'),\n          animate = state || opts.target.length === 1,\n          sameTarget = !event || opts.target.length < 2 || cache.target[0] === event.target,\n          identicalState,\n          allow,\n          after; // Detect state if valid one isn't provided\n\n      if ((typeof state).search('boolean|number')) {\n        state = !visible;\n      } // Check if the tooltip is in an identical state to the new would-be state\n\n\n      identicalState = !tooltip.is(':animated') && visible === state && sameTarget; // Fire tooltip(show/hide) event and check if destroyed\n\n      allow = !identicalState ? !!this._trigger(type, [90]) : NULL; // Check to make sure the tooltip wasn't destroyed in the callback\n\n      if (this.destroyed) {\n        return this;\n      } // If the user didn't stop the method prematurely and we're showing the tooltip, focus it\n\n\n      if (allow !== FALSE && state) {\n        this.focus(event);\n      } // If the state hasn't changed or the user stopped it, return early\n\n\n      if (!allow || identicalState) {\n        return this;\n      } // Set ARIA hidden attribute\n\n\n      $.attr(tooltip[0], 'aria-hidden', !!!state); // Execute state specific properties\n\n      if (state) {\n        // Store show origin coordinates\n        this.mouse && (cache.origin = $.event.fix(this.mouse)); // Update tooltip content & title if it's a dynamic function\n\n        if ($.isFunction(contentOptions.text)) {\n          this._updateContent(contentOptions.text, FALSE);\n        }\n\n        if ($.isFunction(contentOptions.title)) {\n          this._updateTitle(contentOptions.title, FALSE);\n        } // Cache mousemove events for positioning purposes (if not already tracking)\n\n\n        if (!trackingBound && posOptions.target === 'mouse' && posOptions.adjust.mouse) {\n          $(document).bind('mousemove.' + NAMESPACE, this._storeMouse);\n          trackingBound = TRUE;\n        } // Update the tooltip position (set width first to prevent viewport/max-width issues)\n\n\n        if (!width) {\n          tooltip.css('width', tooltip.outerWidth(FALSE));\n        }\n\n        this.reposition(event, arguments[2]);\n\n        if (!width) {\n          tooltip.css('width', '');\n        } // Hide other tooltips if tooltip is solo\n\n\n        if (!!opts.solo) {\n          (typeof opts.solo === 'string' ? $(opts.solo) : $(SELECTOR, opts.solo)).not(tooltip).not(opts.target).qtip('hide', new $.Event('tooltipsolo'));\n        }\n      } else {\n        // Clear show timer if we're hiding\n        clearTimeout(this.timers.show); // Remove cached origin on hide\n\n        delete cache.origin; // Remove mouse tracking event if not needed (all tracking qTips are hidden)\n\n        if (trackingBound && !$(SELECTOR + '[tracking=\"true\"]:visible', opts.solo).not(tooltip).length) {\n          $(document).unbind('mousemove.' + NAMESPACE);\n          trackingBound = FALSE;\n        } // Blur the tooltip\n\n\n        this.blur(event);\n      } // Define post-animation, state specific properties\n\n\n      after = $.proxy(function () {\n        if (state) {\n          // Prevent antialias from disappearing in IE by removing filter\n          if (BROWSER.ie) {\n            tooltip[0].style.removeAttribute('filter');\n          } // Remove overflow setting to prevent tip bugs\n\n\n          tooltip.css('overflow', ''); // Autofocus elements if enabled\n\n          if ('string' === typeof opts.autofocus) {\n            $(this.options.show.autofocus, tooltip).focus();\n          } // If set, hide tooltip when inactive for delay period\n\n\n          this.options.show.target.trigger('qtip-' + this.id + '-inactive');\n        } else {\n          // Reset CSS states\n          tooltip.css({\n            display: '',\n            visibility: '',\n            opacity: '',\n            left: '',\n            top: ''\n          });\n        } // tooltipvisible/tooltiphidden events\n\n\n        this._trigger(state ? 'visible' : 'hidden');\n      }, this); // If no effect type is supplied, use a simple toggle\n\n      if (opts.effect === FALSE || animate === FALSE) {\n        tooltip[type]();\n        after();\n      } // Use custom function if provided\n      else if ($.isFunction(opts.effect)) {\n          tooltip.stop(1, 1);\n          opts.effect.call(tooltip, this);\n          tooltip.queue('fx', function (n) {\n            after();\n            n();\n          });\n        } // Use basic fade function by default\n        else {\n            tooltip.fadeTo(90, state ? 1 : 0, after);\n          } // If inactive hide method is set, active it\n\n\n      if (state) {\n        opts.target.trigger('qtip-' + this.id + '-inactive');\n      }\n\n      return this;\n    };\n\n    PROTOTYPE.show = function (event) {\n      return this.toggle(TRUE, event);\n    };\n\n    PROTOTYPE.hide = function (event) {\n      return this.toggle(FALSE, event);\n    };\n\n    ;\n\n    PROTOTYPE.focus = function (event) {\n      if (!this.rendered || this.destroyed) {\n        return this;\n      }\n\n      var qtips = $(SELECTOR),\n          tooltip = this.tooltip,\n          curIndex = parseInt(tooltip[0].style.zIndex, 10),\n          newIndex = QTIP.zindex + qtips.length; // Only update the z-index if it has changed and tooltip is not already focused\n\n      if (!tooltip.hasClass(CLASS_FOCUS)) {\n        // tooltipfocus event\n        if (this._trigger('focus', [newIndex], event)) {\n          // Only update z-index's if they've changed\n          if (curIndex !== newIndex) {\n            // Reduce our z-index's and keep them properly ordered\n            qtips.each(function () {\n              if (this.style.zIndex > curIndex) {\n                this.style.zIndex = this.style.zIndex - 1;\n              }\n            }); // Fire blur event for focused tooltip\n\n            qtips.filter('.' + CLASS_FOCUS).qtip('blur', event);\n          } // Set the new z-index\n\n\n          tooltip.addClass(CLASS_FOCUS)[0].style.zIndex = newIndex;\n        }\n      }\n\n      return this;\n    };\n\n    PROTOTYPE.blur = function (event) {\n      if (!this.rendered || this.destroyed) {\n        return this;\n      } // Set focused status to FALSE\n\n\n      this.tooltip.removeClass(CLASS_FOCUS); // tooltipblur event\n\n      this._trigger('blur', [this.tooltip.css('zIndex')], event);\n\n      return this;\n    };\n\n    ;\n\n    PROTOTYPE.disable = function (state) {\n      if (this.destroyed) {\n        return this;\n      } // If 'toggle' is passed, toggle the current state\n\n\n      if (state === 'toggle') {\n        state = !(this.rendered ? this.tooltip.hasClass(CLASS_DISABLED) : this.disabled);\n      } // Disable if no state passed\n      else if ('boolean' !== typeof state) {\n          state = TRUE;\n        }\n\n      if (this.rendered) {\n        this.tooltip.toggleClass(CLASS_DISABLED, state).attr('aria-disabled', state);\n      }\n\n      this.disabled = !!state;\n      return this;\n    };\n\n    PROTOTYPE.enable = function () {\n      return this.disable(FALSE);\n    };\n\n    ;\n\n    PROTOTYPE._createButton = function () {\n      var self = this,\n          elements = this.elements,\n          tooltip = elements.tooltip,\n          button = this.options.content.button,\n          isString = typeof button === 'string',\n          close = isString ? button : 'Close tooltip';\n\n      if (elements.button) {\n        elements.button.remove();\n      } // Use custom button if one was supplied by user, else use default\n\n\n      if (button.jquery) {\n        elements.button = button;\n      } else {\n        elements.button = $('<a />', {\n          'class': 'qtip-close ' + (this.options.style.widget ? '' : NAMESPACE + '-icon'),\n          'title': close,\n          'aria-label': close\n        }).prepend($('<span />', {\n          'class': 'ui-icon ui-icon-close',\n          'html': '&times;'\n        }));\n      } // Create button and setup attributes\n\n\n      elements.button.appendTo(elements.titlebar || tooltip).attr('role', 'button').click(function (event) {\n        if (!tooltip.hasClass(CLASS_DISABLED)) {\n          self.hide(event);\n        }\n\n        return FALSE;\n      });\n    };\n\n    PROTOTYPE._updateButton = function (button) {\n      // Make sure tooltip is rendered and if not, return\n      if (!this.rendered) {\n        return FALSE;\n      }\n\n      var elem = this.elements.button;\n\n      if (button) {\n        this._createButton();\n      } else {\n        elem.remove();\n      }\n    };\n\n    ; // Widget class creator\n\n    function createWidgetClass(cls) {\n      return WIDGET.concat('').join(cls ? '-' + cls + ' ' : ' ');\n    } // Widget class setter method\n\n\n    PROTOTYPE._setWidget = function () {\n      var on = this.options.style.widget,\n          elements = this.elements,\n          tooltip = elements.tooltip,\n          disabled = tooltip.hasClass(CLASS_DISABLED);\n      tooltip.removeClass(CLASS_DISABLED);\n      CLASS_DISABLED = on ? 'ui-state-disabled' : 'qtip-disabled';\n      tooltip.toggleClass(CLASS_DISABLED, disabled);\n      tooltip.toggleClass('ui-helper-reset ' + createWidgetClass(), on).toggleClass(CLASS_DEFAULT, this.options.style.def && !on);\n\n      if (elements.content) {\n        elements.content.toggleClass(createWidgetClass('content'), on);\n      }\n\n      if (elements.titlebar) {\n        elements.titlebar.toggleClass(createWidgetClass('header'), on);\n      }\n\n      if (elements.button) {\n        elements.button.toggleClass(NAMESPACE + '-icon', !on);\n      }\n    };\n\n    ;\n\n    function delay(callback, duration) {\n      // If tooltip has displayed, start hide timer\n      if (duration > 0) {\n        return setTimeout($.proxy(callback, this), duration);\n      } else {\n        callback.call(this);\n      }\n    }\n\n    function showMethod(event) {\n      if (this.tooltip.hasClass(CLASS_DISABLED)) {\n        return;\n      } // Clear hide timers\n\n\n      clearTimeout(this.timers.show);\n      clearTimeout(this.timers.hide); // Start show timer\n\n      this.timers.show = delay.call(this, function () {\n        this.toggle(TRUE, event);\n      }, this.options.show.delay);\n    }\n\n    function hideMethod(event) {\n      if (this.tooltip.hasClass(CLASS_DISABLED) || this.destroyed) {\n        return;\n      } // Check if new target was actually the tooltip element\n\n\n      var relatedTarget = $(event.relatedTarget),\n          ontoTooltip = relatedTarget.closest(SELECTOR)[0] === this.tooltip[0],\n          ontoTarget = relatedTarget[0] === this.options.show.target[0]; // Clear timers and stop animation queue\n\n      clearTimeout(this.timers.show);\n      clearTimeout(this.timers.hide); // Prevent hiding if tooltip is fixed and event target is the tooltip.\n      // Or if mouse positioning is enabled and cursor momentarily overlaps\n\n      if (this !== relatedTarget[0] && this.options.position.target === 'mouse' && ontoTooltip || this.options.hide.fixed && /mouse(out|leave|move)/.test(event.type) && (ontoTooltip || ontoTarget)) {\n        /* eslint-disable no-empty */\n        try {\n          event.preventDefault();\n          event.stopImmediatePropagation();\n        } catch (e) {}\n        /* eslint-enable no-empty */\n\n\n        return;\n      } // If tooltip has displayed, start hide timer\n\n\n      this.timers.hide = delay.call(this, function () {\n        this.toggle(FALSE, event);\n      }, this.options.hide.delay, this);\n    }\n\n    function inactiveMethod(event) {\n      if (this.tooltip.hasClass(CLASS_DISABLED) || !this.options.hide.inactive) {\n        return;\n      } // Clear timer\n\n\n      clearTimeout(this.timers.inactive);\n      this.timers.inactive = delay.call(this, function () {\n        this.hide(event);\n      }, this.options.hide.inactive);\n    }\n\n    function repositionMethod(event) {\n      if (this.rendered && this.tooltip[0].offsetWidth > 0) {\n        this.reposition(event);\n      }\n    } // Store mouse coordinates\n\n\n    PROTOTYPE._storeMouse = function (event) {\n      (this.mouse = $.event.fix(event)).type = 'mousemove';\n      return this;\n    }; // Bind events\n\n\n    PROTOTYPE._bind = function (targets, events, method, suffix, context) {\n      if (!targets || !method || !events.length) {\n        return;\n      }\n\n      var ns = '.' + this._id + (suffix ? '-' + suffix : '');\n      $(targets).bind((events.split ? events : events.join(ns + ' ')) + ns, $.proxy(method, context || this));\n      return this;\n    };\n\n    PROTOTYPE._unbind = function (targets, suffix) {\n      targets && $(targets).unbind('.' + this._id + (suffix ? '-' + suffix : ''));\n      return this;\n    }; // Global delegation helper\n\n\n    function delegate(selector, events, method) {\n      $(document.body).delegate(selector, (events.split ? events : events.join('.' + NAMESPACE + ' ')) + '.' + NAMESPACE, function () {\n        var api = QTIP.api[$.attr(this, ATTR_ID)];\n        api && !api.disabled && method.apply(api, arguments);\n      });\n    } // Event trigger\n\n\n    PROTOTYPE._trigger = function (type, args, event) {\n      var callback = new $.Event('tooltip' + type);\n      callback.originalEvent = event && $.extend({}, event) || this.cache.event || NULL;\n      this.triggering = type;\n      this.tooltip.trigger(callback, [this].concat(args || []));\n      this.triggering = FALSE;\n      return !callback.isDefaultPrevented();\n    };\n\n    PROTOTYPE._bindEvents = function (showEvents, hideEvents, showTargets, hideTargets, showCallback, hideCallback) {\n      // Get tasrgets that lye within both\n      var similarTargets = showTargets.filter(hideTargets).add(hideTargets.filter(showTargets)),\n          toggleEvents = []; // If hide and show targets are the same...\n\n      if (similarTargets.length) {\n        // Filter identical show/hide events\n        $.each(hideEvents, function (i, type) {\n          var showIndex = $.inArray(type, showEvents); // Both events are identical, remove from both hide and show events\n          // and append to toggleEvents\n\n          showIndex > -1 && toggleEvents.push(showEvents.splice(showIndex, 1)[0]);\n        }); // Toggle events are special case of identical show/hide events, which happen in sequence\n\n        if (toggleEvents.length) {\n          // Bind toggle events to the similar targets\n          this._bind(similarTargets, toggleEvents, function (event) {\n            var state = this.rendered ? this.tooltip[0].offsetWidth > 0 : false;\n            (state ? hideCallback : showCallback).call(this, event);\n          }); // Remove the similar targets from the regular show/hide bindings\n\n\n          showTargets = showTargets.not(similarTargets);\n          hideTargets = hideTargets.not(similarTargets);\n        }\n      } // Apply show/hide/toggle events\n\n\n      this._bind(showTargets, showEvents, showCallback);\n\n      this._bind(hideTargets, hideEvents, hideCallback);\n    };\n\n    PROTOTYPE._assignInitialEvents = function (event) {\n      var options = this.options,\n          showTarget = options.show.target,\n          hideTarget = options.hide.target,\n          showEvents = options.show.event ? $.trim('' + options.show.event).split(' ') : [],\n          hideEvents = options.hide.event ? $.trim('' + options.hide.event).split(' ') : []; // Catch remove/removeqtip events on target element to destroy redundant tooltips\n\n      this._bind(this.elements.target, ['remove', 'removeqtip'], function () {\n        this.destroy(true);\n      }, 'destroy');\n      /*\n       * Make sure hoverIntent functions properly by using mouseleave as a hide event if\n       * mouseenter/mouseout is used for show.event, even if it isn't in the users options.\n       */\n\n\n      if (/mouse(over|enter)/i.test(options.show.event) && !/mouse(out|leave)/i.test(options.hide.event)) {\n        hideEvents.push('mouseleave');\n      }\n      /*\n       * Also make sure initial mouse targetting works correctly by caching mousemove coords\n       * on show targets before the tooltip has rendered. Also set onTarget when triggered to\n       * keep mouse tracking working.\n       */\n\n\n      this._bind(showTarget, 'mousemove', function (moveEvent) {\n        this._storeMouse(moveEvent);\n\n        this.cache.onTarget = TRUE;\n      }); // Define hoverIntent function\n\n\n      function hoverIntent(hoverEvent) {\n        // Only continue if tooltip isn't disabled\n        if (this.disabled || this.destroyed) {\n          return FALSE;\n        } // Cache the event data\n\n\n        this.cache.event = hoverEvent && $.event.fix(hoverEvent);\n        this.cache.target = hoverEvent && $(hoverEvent.target); // Start the event sequence\n\n        clearTimeout(this.timers.show);\n        this.timers.show = delay.call(this, function () {\n          this.render(typeof hoverEvent === 'object' || options.show.ready);\n        }, options.prerender ? 0 : options.show.delay);\n      } // Filter and bind events\n\n\n      this._bindEvents(showEvents, hideEvents, showTarget, hideTarget, hoverIntent, function () {\n        if (!this.timers) {\n          return FALSE;\n        }\n\n        clearTimeout(this.timers.show);\n      }); // Prerendering is enabled, create tooltip now\n\n\n      if (options.show.ready || options.prerender) {\n        hoverIntent.call(this, event);\n      }\n    }; // Event assignment method\n\n\n    PROTOTYPE._assignEvents = function () {\n      var self = this,\n          options = this.options,\n          posOptions = options.position,\n          tooltip = this.tooltip,\n          showTarget = options.show.target,\n          hideTarget = options.hide.target,\n          containerTarget = posOptions.container,\n          viewportTarget = posOptions.viewport,\n          documentTarget = $(document),\n          windowTarget = $(window),\n          showEvents = options.show.event ? $.trim('' + options.show.event).split(' ') : [],\n          hideEvents = options.hide.event ? $.trim('' + options.hide.event).split(' ') : []; // Assign passed event callbacks\n\n      $.each(options.events, function (name, callback) {\n        self._bind(tooltip, name === 'toggle' ? ['tooltipshow', 'tooltiphide'] : ['tooltip' + name], callback, null, tooltip);\n      }); // Hide tooltips when leaving current window/frame (but not select/option elements)\n\n      if (/mouse(out|leave)/i.test(options.hide.event) && options.hide.leave === 'window') {\n        this._bind(documentTarget, ['mouseout', 'blur'], function (event) {\n          if (!/select|option/.test(event.target.nodeName) && !event.relatedTarget) {\n            this.hide(event);\n          }\n        });\n      } // Enable hide.fixed by adding appropriate class\n\n\n      if (options.hide.fixed) {\n        hideTarget = hideTarget.add(tooltip.addClass(CLASS_FIXED));\n      }\n      /*\n       * Make sure hoverIntent functions properly by using mouseleave to clear show timer if\n       * mouseenter/mouseout is used for show.event, even if it isn't in the users options.\n       */\n      else if (/mouse(over|enter)/i.test(options.show.event)) {\n          this._bind(hideTarget, 'mouseleave', function () {\n            clearTimeout(this.timers.show);\n          });\n        } // Hide tooltip on document mousedown if unfocus events are enabled\n\n\n      if (('' + options.hide.event).indexOf('unfocus') > -1) {\n        this._bind(containerTarget.closest('html'), ['mousedown', 'touchstart'], function (event) {\n          var elem = $(event.target),\n              enabled = this.rendered && !this.tooltip.hasClass(CLASS_DISABLED) && this.tooltip[0].offsetWidth > 0,\n              isAncestor = elem.parents(SELECTOR).filter(this.tooltip[0]).length > 0;\n\n          if (elem[0] !== this.target[0] && elem[0] !== this.tooltip[0] && !isAncestor && !this.target.has(elem[0]).length && enabled) {\n            this.hide(event);\n          }\n        });\n      } // Check if the tooltip hides when inactive\n\n\n      if ('number' === typeof options.hide.inactive) {\n        // Bind inactive method to show target(s) as a custom event\n        this._bind(showTarget, 'qtip-' + this.id + '-inactive', inactiveMethod, 'inactive'); // Define events which reset the 'inactive' event handler\n\n\n        this._bind(hideTarget.add(tooltip), QTIP.inactiveEvents, inactiveMethod);\n      } // Filter and bind events\n\n\n      this._bindEvents(showEvents, hideEvents, showTarget, hideTarget, showMethod, hideMethod); // Mouse movement bindings\n\n\n      this._bind(showTarget.add(tooltip), 'mousemove', function (event) {\n        // Check if the tooltip hides when mouse is moved a certain distance\n        if ('number' === typeof options.hide.distance) {\n          var origin = this.cache.origin || {},\n              limit = this.options.hide.distance,\n              abs = Math.abs; // Check if the movement has gone beyond the limit, and hide it if so\n\n          if (abs(event.pageX - origin.pageX) >= limit || abs(event.pageY - origin.pageY) >= limit) {\n            this.hide(event);\n          }\n        } // Cache mousemove coords on show targets\n\n\n        this._storeMouse(event);\n      }); // Mouse positioning events\n\n\n      if (posOptions.target === 'mouse') {\n        // If mouse adjustment is on...\n        if (posOptions.adjust.mouse) {\n          // Apply a mouseleave event so we don't get problems with overlapping\n          if (options.hide.event) {\n            // Track if we're on the target or not\n            this._bind(showTarget, ['mouseenter', 'mouseleave'], function (event) {\n              if (!this.cache) {\n                return FALSE;\n              }\n\n              this.cache.onTarget = event.type === 'mouseenter';\n            });\n          } // Update tooltip position on mousemove\n\n\n          this._bind(documentTarget, 'mousemove', function (event) {\n            // Update the tooltip position only if the tooltip is visible and adjustment is enabled\n            if (this.rendered && this.cache.onTarget && !this.tooltip.hasClass(CLASS_DISABLED) && this.tooltip[0].offsetWidth > 0) {\n              this.reposition(event);\n            }\n          });\n        }\n      } // Adjust positions of the tooltip on window resize if enabled\n\n\n      if (posOptions.adjust.resize || viewportTarget.length) {\n        this._bind($.event.special.resize ? viewportTarget : windowTarget, 'resize', repositionMethod);\n      } // Adjust tooltip position on scroll of the window or viewport element if present\n\n\n      if (posOptions.adjust.scroll) {\n        this._bind(windowTarget.add(posOptions.container), 'scroll', repositionMethod);\n      }\n    }; // Un-assignment method\n\n\n    PROTOTYPE._unassignEvents = function () {\n      var options = this.options,\n          showTargets = options.show.target,\n          hideTargets = options.hide.target,\n          targets = $.grep([this.elements.target[0], this.rendered && this.tooltip[0], options.position.container[0], options.position.viewport[0], options.position.container.closest('html')[0], // unfocus\n      window, document], function (i) {\n        return typeof i === 'object';\n      }); // Add show and hide targets if they're valid\n\n      if (showTargets && showTargets.toArray) {\n        targets = targets.concat(showTargets.toArray());\n      }\n\n      if (hideTargets && hideTargets.toArray) {\n        targets = targets.concat(hideTargets.toArray());\n      } // Unbind the events\n\n\n      this._unbind(targets)._unbind(targets, 'destroy')._unbind(targets, 'inactive');\n    }; // Apply common event handlers using delegate (avoids excessive .bind calls!)\n\n\n    $(function () {\n      delegate(SELECTOR, ['mouseenter', 'mouseleave'], function (event) {\n        var state = event.type === 'mouseenter',\n            tooltip = $(event.currentTarget),\n            target = $(event.relatedTarget || event.target),\n            options = this.options; // On mouseenter...\n\n        if (state) {\n          // Focus the tooltip on mouseenter (z-index stacking)\n          this.focus(event); // Clear hide timer on tooltip hover to prevent it from closing\n\n          tooltip.hasClass(CLASS_FIXED) && !tooltip.hasClass(CLASS_DISABLED) && clearTimeout(this.timers.hide);\n        } // On mouseleave...\n        else {\n            // When mouse tracking is enabled, hide when we leave the tooltip and not onto the show target (if a hide event is set)\n            if (options.position.target === 'mouse' && options.position.adjust.mouse && options.hide.event && options.show.target && !target.closest(options.show.target[0]).length) {\n              this.hide(event);\n            }\n          } // Add hover class\n\n\n        tooltip.toggleClass(CLASS_HOVER, state);\n      }); // Define events which reset the 'inactive' event handler\n\n      delegate('[' + ATTR_ID + ']', INACTIVE_EVENTS, inactiveMethod);\n    });\n    ; // Initialization method\n\n    function init(elem, id, opts) {\n      var obj,\n          posOptions,\n          attr,\n          config,\n          title,\n          // Setup element references\n      docBody = $(document.body),\n          // Use document body instead of document element if needed\n      newTarget = elem[0] === document ? docBody : elem,\n          // Grab metadata from element if plugin is present\n      metadata = elem.metadata ? elem.metadata(opts.metadata) : NULL,\n          // If metadata type if HTML5, grab 'name' from the object instead, or use the regular data object otherwise\n      metadata5 = opts.metadata.type === 'html5' && metadata ? metadata[opts.metadata.name] : NULL,\n          // Grab data from metadata.name (or data-qtipopts as fallback) using .data() method,\n      html5 = elem.data(opts.metadata.name || 'qtipopts'); // If we don't get an object returned attempt to parse it manualyl without parseJSON\n\n      /* eslint-disable no-empty */\n\n      try {\n        html5 = typeof html5 === 'string' ? $.parseJSON(html5) : html5;\n      } catch (e) {}\n      /* eslint-enable no-empty */\n      // Merge in and sanitize metadata\n\n\n      config = $.extend(TRUE, {}, QTIP.defaults, opts, typeof html5 === 'object' ? sanitizeOptions(html5) : NULL, sanitizeOptions(metadata5 || metadata)); // Re-grab our positioning options now we've merged our metadata and set id to passed value\n\n      posOptions = config.position;\n      config.id = id; // Setup missing content if none is detected\n\n      if ('boolean' === typeof config.content.text) {\n        attr = elem.attr(config.content.attr); // Grab from supplied attribute if available\n\n        if (config.content.attr !== FALSE && attr) {\n          config.content.text = attr;\n        } // No valid content was found, abort render\n        else {\n            return FALSE;\n          }\n      } // Setup target options\n\n\n      if (!posOptions.container.length) {\n        posOptions.container = docBody;\n      }\n\n      if (posOptions.target === FALSE) {\n        posOptions.target = newTarget;\n      }\n\n      if (config.show.target === FALSE) {\n        config.show.target = newTarget;\n      }\n\n      if (config.show.solo === TRUE) {\n        config.show.solo = posOptions.container.closest('body');\n      }\n\n      if (config.hide.target === FALSE) {\n        config.hide.target = newTarget;\n      }\n\n      if (config.position.viewport === TRUE) {\n        config.position.viewport = posOptions.container;\n      } // Ensure we only use a single container\n\n\n      posOptions.container = posOptions.container.eq(0); // Convert position corner values into x and y strings\n\n      posOptions.at = new CORNER(posOptions.at, TRUE);\n      posOptions.my = new CORNER(posOptions.my); // Destroy previous tooltip if overwrite is enabled, or skip element if not\n\n      if (elem.data(NAMESPACE)) {\n        if (config.overwrite) {\n          elem.qtip('destroy', true);\n        } else if (config.overwrite === FALSE) {\n          return FALSE;\n        }\n      } // Add has-qtip attribute\n\n\n      elem.attr(ATTR_HAS, id); // Remove title attribute and store it if present\n\n      if (config.suppress && (title = elem.attr('title'))) {\n        // Final attr call fixes event delegatiom and IE default tooltip showing problem\n        elem.removeAttr('title').attr(oldtitle, title).attr('title', '');\n      } // Initialize the tooltip and add API reference\n\n\n      obj = new QTip(elem, config, id, !!attr);\n      elem.data(NAMESPACE, obj);\n      return obj;\n    } // jQuery $.fn extension method\n\n\n    QTIP = $.fn.qtip = function (options, notation, newValue) {\n      var command = ('' + options).toLowerCase(),\n          // Parse command\n      returned = NULL,\n          args = $.makeArray(arguments).slice(1),\n          event = args[args.length - 1],\n          opts = this[0] ? $.data(this[0], NAMESPACE) : NULL; // Check for API request\n\n      if (!arguments.length && opts || command === 'api') {\n        return opts;\n      } // Execute API command if present\n      else if ('string' === typeof options) {\n          this.each(function () {\n            var api = $.data(this, NAMESPACE);\n\n            if (!api) {\n              return TRUE;\n            } // Cache the event if possible\n\n\n            if (event && event.timeStamp) {\n              api.cache.event = event;\n            } // Check for specific API commands\n\n\n            if (notation && (command === 'option' || command === 'options')) {\n              if (newValue !== undefined || $.isPlainObject(notation)) {\n                api.set(notation, newValue);\n              } else {\n                returned = api.get(notation);\n                return FALSE;\n              }\n            } // Execute API command\n            else if (api[command]) {\n                api[command].apply(api, args);\n              }\n          });\n          return returned !== NULL ? returned : this;\n        } // No API commands. validate provided options and setup qTips\n        else if ('object' === typeof options || !arguments.length) {\n            // Sanitize options first\n            opts = sanitizeOptions($.extend(TRUE, {}, options));\n            return this.each(function (i) {\n              var api, id; // Find next available ID, or use custom ID if provided\n\n              id = $.isArray(opts.id) ? opts.id[i] : opts.id;\n              id = !id || id === FALSE || id.length < 1 || QTIP.api[id] ? QTIP.nextid++ : id; // Initialize the qTip and re-grab newly sanitized options\n\n              api = init($(this), id, opts);\n\n              if (api === FALSE) {\n                return TRUE;\n              } else {\n                QTIP.api[id] = api;\n              } // Initialize plugins\n\n\n              $.each(PLUGINS, function () {\n                if (this.initialize === 'initialize') {\n                  this(api);\n                }\n              }); // Assign initial pre-render events\n\n              api._assignInitialEvents(event);\n            });\n          }\n    }; // Expose class\n\n\n    $.qtip = QTip; // Populated in render method\n\n    QTIP.api = {};\n    ;\n    $.each({\n      /* Allow other plugins to successfully retrieve the title of an element with a qTip applied */\n      attr: function (attr, val) {\n        if (this.length) {\n          var self = this[0],\n              title = 'title',\n              api = $.data(self, 'qtip');\n\n          if (attr === title && api && api.options && 'object' === typeof api && 'object' === typeof api.options && api.options.suppress) {\n            if (arguments.length < 2) {\n              return $.attr(self, oldtitle);\n            } // If qTip is rendered and title was originally used as content, update it\n\n\n            if (api && api.options.content.attr === title && api.cache.attr) {\n              api.set('content.text', val);\n            } // Use the regular attr method to set, then cache the result\n\n\n            return this.attr(oldtitle, val);\n          }\n        }\n\n        return $.fn['attr' + replaceSuffix].apply(this, arguments);\n      },\n\n      /* Allow clone to correctly retrieve cached title attributes */\n      clone: function (keepData) {\n        // Clone our element using the real clone method\n        var elems = $.fn['clone' + replaceSuffix].apply(this, arguments); // Grab all elements with an oldtitle set, and change it to regular title attribute, if keepData is false\n\n        if (!keepData) {\n          elems.filter('[' + oldtitle + ']').attr('title', function () {\n            return $.attr(this, oldtitle);\n          }).removeAttr(oldtitle);\n        }\n\n        return elems;\n      }\n    }, function (name, func) {\n      if (!func || $.fn[name + replaceSuffix]) {\n        return TRUE;\n      }\n\n      var old = $.fn[name + replaceSuffix] = $.fn[name];\n\n      $.fn[name] = function () {\n        return func.apply(this, arguments) || old.apply(this, arguments);\n      };\n    });\n    /* Fire off 'removeqtip' handler in $.cleanData if jQuery UI not present (it already does similar).\n     * This snippet is taken directly from jQuery UI source code found here:\n     *     http://code.jquery.com/ui/jquery-ui-git.js\n     */\n\n    if (!$.ui) {\n      $['cleanData' + replaceSuffix] = $.cleanData;\n\n      $.cleanData = function (elems) {\n        for (var i = 0, elem; (elem = $(elems[i])).length; i++) {\n          if (elem.attr(ATTR_HAS)) {\n            /* eslint-disable no-empty */\n            try {\n              elem.triggerHandler('removeqtip');\n            } catch (e) {}\n            /* eslint-enable no-empty */\n\n          }\n        }\n\n        $['cleanData' + replaceSuffix].apply(this, arguments);\n      };\n    }\n\n    ; // qTip version\n\n    QTIP.version = '3.0.3'; // Base ID for all qTips\n\n    QTIP.nextid = 0; // Inactive events array\n\n    QTIP.inactiveEvents = INACTIVE_EVENTS; // Base z-index for all qTips\n\n    QTIP.zindex = 15000; // Define configuration defaults\n\n    QTIP.defaults = {\n      prerender: FALSE,\n      id: FALSE,\n      overwrite: TRUE,\n      suppress: TRUE,\n      content: {\n        text: TRUE,\n        attr: 'title',\n        title: FALSE,\n        button: FALSE\n      },\n      position: {\n        my: 'top left',\n        at: 'bottom right',\n        target: FALSE,\n        container: FALSE,\n        viewport: FALSE,\n        adjust: {\n          x: 0,\n          y: 0,\n          mouse: TRUE,\n          scroll: TRUE,\n          resize: TRUE,\n          method: 'flipinvert flipinvert'\n        },\n        effect: function (api, pos) {\n          $(this).animate(pos, {\n            duration: 200,\n            queue: FALSE\n          });\n        }\n      },\n      show: {\n        target: FALSE,\n        event: 'mouseenter',\n        effect: TRUE,\n        delay: 90,\n        solo: FALSE,\n        ready: FALSE,\n        autofocus: FALSE\n      },\n      hide: {\n        target: FALSE,\n        event: 'mouseleave',\n        effect: TRUE,\n        delay: 0,\n        fixed: FALSE,\n        inactive: FALSE,\n        leave: 'window',\n        distance: FALSE\n      },\n      style: {\n        classes: '',\n        widget: FALSE,\n        width: FALSE,\n        height: FALSE,\n        def: TRUE\n      },\n      events: {\n        render: NULL,\n        move: NULL,\n        show: NULL,\n        hide: NULL,\n        toggle: NULL,\n        visible: NULL,\n        hidden: NULL,\n        focus: NULL,\n        blur: NULL\n      }\n    };\n    ;\n    var TIP,\n        createVML,\n        SCALE,\n        PIXEL_RATIO,\n        BACKING_STORE_RATIO,\n        // Common CSS strings\n    MARGIN = 'margin',\n        BORDER = 'border',\n        COLOR = 'color',\n        BG_COLOR = 'background-color',\n        TRANSPARENT = 'transparent',\n        IMPORTANT = ' !important',\n        // Check if the browser supports <canvas/> elements\n    HASCANVAS = !!document.createElement('canvas').getContext,\n        // Invalid colour values used in parseColours()\n    INVALID = /rgba?\\(0, 0, 0(, 0)?\\)|transparent|#123456/i; // Camel-case method, taken from jQuery source\n    // http://code.jquery.com/jquery-1.8.0.js\n\n    function camel(s) {\n      return s.charAt(0).toUpperCase() + s.slice(1);\n    }\n    /*\n     * Modified from Modernizr's testPropsAll()\n     * http://modernizr.com/downloads/modernizr-latest.js\n     */\n\n\n    var cssProps = {},\n        cssPrefixes = ['Webkit', 'O', 'Moz', 'ms'];\n\n    function vendorCss(elem, prop) {\n      var ucProp = prop.charAt(0).toUpperCase() + prop.slice(1),\n          props = (prop + ' ' + cssPrefixes.join(ucProp + ' ') + ucProp).split(' '),\n          cur,\n          val,\n          i = 0; // If the property has already been mapped...\n\n      if (cssProps[prop]) {\n        return elem.css(cssProps[prop]);\n      }\n\n      while (cur = props[i++]) {\n        if ((val = elem.css(cur)) !== undefined) {\n          cssProps[prop] = cur;\n          return val;\n        }\n      }\n    } // Parse a given elements CSS property into an int\n\n\n    function intCss(elem, prop) {\n      return Math.ceil(parseFloat(vendorCss(elem, prop)));\n    } // VML creation (for IE only)\n\n\n    if (!HASCANVAS) {\n      createVML = function (tag, props, style) {\n        return '<qtipvml:' + tag + ' xmlns=\"urn:schemas-microsoft.com:vml\" class=\"qtip-vml\" ' + (props || '') + ' style=\"behavior: url(#default#VML); ' + (style || '') + '\" />';\n      };\n    } // Canvas only definitions\n    else {\n        PIXEL_RATIO = window.devicePixelRatio || 1;\n\n        BACKING_STORE_RATIO = function () {\n          var context = document.createElement('canvas').getContext('2d');\n          return context.backingStorePixelRatio || context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || 1;\n        }();\n\n        SCALE = PIXEL_RATIO / BACKING_STORE_RATIO;\n      }\n\n    function Tip(qtip, options) {\n      this._ns = 'tip';\n      this.options = options;\n      this.offset = options.offset;\n      this.size = [options.width, options.height]; // Initialize\n\n      this.qtip = qtip;\n      this.init(qtip);\n    }\n\n    $.extend(Tip.prototype, {\n      init: function (qtip) {\n        var context, tip; // Create tip element and prepend to the tooltip\n\n        tip = this.element = qtip.elements.tip = $('<div />', {\n          'class': NAMESPACE + '-tip'\n        }).prependTo(qtip.tooltip); // Create tip drawing element(s)\n\n        if (HASCANVAS) {\n          // save() as soon as we create the canvas element so FF2 doesn't bork on our first restore()!\n          context = $('<canvas />').appendTo(this.element)[0].getContext('2d'); // Setup constant parameters\n\n          context.lineJoin = 'miter';\n          context.miterLimit = 100000;\n          context.save();\n        } else {\n          context = createVML('shape', 'coordorigin=\"0,0\"', 'position:absolute;');\n          this.element.html(context + context); // Prevent mousing down on the tip since it causes problems with .live() handling in IE due to VML\n\n          qtip._bind($('*', tip).add(tip), ['click', 'mousedown'], function (event) {\n            event.stopPropagation();\n          }, this._ns);\n        } // Bind update events\n\n\n        qtip._bind(qtip.tooltip, 'tooltipmove', this.reposition, this._ns, this); // Create it\n\n\n        this.create();\n      },\n      _swapDimensions: function () {\n        this.size[0] = this.options.height;\n        this.size[1] = this.options.width;\n      },\n      _resetDimensions: function () {\n        this.size[0] = this.options.width;\n        this.size[1] = this.options.height;\n      },\n      _useTitle: function (corner) {\n        var titlebar = this.qtip.elements.titlebar;\n        return titlebar && (corner.y === TOP || corner.y === CENTER && this.element.position().top + this.size[1] / 2 + this.options.offset < titlebar.outerHeight(TRUE));\n      },\n      _parseCorner: function (corner) {\n        var my = this.qtip.options.position.my; // Detect corner and mimic properties\n\n        if (corner === FALSE || my === FALSE) {\n          corner = FALSE;\n        } else if (corner === TRUE) {\n          corner = new CORNER(my.string());\n        } else if (!corner.string) {\n          corner = new CORNER(corner);\n          corner.fixed = TRUE;\n        }\n\n        return corner;\n      },\n      _parseWidth: function (corner, side, use) {\n        var elements = this.qtip.elements,\n            prop = BORDER + camel(side) + 'Width';\n        return (use ? intCss(use, prop) : intCss(elements.content, prop) || intCss(this._useTitle(corner) && elements.titlebar || elements.content, prop) || intCss(elements.tooltip, prop)) || 0;\n      },\n      _parseRadius: function (corner) {\n        var elements = this.qtip.elements,\n            prop = BORDER + camel(corner.y) + camel(corner.x) + 'Radius';\n        return BROWSER.ie < 9 ? 0 : intCss(this._useTitle(corner) && elements.titlebar || elements.content, prop) || intCss(elements.tooltip, prop) || 0;\n      },\n      _invalidColour: function (elem, prop, compare) {\n        var val = elem.css(prop);\n        return !val || compare && val === elem.css(compare) || INVALID.test(val) ? FALSE : val;\n      },\n      _parseColours: function (corner) {\n        var elements = this.qtip.elements,\n            tip = this.element.css('cssText', ''),\n            borderSide = BORDER + camel(corner[corner.precedance]) + camel(COLOR),\n            colorElem = this._useTitle(corner) && elements.titlebar || elements.content,\n            css = this._invalidColour,\n            color = []; // Attempt to detect the background colour from various elements, left-to-right precedance\n\n        color[0] = css(tip, BG_COLOR) || css(colorElem, BG_COLOR) || css(elements.content, BG_COLOR) || css(elements.tooltip, BG_COLOR) || tip.css(BG_COLOR); // Attempt to detect the correct border side colour from various elements, left-to-right precedance\n\n        color[1] = css(tip, borderSide, COLOR) || css(colorElem, borderSide, COLOR) || css(elements.content, borderSide, COLOR) || css(elements.tooltip, borderSide, COLOR) || elements.tooltip.css(borderSide); // Reset background and border colours\n\n        $('*', tip).add(tip).css('cssText', BG_COLOR + ':' + TRANSPARENT + IMPORTANT + ';' + BORDER + ':0' + IMPORTANT + ';');\n        return color;\n      },\n      _calculateSize: function (corner) {\n        var y = corner.precedance === Y,\n            width = this.options.width,\n            height = this.options.height,\n            isCenter = corner.abbrev() === 'c',\n            base = (y ? width : height) * (isCenter ? 0.5 : 1),\n            pow = Math.pow,\n            round = Math.round,\n            bigHyp,\n            ratio,\n            result,\n            smallHyp = Math.sqrt(pow(base, 2) + pow(height, 2)),\n            hyp = [this.border / base * smallHyp, this.border / height * smallHyp];\n        hyp[2] = Math.sqrt(pow(hyp[0], 2) - pow(this.border, 2));\n        hyp[3] = Math.sqrt(pow(hyp[1], 2) - pow(this.border, 2));\n        bigHyp = smallHyp + hyp[2] + hyp[3] + (isCenter ? 0 : hyp[0]);\n        ratio = bigHyp / smallHyp;\n        result = [round(ratio * width), round(ratio * height)];\n        return y ? result : result.reverse();\n      },\n      // Tip coordinates calculator\n      _calculateTip: function (corner, size, scale) {\n        scale = scale || 1;\n        size = size || this.size;\n        var width = size[0] * scale,\n            height = size[1] * scale,\n            width2 = Math.ceil(width / 2),\n            height2 = Math.ceil(height / 2),\n            // Define tip coordinates in terms of height and width values\n        tips = {\n          br: [0, 0, width, height, width, 0],\n          bl: [0, 0, width, 0, 0, height],\n          tr: [0, height, width, 0, width, height],\n          tl: [0, 0, 0, height, width, height],\n          tc: [0, height, width2, 0, width, height],\n          bc: [0, 0, width, 0, width2, height],\n          rc: [0, 0, width, height2, 0, height],\n          lc: [width, 0, width, height, 0, height2]\n        }; // Set common side shapes\n\n        tips.lt = tips.br;\n        tips.rt = tips.bl;\n        tips.lb = tips.tr;\n        tips.rb = tips.tl;\n        return tips[corner.abbrev()];\n      },\n      // Tip coordinates drawer (canvas)\n      _drawCoords: function (context, coords) {\n        context.beginPath();\n        context.moveTo(coords[0], coords[1]);\n        context.lineTo(coords[2], coords[3]);\n        context.lineTo(coords[4], coords[5]);\n        context.closePath();\n      },\n      create: function () {\n        // Determine tip corner\n        var c = this.corner = (HASCANVAS || BROWSER.ie) && this._parseCorner(this.options.corner); // If we have a tip corner...\n\n\n        this.enabled = !!this.corner && this.corner.abbrev() !== 'c';\n\n        if (this.enabled) {\n          // Cache it\n          this.qtip.cache.corner = c.clone(); // Create it\n\n          this.update();\n        } // Toggle tip element\n\n\n        this.element.toggle(this.enabled);\n        return this.corner;\n      },\n      update: function (corner, position) {\n        if (!this.enabled) {\n          return this;\n        }\n\n        var elements = this.qtip.elements,\n            tip = this.element,\n            inner = tip.children(),\n            options = this.options,\n            curSize = this.size,\n            mimic = options.mimic,\n            round = Math.round,\n            color,\n            precedance,\n            context,\n            coords,\n            bigCoords,\n            translate,\n            newSize,\n            border; // Re-determine tip if not already set\n\n        if (!corner) {\n          corner = this.qtip.cache.corner || this.corner;\n        } // Use corner property if we detect an invalid mimic value\n\n\n        if (mimic === FALSE) {\n          mimic = corner;\n        } // Otherwise inherit mimic properties from the corner object as necessary\n        else {\n            mimic = new CORNER(mimic);\n            mimic.precedance = corner.precedance;\n\n            if (mimic.x === 'inherit') {\n              mimic.x = corner.x;\n            } else if (mimic.y === 'inherit') {\n              mimic.y = corner.y;\n            } else if (mimic.x === mimic.y) {\n              mimic[corner.precedance] = corner[corner.precedance];\n            }\n          }\n\n        precedance = mimic.precedance; // Ensure the tip width.height are relative to the tip position\n\n        if (corner.precedance === X) {\n          this._swapDimensions();\n        } else {\n          this._resetDimensions();\n        } // Update our colours\n\n\n        color = this.color = this._parseColours(corner); // Detect border width, taking into account colours\n\n        if (color[1] !== TRANSPARENT) {\n          // Grab border width\n          border = this.border = this._parseWidth(corner, corner[corner.precedance]); // If border width isn't zero, use border color as fill if it's not invalid (1.0 style tips)\n\n          if (options.border && border < 1 && !INVALID.test(color[1])) {\n            color[0] = color[1];\n          } // Set border width (use detected border width if options.border is true)\n\n\n          this.border = border = options.border !== TRUE ? options.border : border;\n        } // Border colour was invalid, set border to zero\n        else {\n            this.border = border = 0;\n          } // Determine tip size\n\n\n        newSize = this.size = this._calculateSize(corner);\n        tip.css({\n          width: newSize[0],\n          height: newSize[1],\n          lineHeight: newSize[1] + 'px'\n        }); // Calculate tip translation\n\n        if (corner.precedance === Y) {\n          translate = [round(mimic.x === LEFT ? border : mimic.x === RIGHT ? newSize[0] - curSize[0] - border : (newSize[0] - curSize[0]) / 2), round(mimic.y === TOP ? newSize[1] - curSize[1] : 0)];\n        } else {\n          translate = [round(mimic.x === LEFT ? newSize[0] - curSize[0] : 0), round(mimic.y === TOP ? border : mimic.y === BOTTOM ? newSize[1] - curSize[1] - border : (newSize[1] - curSize[1]) / 2)];\n        } // Canvas drawing implementation\n\n\n        if (HASCANVAS) {\n          // Grab canvas context and clear/save it\n          context = inner[0].getContext('2d');\n          context.restore();\n          context.save();\n          context.clearRect(0, 0, 6000, 6000); // Calculate coordinates\n\n          coords = this._calculateTip(mimic, curSize, SCALE);\n          bigCoords = this._calculateTip(mimic, this.size, SCALE); // Set the canvas size using calculated size\n\n          inner.attr(WIDTH, newSize[0] * SCALE).attr(HEIGHT, newSize[1] * SCALE);\n          inner.css(WIDTH, newSize[0]).css(HEIGHT, newSize[1]); // Draw the outer-stroke tip\n\n          this._drawCoords(context, bigCoords);\n\n          context.fillStyle = color[1];\n          context.fill(); // Draw the actual tip\n\n          context.translate(translate[0] * SCALE, translate[1] * SCALE);\n\n          this._drawCoords(context, coords);\n\n          context.fillStyle = color[0];\n          context.fill();\n        } // VML (IE Proprietary implementation)\n        else {\n            // Calculate coordinates\n            coords = this._calculateTip(mimic); // Setup coordinates string\n\n            coords = 'm' + coords[0] + ',' + coords[1] + ' l' + coords[2] + ',' + coords[3] + ' ' + coords[4] + ',' + coords[5] + ' xe'; // Setup VML-specific offset for pixel-perfection\n\n            translate[2] = border && /^(r|b)/i.test(corner.string()) ? BROWSER.ie === 8 ? 2 : 1 : 0; // Set initial CSS\n\n            inner.css({\n              coordsize: newSize[0] + border + ' ' + newSize[1] + border,\n              antialias: '' + (mimic.string().indexOf(CENTER) > -1),\n              left: translate[0] - translate[2] * Number(precedance === X),\n              top: translate[1] - translate[2] * Number(precedance === Y),\n              width: newSize[0] + border,\n              height: newSize[1] + border\n            }).each(function (i) {\n              var $this = $(this); // Set shape specific attributes\n\n              $this[$this.prop ? 'prop' : 'attr']({\n                coordsize: newSize[0] + border + ' ' + newSize[1] + border,\n                path: coords,\n                fillcolor: color[0],\n                filled: !!i,\n                stroked: !i\n              }).toggle(!!(border || i)); // Check if border is enabled and add stroke element\n\n              !i && $this.html(createVML('stroke', 'weight=\"' + border * 2 + 'px\" color=\"' + color[1] + '\" miterlimit=\"1000\" joinstyle=\"miter\"'));\n            });\n          } // Opera bug #357 - Incorrect tip position\n        // https://github.com/Craga89/qTip2/issues/367\n\n\n        window.opera && setTimeout(function () {\n          elements.tip.css({\n            display: 'inline-block',\n            visibility: 'visible'\n          });\n        }, 1); // Position if needed\n\n        if (position !== FALSE) {\n          this.calculate(corner, newSize);\n        }\n      },\n      calculate: function (corner, size) {\n        if (!this.enabled) {\n          return FALSE;\n        }\n\n        var self = this,\n            elements = this.qtip.elements,\n            tip = this.element,\n            userOffset = this.options.offset,\n            position = {},\n            precedance,\n            corners; // Inherit corner if not provided\n\n        corner = corner || this.corner;\n        precedance = corner.precedance; // Determine which tip dimension to use for adjustment\n\n        size = size || this._calculateSize(corner); // Setup corners and offset array\n\n        corners = [corner.x, corner.y];\n\n        if (precedance === X) {\n          corners.reverse();\n        } // Calculate tip position\n\n\n        $.each(corners, function (i, side) {\n          var b, bc, br;\n\n          if (side === CENTER) {\n            b = precedance === Y ? LEFT : TOP;\n            position[b] = '50%';\n            position[MARGIN + '-' + b] = -Math.round(size[precedance === Y ? 0 : 1] / 2) + userOffset;\n          } else {\n            b = self._parseWidth(corner, side, elements.tooltip);\n            bc = self._parseWidth(corner, side, elements.content);\n            br = self._parseRadius(corner);\n            position[side] = Math.max(-self.border, i ? bc : userOffset + (br > b ? br : -b));\n          }\n        }); // Adjust for tip size\n\n        position[corner[precedance]] -= size[precedance === X ? 0 : 1]; // Set and return new position\n\n        tip.css({\n          margin: '',\n          top: '',\n          bottom: '',\n          left: '',\n          right: ''\n        }).css(position);\n        return position;\n      },\n      reposition: function (event, api, pos) {\n        if (!this.enabled) {\n          return;\n        }\n\n        var cache = api.cache,\n            newCorner = this.corner.clone(),\n            adjust = pos.adjusted,\n            method = api.options.position.adjust.method.split(' '),\n            horizontal = method[0],\n            vertical = method[1] || method[0],\n            shift = {\n          left: FALSE,\n          top: FALSE,\n          x: 0,\n          y: 0\n        },\n            offset,\n            css = {},\n            props;\n\n        function shiftflip(direction, precedance, popposite, side, opposite) {\n          // Horizontal - Shift or flip method\n          if (direction === SHIFT && newCorner.precedance === precedance && adjust[side] && newCorner[popposite] !== CENTER) {\n            newCorner.precedance = newCorner.precedance === X ? Y : X;\n          } else if (direction !== SHIFT && adjust[side]) {\n            newCorner[precedance] = newCorner[precedance] === CENTER ? adjust[side] > 0 ? side : opposite : newCorner[precedance] === side ? opposite : side;\n          }\n        }\n\n        function shiftonly(xy, side, opposite) {\n          if (newCorner[xy] === CENTER) {\n            css[MARGIN + '-' + side] = shift[xy] = offset[MARGIN + '-' + side] - adjust[side];\n          } else {\n            props = offset[opposite] !== undefined ? [adjust[side], -offset[side]] : [-adjust[side], offset[side]];\n\n            if ((shift[xy] = Math.max(props[0], props[1])) > props[0]) {\n              pos[side] -= adjust[side];\n              shift[side] = FALSE;\n            }\n\n            css[offset[opposite] !== undefined ? opposite : side] = shift[xy];\n          }\n        } // If our tip position isn't fixed e.g. doesn't adjust with viewport...\n\n\n        if (this.corner.fixed !== TRUE) {\n          // Perform shift/flip adjustments\n          shiftflip(horizontal, X, Y, LEFT, RIGHT);\n          shiftflip(vertical, Y, X, TOP, BOTTOM); // Update and redraw the tip if needed (check cached details of last drawn tip)\n\n          if (newCorner.string() !== cache.corner.string() || cache.cornerTop !== adjust.top || cache.cornerLeft !== adjust.left) {\n            this.update(newCorner, FALSE);\n          }\n        } // Setup tip offset properties\n\n\n        offset = this.calculate(newCorner); // Readjust offset object to make it left/top\n\n        if (offset.right !== undefined) {\n          offset.left = -offset.right;\n        }\n\n        if (offset.bottom !== undefined) {\n          offset.top = -offset.bottom;\n        }\n\n        offset.user = this.offset; // Perform shift adjustments\n\n        shift.left = horizontal === SHIFT && !!adjust.left;\n\n        if (shift.left) {\n          shiftonly(X, LEFT, RIGHT);\n        }\n\n        shift.top = vertical === SHIFT && !!adjust.top;\n\n        if (shift.top) {\n          shiftonly(Y, TOP, BOTTOM);\n        }\n        /*\n        * If the tip is adjusted in both dimensions, or in a\n        * direction that would cause it to be anywhere but the\n        * outer border, hide it!\n        */\n\n\n        this.element.css(css).toggle(!(shift.x && shift.y || newCorner.x === CENTER && shift.y || newCorner.y === CENTER && shift.x)); // Adjust position to accomodate tip dimensions\n\n        pos.left -= offset.left.charAt ? offset.user : horizontal !== SHIFT || shift.top || !shift.left && !shift.top ? offset.left + this.border : 0;\n        pos.top -= offset.top.charAt ? offset.user : vertical !== SHIFT || shift.left || !shift.left && !shift.top ? offset.top + this.border : 0; // Cache details\n\n        cache.cornerLeft = adjust.left;\n        cache.cornerTop = adjust.top;\n        cache.corner = newCorner.clone();\n      },\n      destroy: function () {\n        // Unbind events\n        this.qtip._unbind(this.qtip.tooltip, this._ns); // Remove the tip element(s)\n\n\n        if (this.qtip.elements.tip) {\n          this.qtip.elements.tip.find('*').remove().end().remove();\n        }\n      }\n    });\n\n    TIP = PLUGINS.tip = function (api) {\n      return new Tip(api, api.options.style.tip);\n    }; // Initialize tip on render\n\n\n    TIP.initialize = 'render'; // Setup plugin sanitization options\n\n    TIP.sanitize = function (options) {\n      if (options.style && 'tip' in options.style) {\n        var opts = options.style.tip;\n\n        if (typeof opts !== 'object') {\n          opts = options.style.tip = {\n            corner: opts\n          };\n        }\n\n        if (!/string|boolean/i.test(typeof opts.corner)) {\n          opts.corner = TRUE;\n        }\n      }\n    }; // Add new option checks for the plugin\n\n\n    CHECKS.tip = {\n      '^position.my|style.tip.(corner|mimic|border)$': function () {\n        // Make sure a tip can be drawn\n        this.create(); // Reposition the tooltip\n\n        this.qtip.reposition();\n      },\n      '^style.tip.(height|width)$': function (obj) {\n        // Re-set dimensions and redraw the tip\n        this.size = [obj.width, obj.height];\n        this.update(); // Reposition the tooltip\n\n        this.qtip.reposition();\n      },\n      '^content.title|style.(classes|widget)$': function () {\n        this.update();\n      }\n    }; // Extend original qTip defaults\n\n    $.extend(TRUE, QTIP.defaults, {\n      style: {\n        tip: {\n          corner: TRUE,\n          mimic: FALSE,\n          width: 6,\n          height: 6,\n          border: TRUE,\n          offset: 0\n        }\n      }\n    });\n    ;\n    var MODAL,\n        OVERLAY,\n        MODALCLASS = 'qtip-modal',\n        MODALSELECTOR = '.' + MODALCLASS;\n\n    OVERLAY = function () {\n      var self = this,\n          focusableElems = {},\n          current,\n          prevState,\n          elem; // Modified code from jQuery UI 1.10.0 source\n      // http://code.jquery.com/ui/1.10.0/jquery-ui.js\n\n      function focusable(element) {\n        // Use the defined focusable checker when possible\n        if ($.expr[':'].focusable) {\n          return $.expr[':'].focusable;\n        }\n\n        var isTabIndexNotNaN = !isNaN($.attr(element, 'tabindex')),\n            nodeName = element.nodeName && element.nodeName.toLowerCase(),\n            map,\n            mapName,\n            img;\n\n        if ('area' === nodeName) {\n          map = element.parentNode;\n          mapName = map.name;\n\n          if (!element.href || !mapName || map.nodeName.toLowerCase() !== 'map') {\n            return false;\n          }\n\n          img = $('img[usemap=#' + mapName + ']')[0];\n          return !!img && img.is(':visible');\n        }\n\n        return /input|select|textarea|button|object/.test(nodeName) ? !element.disabled : 'a' === nodeName ? element.href || isTabIndexNotNaN : isTabIndexNotNaN;\n      } // Focus inputs using cached focusable elements (see update())\n\n\n      function focusInputs(blurElems) {\n        // Blurring body element in IE causes window.open windows to unfocus!\n        if (focusableElems.length < 1 && blurElems.length) {\n          blurElems.not('body').blur();\n        } // Focus the inputs\n        else {\n            focusableElems.first().focus();\n          }\n      } // Steal focus from elements outside tooltip\n\n\n      function stealFocus(event) {\n        if (!elem.is(':visible')) {\n          return;\n        }\n\n        var target = $(event.target),\n            tooltip = current.tooltip,\n            container = target.closest(SELECTOR),\n            targetOnTop; // Determine if input container target is above this\n\n        targetOnTop = container.length < 1 ? FALSE : parseInt(container[0].style.zIndex, 10) > parseInt(tooltip[0].style.zIndex, 10); // If we're showing a modal, but focus has landed on an input below\n        // this modal, divert focus to the first visible input in this modal\n        // or if we can't find one... the tooltip itself\n\n        if (!targetOnTop && target.closest(SELECTOR)[0] !== tooltip[0]) {\n          focusInputs(target);\n        }\n      }\n\n      $.extend(self, {\n        init: function () {\n          // Create document overlay\n          elem = self.elem = $('<div />', {\n            id: 'qtip-overlay',\n            html: '<div></div>',\n            mousedown: function () {\n              return FALSE;\n            }\n          }).hide(); // Make sure we can't focus anything outside the tooltip\n\n          $(document.body).bind('focusin' + MODALSELECTOR, stealFocus); // Apply keyboard \"Escape key\" close handler\n\n          $(document).bind('keydown' + MODALSELECTOR, function (event) {\n            if (current && current.options.show.modal.escape && event.keyCode === 27) {\n              current.hide(event);\n            }\n          }); // Apply click handler for blur option\n\n          elem.bind('click' + MODALSELECTOR, function (event) {\n            if (current && current.options.show.modal.blur) {\n              current.hide(event);\n            }\n          });\n          return self;\n        },\n        update: function (api) {\n          // Update current API reference\n          current = api; // Update focusable elements if enabled\n\n          if (api.options.show.modal.stealfocus !== FALSE) {\n            focusableElems = api.tooltip.find('*').filter(function () {\n              return focusable(this);\n            });\n          } else {\n            focusableElems = [];\n          }\n        },\n        toggle: function (api, state, duration) {\n          var tooltip = api.tooltip,\n              options = api.options.show.modal,\n              effect = options.effect,\n              type = state ? 'show' : 'hide',\n              visible = elem.is(':visible'),\n              visibleModals = $(MODALSELECTOR).filter(':visible:not(:animated)').not(tooltip); // Set active tooltip API reference\n\n          self.update(api); // If the modal can steal the focus...\n          // Blur the current item and focus anything in the modal we an\n\n          if (state && options.stealfocus !== FALSE) {\n            focusInputs($(':focus'));\n          } // Toggle backdrop cursor style on show\n\n\n          elem.toggleClass('blurs', options.blur); // Append to body on show\n\n          if (state) {\n            elem.appendTo(document.body);\n          } // Prevent modal from conflicting with show.solo, and don't hide backdrop is other modals are visible\n\n\n          if (elem.is(':animated') && visible === state && prevState !== FALSE || !state && visibleModals.length) {\n            return self;\n          } // Stop all animations\n\n\n          elem.stop(TRUE, FALSE); // Use custom function if provided\n\n          if ($.isFunction(effect)) {\n            effect.call(elem, state);\n          } // If no effect type is supplied, use a simple toggle\n          else if (effect === FALSE) {\n              elem[type]();\n            } // Use basic fade function\n            else {\n                elem.fadeTo(parseInt(duration, 10) || 90, state ? 1 : 0, function () {\n                  if (!state) {\n                    elem.hide();\n                  }\n                });\n              } // Reset position and detach from body on hide\n\n\n          if (!state) {\n            elem.queue(function (next) {\n              elem.css({\n                left: '',\n                top: ''\n              });\n\n              if (!$(MODALSELECTOR).length) {\n                elem.detach();\n              }\n\n              next();\n            });\n          } // Cache the state\n\n\n          prevState = state; // If the tooltip is destroyed, set reference to null\n\n          if (current.destroyed) {\n            current = NULL;\n          }\n\n          return self;\n        }\n      });\n      self.init();\n    };\n\n    OVERLAY = new OVERLAY();\n\n    function Modal(api, options) {\n      this.options = options;\n      this._ns = '-modal';\n      this.qtip = api;\n      this.init(api);\n    }\n\n    $.extend(Modal.prototype, {\n      init: function (qtip) {\n        var tooltip = qtip.tooltip; // If modal is disabled... return\n\n        if (!this.options.on) {\n          return this;\n        } // Set overlay reference\n\n\n        qtip.elements.overlay = OVERLAY.elem; // Add unique attribute so we can grab modal tooltips easily via a SELECTOR, and set z-index\n\n        tooltip.addClass(MODALCLASS).css('z-index', QTIP.modal_zindex + $(MODALSELECTOR).length); // Apply our show/hide/focus modal events\n\n        qtip._bind(tooltip, ['tooltipshow', 'tooltiphide'], function (event, api, duration) {\n          var oEvent = event.originalEvent; // Make sure mouseout doesn't trigger a hide when showing the modal and mousing onto backdrop\n\n          if (event.target === tooltip[0]) {\n            if (oEvent && event.type === 'tooltiphide' && /mouse(leave|enter)/.test(oEvent.type) && $(oEvent.relatedTarget).closest(OVERLAY.elem[0]).length) {\n              /* eslint-disable no-empty */\n              try {\n                event.preventDefault();\n              } catch (e) {}\n              /* eslint-enable no-empty */\n\n            } else if (!oEvent || oEvent && oEvent.type !== 'tooltipsolo') {\n              this.toggle(event, event.type === 'tooltipshow', duration);\n            }\n          }\n        }, this._ns, this); // Adjust modal z-index on tooltip focus\n\n\n        qtip._bind(tooltip, 'tooltipfocus', function (event, api) {\n          // If focus was cancelled before it reached us, don't do anything\n          if (event.isDefaultPrevented() || event.target !== tooltip[0]) {\n            return;\n          }\n\n          var qtips = $(MODALSELECTOR),\n              // Keep the modal's lower than other, regular qtips\n          newIndex = QTIP.modal_zindex + qtips.length,\n              curIndex = parseInt(tooltip[0].style.zIndex, 10); // Set overlay z-index\n\n          OVERLAY.elem[0].style.zIndex = newIndex - 1; // Reduce modal z-index's and keep them properly ordered\n\n          qtips.each(function () {\n            if (this.style.zIndex > curIndex) {\n              this.style.zIndex -= 1;\n            }\n          }); // Fire blur event for focused tooltip\n\n          qtips.filter('.' + CLASS_FOCUS).qtip('blur', event.originalEvent); // Set the new z-index\n\n          tooltip.addClass(CLASS_FOCUS)[0].style.zIndex = newIndex; // Set current\n\n          OVERLAY.update(api); // Prevent default handling\n\n          /* eslint-disable no-empty */\n\n          try {\n            event.preventDefault();\n          } catch (e) {}\n          /* eslint-enable no-empty */\n\n        }, this._ns, this); // Focus any other visible modals when this one hides\n\n\n        qtip._bind(tooltip, 'tooltiphide', function (event) {\n          if (event.target === tooltip[0]) {\n            $(MODALSELECTOR).filter(':visible').not(tooltip).last().qtip('focus', event);\n          }\n        }, this._ns, this);\n      },\n      toggle: function (event, state, duration) {\n        // Make sure default event hasn't been prevented\n        if (event && event.isDefaultPrevented()) {\n          return this;\n        } // Toggle it\n\n\n        OVERLAY.toggle(this.qtip, !!state, duration);\n      },\n      destroy: function () {\n        // Remove modal class\n        this.qtip.tooltip.removeClass(MODALCLASS); // Remove bound events\n\n        this.qtip._unbind(this.qtip.tooltip, this._ns); // Delete element reference\n\n\n        OVERLAY.toggle(this.qtip, FALSE);\n        delete this.qtip.elements.overlay;\n      }\n    });\n\n    MODAL = PLUGINS.modal = function (api) {\n      return new Modal(api, api.options.show.modal);\n    }; // Setup sanitiztion rules\n\n\n    MODAL.sanitize = function (opts) {\n      if (opts.show) {\n        if (typeof opts.show.modal !== 'object') {\n          opts.show.modal = {\n            on: !!opts.show.modal\n          };\n        } else if (typeof opts.show.modal.on === 'undefined') {\n          opts.show.modal.on = TRUE;\n        }\n      }\n    }; // Base z-index for all modal tooltips (use qTip core z-index as a base)\n\n    /* eslint-disable camelcase */\n\n\n    QTIP.modal_zindex = QTIP.zindex - 200;\n    /* eslint-enable camelcase */\n    // Plugin needs to be initialized on render\n\n    MODAL.initialize = 'render'; // Setup option set checks\n\n    CHECKS.modal = {\n      '^show.modal.(on|blur)$': function () {\n        // Initialise\n        this.destroy();\n        this.init(); // Show the modal if not visible already and tooltip is visible\n\n        this.qtip.elems.overlay.toggle(this.qtip.tooltip[0].offsetWidth > 0);\n      }\n    }; // Extend original api defaults\n\n    $.extend(TRUE, QTIP.defaults, {\n      show: {\n        modal: {\n          on: FALSE,\n          effect: TRUE,\n          blur: TRUE,\n          stealfocus: TRUE,\n          escape: TRUE\n        }\n      }\n    });\n    ;\n\n    PLUGINS.viewport = function (api, position, posOptions, targetWidth, targetHeight, elemWidth, elemHeight) {\n      var target = posOptions.target,\n          tooltip = api.elements.tooltip,\n          my = posOptions.my,\n          at = posOptions.at,\n          adjust = posOptions.adjust,\n          method = adjust.method.split(' '),\n          methodX = method[0],\n          methodY = method[1] || method[0],\n          viewport = posOptions.viewport,\n          container = posOptions.container,\n          adjusted = {\n        left: 0,\n        top: 0\n      },\n          fixed,\n          newMy,\n          containerOffset,\n          containerStatic,\n          viewportWidth,\n          viewportHeight,\n          viewportScroll,\n          viewportOffset; // If viewport is not a jQuery element, or it's the window/document, or no adjustment method is used... return\n\n      if (!viewport.jquery || target[0] === window || target[0] === document.body || adjust.method === 'none') {\n        return adjusted;\n      } // Cach container details\n\n\n      containerOffset = container.offset() || adjusted;\n      containerStatic = container.css('position') === 'static'; // Cache our viewport details\n\n      fixed = tooltip.css('position') === 'fixed';\n      viewportWidth = viewport[0] === window ? viewport.width() : viewport.outerWidth(FALSE);\n      viewportHeight = viewport[0] === window ? viewport.height() : viewport.outerHeight(FALSE);\n      viewportScroll = {\n        left: fixed ? 0 : viewport.scrollLeft(),\n        top: fixed ? 0 : viewport.scrollTop()\n      };\n      viewportOffset = viewport.offset() || adjusted; // Generic calculation method\n\n      function calculate(side, otherSide, type, adjustment, side1, side2, lengthName, targetLength, elemLength) {\n        var initialPos = position[side1],\n            mySide = my[side],\n            atSide = at[side],\n            isShift = type === SHIFT,\n            myLength = mySide === side1 ? elemLength : mySide === side2 ? -elemLength : -elemLength / 2,\n            atLength = atSide === side1 ? targetLength : atSide === side2 ? -targetLength : -targetLength / 2,\n            sideOffset = viewportScroll[side1] + viewportOffset[side1] - (containerStatic ? 0 : containerOffset[side1]),\n            overflow1 = sideOffset - initialPos,\n            overflow2 = initialPos + elemLength - (lengthName === WIDTH ? viewportWidth : viewportHeight) - sideOffset,\n            offset = myLength - (my.precedance === side || mySide === my[otherSide] ? atLength : 0) - (atSide === CENTER ? targetLength / 2 : 0); // shift\n\n        if (isShift) {\n          offset = (mySide === side1 ? 1 : -1) * myLength; // Adjust position but keep it within viewport dimensions\n\n          position[side1] += overflow1 > 0 ? overflow1 : overflow2 > 0 ? -overflow2 : 0;\n          position[side1] = Math.max(-containerOffset[side1] + viewportOffset[side1], initialPos - offset, Math.min(Math.max(-containerOffset[side1] + viewportOffset[side1] + (lengthName === WIDTH ? viewportWidth : viewportHeight), initialPos + offset), position[side1], // Make sure we don't adjust complete off the element when using 'center'\n          mySide === 'center' ? initialPos - myLength : 1E9));\n        } // flip/flipinvert\n        else {\n            // Update adjustment amount depending on if using flipinvert or flip\n            adjustment *= type === FLIPINVERT ? 2 : 0; // Check for overflow on the left/top\n\n            if (overflow1 > 0 && (mySide !== side1 || overflow2 > 0)) {\n              position[side1] -= offset + adjustment;\n              newMy.invert(side, side1);\n            } // Check for overflow on the bottom/right\n            else if (overflow2 > 0 && (mySide !== side2 || overflow1 > 0)) {\n                position[side1] -= (mySide === CENTER ? -offset : offset) + adjustment;\n                newMy.invert(side, side2);\n              } // Make sure we haven't made things worse with the adjustment and reset if so\n\n\n            if (position[side1] < viewportScroll[side1] && -position[side1] > overflow2) {\n              position[side1] = initialPos;\n              newMy = my.clone();\n            }\n          }\n\n        return position[side1] - initialPos;\n      } // Set newMy if using flip or flipinvert methods\n\n\n      if (methodX !== 'shift' || methodY !== 'shift') {\n        newMy = my.clone();\n      } // Adjust position based onviewport and adjustment options\n\n\n      adjusted = {\n        left: methodX !== 'none' ? calculate(X, Y, methodX, adjust.x, LEFT, RIGHT, WIDTH, targetWidth, elemWidth) : 0,\n        top: methodY !== 'none' ? calculate(Y, X, methodY, adjust.y, TOP, BOTTOM, HEIGHT, targetHeight, elemHeight) : 0,\n        my: newMy\n      };\n      return adjusted;\n    };\n\n    ;\n    PLUGINS.polys = {\n      // POLY area coordinate calculator\n      //\tSpecial thanks to Ed Cradock for helping out with this.\n      //\tUses a binary search algorithm to find suitable coordinates.\n      polygon: function (baseCoords, corner) {\n        var result = {\n          width: 0,\n          height: 0,\n          position: {\n            top: 1e10,\n            right: 0,\n            bottom: 0,\n            left: 1e10\n          },\n          adjustable: FALSE\n        },\n            i = 0,\n            next,\n            coords = [],\n            compareX = 1,\n            compareY = 1,\n            realX = 0,\n            realY = 0,\n            newWidth,\n            newHeight; // First pass, sanitize coords and determine outer edges\n\n        i = baseCoords.length;\n\n        while (i--) {\n          next = [parseInt(baseCoords[--i], 10), parseInt(baseCoords[i + 1], 10)];\n\n          if (next[0] > result.position.right) {\n            result.position.right = next[0];\n          }\n\n          if (next[0] < result.position.left) {\n            result.position.left = next[0];\n          }\n\n          if (next[1] > result.position.bottom) {\n            result.position.bottom = next[1];\n          }\n\n          if (next[1] < result.position.top) {\n            result.position.top = next[1];\n          }\n\n          coords.push(next);\n        } // Calculate height and width from outer edges\n\n\n        newWidth = result.width = Math.abs(result.position.right - result.position.left);\n        newHeight = result.height = Math.abs(result.position.bottom - result.position.top); // If it's the center corner...\n\n        if (corner.abbrev() === 'c') {\n          result.position = {\n            left: result.position.left + result.width / 2,\n            top: result.position.top + result.height / 2\n          };\n        } else {\n          // Second pass, use a binary search algorithm to locate most suitable coordinate\n          while (newWidth > 0 && newHeight > 0 && compareX > 0 && compareY > 0) {\n            newWidth = Math.floor(newWidth / 2);\n            newHeight = Math.floor(newHeight / 2);\n\n            if (corner.x === LEFT) {\n              compareX = newWidth;\n            } else if (corner.x === RIGHT) {\n              compareX = result.width - newWidth;\n            } else {\n              compareX += Math.floor(newWidth / 2);\n            }\n\n            if (corner.y === TOP) {\n              compareY = newHeight;\n            } else if (corner.y === BOTTOM) {\n              compareY = result.height - newHeight;\n            } else {\n              compareY += Math.floor(newHeight / 2);\n            }\n\n            i = coords.length;\n\n            while (i--) {\n              if (coords.length < 2) {\n                break;\n              }\n\n              realX = coords[i][0] - result.position.left;\n              realY = coords[i][1] - result.position.top;\n\n              if (corner.x === LEFT && realX >= compareX || corner.x === RIGHT && realX <= compareX || corner.x === CENTER && (realX < compareX || realX > result.width - compareX) || corner.y === TOP && realY >= compareY || corner.y === BOTTOM && realY <= compareY || corner.y === CENTER && (realY < compareY || realY > result.height - compareY)) {\n                coords.splice(i, 1);\n              }\n            }\n          }\n\n          result.position = {\n            left: coords[0][0],\n            top: coords[0][1]\n          };\n        }\n\n        return result;\n      },\n      rect: function (ax, ay, bx, by) {\n        return {\n          width: Math.abs(bx - ax),\n          height: Math.abs(by - ay),\n          position: {\n            left: Math.min(ax, bx),\n            top: Math.min(ay, by)\n          }\n        };\n      },\n      _angles: {\n        tc: 3 / 2,\n        tr: 7 / 4,\n        tl: 5 / 4,\n        bc: 1 / 2,\n        br: 1 / 4,\n        bl: 3 / 4,\n        rc: 2,\n        lc: 1,\n        c: 0\n      },\n      ellipse: function (cx, cy, rx, ry, corner) {\n        var c = PLUGINS.polys._angles[corner.abbrev()],\n            rxc = c === 0 ? 0 : rx * Math.cos(c * Math.PI),\n            rys = ry * Math.sin(c * Math.PI);\n\n        return {\n          width: rx * 2 - Math.abs(rxc),\n          height: ry * 2 - Math.abs(rys),\n          position: {\n            left: cx + rxc,\n            top: cy + rys\n          },\n          adjustable: FALSE\n        };\n      },\n      circle: function (cx, cy, r, corner) {\n        return PLUGINS.polys.ellipse(cx, cy, r, r, corner);\n      }\n    };\n    ;\n\n    PLUGINS.svg = function (api, svg, corner) {\n      var elem = svg[0],\n          root = $(elem.ownerSVGElement),\n          ownerDocument = elem.ownerDocument,\n          strokeWidth2 = (parseInt(svg.css('stroke-width'), 10) || 0) / 2,\n          frameOffset,\n          mtx,\n          transformed,\n          len,\n          next,\n          i,\n          points,\n          result,\n          position; // Ascend the parentNode chain until we find an element with getBBox()\n\n      while (!elem.getBBox) {\n        elem = elem.parentNode;\n      }\n\n      if (!elem.getBBox || !elem.parentNode) {\n        return FALSE;\n      } // Determine which shape calculation to use\n\n\n      switch (elem.nodeName) {\n        case 'ellipse':\n        case 'circle':\n          result = PLUGINS.polys.ellipse(elem.cx.baseVal.value, elem.cy.baseVal.value, (elem.rx || elem.r).baseVal.value + strokeWidth2, (elem.ry || elem.r).baseVal.value + strokeWidth2, corner);\n          break;\n\n        case 'line':\n        case 'polygon':\n        case 'polyline':\n          // Determine points object (line has none, so mimic using array)\n          points = elem.points || [{\n            x: elem.x1.baseVal.value,\n            y: elem.y1.baseVal.value\n          }, {\n            x: elem.x2.baseVal.value,\n            y: elem.y2.baseVal.value\n          }];\n\n          for (result = [], i = -1, len = points.numberOfItems || points.length; ++i < len;) {\n            next = points.getItem ? points.getItem(i) : points[i];\n            result.push.apply(result, [next.x, next.y]);\n          }\n\n          result = PLUGINS.polys.polygon(result, corner);\n          break;\n        // Unknown shape or rectangle? Use bounding box\n\n        default:\n          result = elem.getBBox();\n          result = {\n            width: result.width,\n            height: result.height,\n            position: {\n              left: result.x,\n              top: result.y\n            }\n          };\n          break;\n      } // Shortcut assignments\n\n\n      position = result.position;\n      root = root[0]; // Convert position into a pixel value\n\n      if (root.createSVGPoint) {\n        mtx = elem.getScreenCTM();\n        points = root.createSVGPoint();\n        points.x = position.left;\n        points.y = position.top;\n        transformed = points.matrixTransform(mtx);\n        position.left = transformed.x;\n        position.top = transformed.y;\n      } // Check the element is not in a child document, and if so, adjust for frame elements offset\n\n\n      if (ownerDocument !== document && api.position.target !== 'mouse') {\n        frameOffset = $((ownerDocument.defaultView || ownerDocument.parentWindow).frameElement).offset();\n\n        if (frameOffset) {\n          position.left += frameOffset.left;\n          position.top += frameOffset.top;\n        }\n      } // Adjust by scroll offset of owner document\n\n\n      ownerDocument = $(ownerDocument);\n      position.left += ownerDocument.scrollLeft();\n      position.top += ownerDocument.scrollTop();\n      return result;\n    };\n\n    ;\n\n    PLUGINS.imagemap = function (api, area, corner) {\n      if (!area.jquery) {\n        area = $(area);\n      }\n\n      var shape = (area.attr('shape') || 'rect').toLowerCase().replace('poly', 'polygon'),\n          image = $('img[usemap=\"#' + area.parent('map').attr('name') + '\"]'),\n          coordsString = $.trim(area.attr('coords')),\n          coordsArray = coordsString.replace(/,$/, '').split(','),\n          imageOffset,\n          coords,\n          i,\n          result,\n          len; // If we can't find the image using the map...\n\n      if (!image.length) {\n        return FALSE;\n      } // Pass coordinates string if polygon\n\n\n      if (shape === 'polygon') {\n        result = PLUGINS.polys.polygon(coordsArray, corner);\n      } // Otherwise parse the coordinates and pass them as arguments\n      else if (PLUGINS.polys[shape]) {\n          for (i = -1, len = coordsArray.length, coords = []; ++i < len;) {\n            coords.push(parseInt(coordsArray[i], 10));\n          }\n\n          result = PLUGINS.polys[shape].apply(this, coords.concat(corner));\n        } // If no shapre calculation method was found, return false\n        else {\n            return FALSE;\n          } // Make sure we account for padding and borders on the image\n\n\n      imageOffset = image.offset();\n      imageOffset.left += Math.ceil((image.outerWidth(FALSE) - image.width()) / 2);\n      imageOffset.top += Math.ceil((image.outerHeight(FALSE) - image.height()) / 2); // Add image position to offset coordinates\n\n      result.position.left += imageOffset.left;\n      result.position.top += imageOffset.top;\n      return result;\n    };\n\n    ;\n    var IE6,\n\n    /*\n     * BGIFrame adaption (http://plugins.jquery.com/project/bgiframe)\n     * Special thanks to Brandon Aaron\n     */\n    BGIFRAME = '<iframe class=\"qtip-bgiframe\" frameborder=\"0\" tabindex=\"-1\" src=\"javascript:\\'\\';\" ' + ' style=\"display:block; position:absolute; z-index:-1; filter:alpha(opacity=0); ' + '-ms-filter:\"progid:DXImageTransform.Microsoft.Alpha(Opacity=0)\";\"></iframe>';\n\n    function Ie6(api) {\n      this._ns = 'ie6';\n      this.qtip = api;\n      this.init(api);\n    }\n\n    $.extend(Ie6.prototype, {\n      _scroll: function () {\n        var overlay = this.qtip.elements.overlay;\n        overlay && (overlay[0].style.top = $(window).scrollTop() + 'px');\n      },\n      init: function (qtip) {\n        var tooltip = qtip.tooltip; // Create the BGIFrame element if needed\n\n        if ($('select, object').length < 1) {\n          this.bgiframe = qtip.elements.bgiframe = $(BGIFRAME).appendTo(tooltip); // Update BGIFrame on tooltip move\n\n          qtip._bind(tooltip, 'tooltipmove', this.adjustBGIFrame, this._ns, this);\n        } // redraw() container for width/height calculations\n\n\n        this.redrawContainer = $('<div/>', {\n          id: NAMESPACE + '-rcontainer'\n        }).appendTo(document.body); // Fixup modal plugin if present too\n\n        if (qtip.elements.overlay && qtip.elements.overlay.addClass('qtipmodal-ie6fix')) {\n          qtip._bind(window, ['scroll', 'resize'], this._scroll, this._ns, this);\n\n          qtip._bind(tooltip, ['tooltipshow'], this._scroll, this._ns, this);\n        } // Set dimensions\n\n\n        this.redraw();\n      },\n      adjustBGIFrame: function () {\n        var tooltip = this.qtip.tooltip,\n            dimensions = {\n          height: tooltip.outerHeight(FALSE),\n          width: tooltip.outerWidth(FALSE)\n        },\n            plugin = this.qtip.plugins.tip,\n            tip = this.qtip.elements.tip,\n            tipAdjust,\n            offset; // Adjust border offset\n\n        offset = parseInt(tooltip.css('borderLeftWidth'), 10) || 0;\n        offset = {\n          left: -offset,\n          top: -offset\n        }; // Adjust for tips plugin\n\n        if (plugin && tip) {\n          tipAdjust = plugin.corner.precedance === 'x' ? [WIDTH, LEFT] : [HEIGHT, TOP];\n          offset[tipAdjust[1]] -= tip[tipAdjust[0]]();\n        } // Update bgiframe\n\n\n        this.bgiframe.css(offset).css(dimensions);\n      },\n      // Max/min width simulator function\n      redraw: function () {\n        if (this.qtip.rendered < 1 || this.drawing) {\n          return this;\n        }\n\n        var tooltip = this.qtip.tooltip,\n            style = this.qtip.options.style,\n            container = this.qtip.options.position.container,\n            perc,\n            width,\n            max,\n            min; // Set drawing flag\n\n        this.qtip.drawing = 1; // If tooltip has a set height/width, just set it... like a boss!\n\n        if (style.height) {\n          tooltip.css(HEIGHT, style.height);\n        }\n\n        if (style.width) {\n          tooltip.css(WIDTH, style.width);\n        } // Simulate max/min width if not set width present...\n        else {\n            // Reset width and add fluid class\n            tooltip.css(WIDTH, '').appendTo(this.redrawContainer); // Grab our tooltip width (add 1 if odd so we don't get wrapping problems.. huzzah!)\n\n            width = tooltip.width();\n\n            if (width % 2 < 1) {\n              width += 1;\n            } // Grab our max/min properties\n\n\n            max = tooltip.css('maxWidth') || '';\n            min = tooltip.css('minWidth') || ''; // Parse into proper pixel values\n\n            perc = (max + min).indexOf('%') > -1 ? container.width() / 100 : 0;\n            max = (max.indexOf('%') > -1 ? perc : 1 * parseInt(max, 10)) || width;\n            min = (min.indexOf('%') > -1 ? perc : 1 * parseInt(min, 10)) || 0; // Determine new dimension size based on max/min/current values\n\n            width = max + min ? Math.min(Math.max(width, min), max) : width; // Set the newly calculated width and remvoe fluid class\n\n            tooltip.css(WIDTH, Math.round(width)).appendTo(container);\n          } // Set drawing flag\n\n\n        this.drawing = 0;\n        return this;\n      },\n      destroy: function () {\n        // Remove iframe\n        this.bgiframe && this.bgiframe.remove(); // Remove bound events\n\n        this.qtip._unbind([window, this.qtip.tooltip], this._ns);\n      }\n    });\n\n    IE6 = PLUGINS.ie6 = function (api) {\n      // Proceed only if the browser is IE6\n      return BROWSER.ie === 6 ? new Ie6(api) : FALSE;\n    };\n\n    IE6.initialize = 'render';\n    CHECKS.ie6 = {\n      '^content|style$': function () {\n        this.redraw();\n      }\n    };\n    ;\n  });\n})(window, document);","map":null,"metadata":{},"sourceType":"script"}