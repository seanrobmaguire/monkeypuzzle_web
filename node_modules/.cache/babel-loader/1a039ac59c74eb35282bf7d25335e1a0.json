{"ast":null,"code":"(function webpackUniversalModuleDefinition(root, factory) {\n  if (typeof exports === 'object' && typeof module === 'object') module.exports = factory(require(\"lodash.memoize\"), require(\"lodash.throttle\"));else if (typeof define === 'function' && define.amd) define([\"lodash.memoize\", \"lodash.throttle\"], factory);else if (typeof exports === 'object') exports[\"cytoscapeEdgehandles\"] = factory(require(\"lodash.memoize\"), require(\"lodash.throttle\"));else root[\"cytoscapeEdgehandles\"] = factory(root[\"_\"][\"memoize\"], root[\"_\"][\"throttle\"]);\n})(this, function (__WEBPACK_EXTERNAL_MODULE_13__, __WEBPACK_EXTERNAL_MODULE_14__) {\n  return (\n    /******/\n    function (modules) {\n      // webpackBootstrap\n\n      /******/\n      // The module cache\n\n      /******/\n      var installedModules = {};\n      /******/\n\n      /******/\n      // The require function\n\n      /******/\n\n      function __webpack_require__(moduleId) {\n        /******/\n\n        /******/\n        // Check if module is in cache\n\n        /******/\n        if (installedModules[moduleId]) {\n          /******/\n          return installedModules[moduleId].exports;\n          /******/\n        }\n        /******/\n        // Create a new module (and put it into the cache)\n\n        /******/\n\n\n        var module = installedModules[moduleId] = {\n          /******/\n          i: moduleId,\n\n          /******/\n          l: false,\n\n          /******/\n          exports: {}\n          /******/\n\n        };\n        /******/\n\n        /******/\n        // Execute the module function\n\n        /******/\n\n        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n        /******/\n\n        /******/\n        // Flag the module as loaded\n\n        /******/\n\n        module.l = true;\n        /******/\n\n        /******/\n        // Return the exports of the module\n\n        /******/\n\n        return module.exports;\n        /******/\n      }\n      /******/\n\n      /******/\n\n      /******/\n      // expose the modules object (__webpack_modules__)\n\n      /******/\n\n\n      __webpack_require__.m = modules;\n      /******/\n\n      /******/\n      // expose the module cache\n\n      /******/\n\n      __webpack_require__.c = installedModules;\n      /******/\n\n      /******/\n      // identity function for calling harmony imports with the correct context\n\n      /******/\n\n      __webpack_require__.i = function (value) {\n        return value;\n      };\n      /******/\n\n      /******/\n      // define getter function for harmony exports\n\n      /******/\n\n\n      __webpack_require__.d = function (exports, name, getter) {\n        /******/\n        if (!__webpack_require__.o(exports, name)) {\n          /******/\n          Object.defineProperty(exports, name, {\n            /******/\n            configurable: false,\n\n            /******/\n            enumerable: true,\n\n            /******/\n            get: getter\n            /******/\n\n          });\n          /******/\n        }\n        /******/\n\n      };\n      /******/\n\n      /******/\n      // getDefaultExport function for compatibility with non-harmony modules\n\n      /******/\n\n\n      __webpack_require__.n = function (module) {\n        /******/\n        var getter = module && module.__esModule ?\n        /******/\n        function getDefault() {\n          return module['default'];\n        } :\n        /******/\n        function getModuleExports() {\n          return module;\n        };\n        /******/\n\n        __webpack_require__.d(getter, 'a', getter);\n        /******/\n\n\n        return getter;\n        /******/\n      };\n      /******/\n\n      /******/\n      // Object.prototype.hasOwnProperty.call\n\n      /******/\n\n\n      __webpack_require__.o = function (object, property) {\n        return Object.prototype.hasOwnProperty.call(object, property);\n      };\n      /******/\n\n      /******/\n      // __webpack_public_path__\n\n      /******/\n\n\n      __webpack_require__.p = \"\";\n      /******/\n\n      /******/\n      // Load entry module and return exports\n\n      /******/\n\n      return __webpack_require__(__webpack_require__.s = 12);\n      /******/\n    }(\n    /************************************************************************/\n\n    /******/\n    [\n    /* 0 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\"; // Simple, internal Object.assign() polyfill for options objects etc.\n\n      module.exports = Object.assign != null ? Object.assign.bind(Object) : function (tgt) {\n        for (var _len = arguments.length, srcs = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          srcs[_key - 1] = arguments[_key];\n        }\n\n        srcs.filter(function (src) {\n          return src != null;\n        }).forEach(function (src) {\n          Object.keys(src).forEach(function (k) {\n            return tgt[k] = src[k];\n          });\n        });\n        return tgt;\n      };\n      /***/\n    },\n    /* 1 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var Edgehandles = __webpack_require__(10);\n\n      var assign = __webpack_require__(0);\n\n      module.exports = function (options) {\n        var cy = this;\n        return new Edgehandles(assign({\n          cy: cy\n        }, options));\n      };\n      /***/\n\n    },\n    /* 2 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function disableGestures() {\n        this.saveGestureState();\n        this.cy.zoomingEnabled(false).panningEnabled(false).boxSelectionEnabled(false);\n\n        if (this.options.disableBrowserGestures) {\n          var wlOpts = this.windowListenerOptions;\n          window.addEventListener('touchstart', this.preventDefault, wlOpts);\n          window.addEventListener('touchmove', this.preventDefault, wlOpts);\n          window.addEventListener('wheel', this.preventDefault, wlOpts);\n        }\n\n        return this;\n      }\n\n      function resetGestures() {\n        this.cy.zoomingEnabled(this.lastZoomingEnabled).panningEnabled(this.lastPanningEnabled).boxSelectionEnabled(this.lastBoxSelectionEnabled);\n\n        if (this.options.disableBrowserGestures) {\n          var wlOpts = this.windowListenerOptions;\n          window.removeEventListener('touchstart', this.preventDefault, wlOpts);\n          window.removeEventListener('touchmove', this.preventDefault, wlOpts);\n          window.removeEventListener('wheel', this.preventDefault, wlOpts);\n        }\n\n        return this;\n      }\n\n      function saveGestureState() {\n        var cy = this.cy;\n        this.lastPanningEnabled = cy.panningEnabled();\n        this.lastZoomingEnabled = cy.zoomingEnabled();\n        this.lastBoxSelectionEnabled = cy.boxSelectionEnabled();\n        return this;\n      }\n\n      module.exports = {\n        disableGestures: disableGestures,\n        resetGestures: resetGestures,\n        saveGestureState: saveGestureState\n      };\n      /***/\n    },\n    /* 3 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function addCytoscapeListeners() {\n        var _this = this;\n\n        var cy = this.cy,\n            options = this.options; // grabbing nodes\n\n        this.addListener(cy, 'drag', function () {\n          return _this.grabbingNode = true;\n        });\n        this.addListener(cy, 'free', function () {\n          return _this.grabbingNode = false;\n        }); // show handle on hover\n\n        this.addListener(cy, 'mouseover', 'node', function (e) {\n          _this.show(e.target);\n        }); // hide handle on tap handle\n\n        this.addListener(cy, 'tap', 'node', function (e) {\n          var node = e.target;\n\n          if (!node.same(_this.handleNode)) {\n            _this.show(node);\n          }\n        }); // hide handle when source node moved\n\n        this.addListener(cy, 'position', 'node', function (e) {\n          if (e.target.same(_this.sourceNode)) {\n            _this.hide();\n          }\n        }); // start on tapstart handle\n        // start on tapstart node (draw mode)\n        // toggle on source node\n\n        this.addListener(cy, 'tapstart', 'node', function (e) {\n          var node = e.target;\n\n          if (node.same(_this.handleNode)) {\n            _this.start(_this.sourceNode);\n          } else if (_this.drawMode) {\n            _this.start(node);\n          } else if (node.same(_this.sourceNode)) {\n            _this.hide();\n          }\n        }); // update line on drag\n\n        this.addListener(cy, 'tapdrag', function (e) {\n          _this.update(e.position);\n        }); // hover over preview\n\n        this.addListener(cy, 'tapdragover', 'node', function (e) {\n          if (options.snap) {// then ignore events like mouseover\n          } else {\n            _this.preview(e.target);\n          }\n        }); // hover out unpreview\n\n        this.addListener(cy, 'tapdragout', 'node', function (e) {\n          if (options.snap) {// then keep the preview\n          } else {\n            _this.unpreview(e.target);\n          }\n        }); // stop gesture on tapend\n\n        this.addListener(cy, 'tapend', function () {\n          _this.stop();\n        }); // hide handle if source node is removed\n\n        this.addListener(cy, 'remove', function (e) {\n          if (e.target.same(_this.sourceNode)) {\n            _this.hide();\n          }\n        });\n        return this;\n      }\n\n      module.exports = {\n        addCytoscapeListeners: addCytoscapeListeners\n      };\n      /***/\n    },\n    /* 4 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n      /* eslint-disable no-unused-vars */\n\n      var defaults = {\n        preview: true,\n        // whether to show added edges preview before releasing selection\n        hoverDelay: 150,\n        // time spent hovering over a target node before it is considered selected\n        handleNodes: 'node',\n        // selector/filter function for whether edges can be made from a given node\n        snap: false,\n        // when enabled, the edge can be drawn by just moving close to a target node (can be confusing on compound graphs)\n        snapThreshold: 50,\n        // the target node must be less than or equal to this many pixels away from the cursor/finger\n        snapFrequency: 15,\n        // the number of times per second (Hz) that snap checks done (lower is less expensive)\n        noEdgeEventsInDraw: false,\n        // set events:no to edges during draws, prevents mouseouts on compounds\n        disableBrowserGestures: true,\n        // during an edge drawing gesture, disable browser gestures such as two-finger trackpad swipe and pinch-to-zoom\n        handlePosition: function handlePosition(node) {\n          return 'middle top'; // sets the position of the handle in the format of \"X-AXIS Y-AXIS\" such as \"left top\", \"middle top\"\n        },\n        handleInDrawMode: false,\n        // whether to show the handle in draw mode\n        edgeType: function edgeType(sourceNode, targetNode) {\n          // can return 'flat' for flat edges between nodes or 'node' for intermediate node between them\n          // returning null/undefined means an edge can't be added between the two nodes\n          return 'flat';\n        },\n        loopAllowed: function loopAllowed(node) {\n          // for the specified node, return whether edges from itself to itself are allowed\n          return false;\n        },\n        nodeLoopOffset: -50,\n        // offset for edgeType: 'node' loops\n        nodeParams: function nodeParams(sourceNode, targetNode) {\n          // for edges between the specified source and target\n          // return element object to be passed to cy.add() for intermediary node\n          return {};\n        },\n        edgeParams: function edgeParams(sourceNode, targetNode, i) {\n          // for edges between the specified source and target\n          // return element object to be passed to cy.add() for edge\n          // NB: i indicates edge index in case of edgeType: 'node'\n          return {};\n        },\n        ghostEdgeParams: function ghostEdgeParams() {\n          // return element object to be passed to cy.add() for the ghost edge\n          // (default classes are always added for you)\n          return {};\n        },\n        show: function show(sourceNode) {// fired when handle is shown\n        },\n        hide: function hide(sourceNode) {// fired when the handle is hidden\n        },\n        start: function start(sourceNode) {// fired when edgehandles interaction starts (drag on handle)\n        },\n        complete: function complete(sourceNode, targetNode, addedEles) {// fired when edgehandles is done and elements are added\n        },\n        stop: function stop(sourceNode) {// fired when edgehandles interaction is stopped (either complete with added edges or incomplete)\n        },\n        cancel: function cancel(sourceNode, cancelledTargets) {// fired when edgehandles are cancelled (incomplete gesture)\n        },\n        hoverover: function hoverover(sourceNode, targetNode) {// fired when a target is hovered\n        },\n        hoverout: function hoverout(sourceNode, targetNode) {// fired when a target isn't hovered anymore\n        },\n        previewon: function previewon(sourceNode, targetNode, previewEles) {// fired when preview is shown\n        },\n        previewoff: function previewoff(sourceNode, targetNode, previewEles) {// fired when preview is hidden\n        },\n        drawon: function drawon() {// fired when draw mode enabled\n        },\n        drawoff: function drawoff() {// fired when draw mode disabled\n        }\n      };\n      /* eslint-enable */\n\n      module.exports = defaults;\n      /***/\n    },\n    /* 5 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function toggleDrawMode(bool) {\n        var cy = this.cy,\n            options = this.options;\n        this.drawMode = bool != null ? bool : !this.drawMode;\n\n        if (this.drawMode) {\n          this.prevUngrabifyState = cy.autoungrabify();\n          cy.autoungrabify(true);\n\n          if (!options.handleInDrawMode && this.handleShown()) {\n            this.hide();\n          }\n\n          this.emit('drawon');\n        } else {\n          cy.autoungrabify(this.prevUngrabifyState);\n          this.emit('drawoff');\n        }\n\n        return this;\n      }\n\n      function enableDrawMode() {\n        return this.toggleDrawMode(true);\n      }\n\n      function disableDrawMode() {\n        return this.toggleDrawMode(false);\n      }\n\n      module.exports = {\n        toggleDrawMode: toggleDrawMode,\n        enableDrawMode: enableDrawMode,\n        disableDrawMode: disableDrawMode\n      };\n      /***/\n    },\n    /* 6 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n        return typeof obj;\n      } : function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n      };\n\n      var assign = __webpack_require__(0);\n\n      var isString = function isString(x) {\n        return (typeof x === 'undefined' ? 'undefined' : _typeof(x)) === _typeof('');\n      };\n\n      var isArray = function isArray(x) {\n        return (typeof x === 'undefined' ? 'undefined' : _typeof(x)) === _typeof([]) && x.length != null;\n      };\n\n      function getEleJson(overrides, params, addedClasses) {\n        var json = {}; // basic values\n\n        assign(json, params, overrides); // make sure params can specify data but that overrides take precedence\n\n        assign(json.data, params.data, overrides.data);\n\n        if (isString(params.classes)) {\n          json.classes = params.classes + ' ' + addedClasses;\n        } else if (isArray(params.classes)) {\n          json.classes = params.classes.join(' ') + ' ' + addedClasses;\n        } else {\n          json.classes = addedClasses;\n        }\n\n        return json;\n      }\n\n      function makeEdges() {\n        var preview = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n        var cy = this.cy,\n            options = this.options,\n            presumptiveTargets = this.presumptiveTargets,\n            previewEles = this.previewEles,\n            active = this.active;\n        var source = this.sourceNode;\n        var target = this.targetNode;\n        var classes = preview ? 'eh-preview' : '';\n        var added = cy.collection();\n        var edgeType = options.edgeType(source, target); // can't make edges outside of regular gesture lifecycle\n\n        if (!active) {\n          return;\n        } // must have a non-empty edge type\n\n\n        if (!edgeType) {\n          return;\n        } // can't make preview if disabled\n\n\n        if (preview && !options.preview) {\n          return;\n        } // detect cancel\n\n\n        if (!target || target.size() === 0) {\n          previewEles.remove();\n          this.emit('cancel', this.mp(), source, presumptiveTargets);\n          return;\n        } // just remove preview class if we already have the edges\n\n\n        if (!preview && options.preview) {\n          previewEles.removeClass('eh-preview').style('events', '');\n          this.emit('complete', this.mp(), source, target, previewEles);\n          return;\n        }\n\n        var p1 = source.position();\n        var p2 = target.position();\n        var p = void 0;\n\n        if (source.same(target)) {\n          p = {\n            x: p1.x + options.nodeLoopOffset,\n            y: p1.y + options.nodeLoopOffset\n          };\n        } else {\n          p = {\n            x: (p1.x + p2.x) / 2,\n            y: (p1.y + p2.y) / 2\n          };\n        }\n\n        if (edgeType === 'node') {\n          var interNode = cy.add(getEleJson({\n            group: 'nodes',\n            position: p\n          }, options.nodeParams(source, target), classes));\n          var source2inter = cy.add(getEleJson({\n            group: 'edges',\n            data: {\n              source: source.id(),\n              target: interNode.id()\n            }\n          }, options.edgeParams(source, target, 0), classes));\n          var inter2target = cy.add(getEleJson({\n            group: 'edges',\n            data: {\n              source: interNode.id(),\n              target: target.id()\n            }\n          }, options.edgeParams(source, target, 1), classes));\n          added = added.merge(interNode).merge(source2inter).merge(inter2target);\n        } else {\n          // flat\n          var source2target = cy.add(getEleJson({\n            group: 'edges',\n            data: {\n              source: source.id(),\n              target: target.id()\n            }\n          }, options.edgeParams(source, target, 0), classes));\n          added = added.merge(source2target);\n        }\n\n        if (preview) {\n          this.previewEles = added;\n          added.style('events', 'no');\n        } else {\n          added.style('events', '');\n          this.emit('complete', this.mp(), source, target, added);\n        }\n\n        return this;\n      }\n\n      function makePreview() {\n        this.makeEdges(true);\n        return this;\n      }\n\n      function previewShown() {\n        return this.previewEles.nonempty() && this.previewEles.inside();\n      }\n\n      function removePreview() {\n        if (this.previewShown()) {\n          this.previewEles.remove();\n        }\n\n        return this;\n      }\n\n      function handleShown() {\n        return this.handleNode.nonempty() && this.handleNode.inside();\n      }\n\n      function removeHandle() {\n        if (this.handleShown()) {\n          this.handleNode.remove();\n        }\n\n        return this;\n      }\n\n      function setHandleFor(node) {\n        var _this = this;\n\n        var options = this.options,\n            cy = this.cy;\n        var handlePosition = _typeof(options.handlePosition) === _typeof('') ? function () {\n          return options.handlePosition;\n        } : options.handlePosition;\n        var p = node.position();\n        var h = node.outerHeight();\n        var w = node.outerWidth(); // store how much we should move the handle from origin(p.x, p.y)\n\n        var moveX = 0;\n        var moveY = 0; // grab axes\n\n        var axes = handlePosition(node).toLowerCase().split(/\\s+/);\n        var axisX = axes[0];\n        var axisY = axes[1]; // based on handlePosition move left/right/top/bottom. Middle/middle will just be normal\n\n        if (axisX === 'left') {\n          moveX = -(w / 2);\n        } else if (axisX === 'right') {\n          moveX = w / 2;\n        }\n\n        if (axisY === 'top') {\n          moveY = -(h / 2);\n        } else if (axisY === 'bottom') {\n          moveY = h / 2;\n        } // set handle x and y based on adjusted positions\n\n\n        var hx = this.hx = p.x + moveX;\n        var hy = this.hy = p.y + moveY;\n        var pos = {\n          x: hx,\n          y: hy\n        };\n\n        if (this.handleShown()) {\n          this.handleNode.position(pos);\n        } else {\n          cy.batch(function () {\n            _this.handleNode = cy.add({\n              classes: 'eh-handle',\n              position: pos,\n              grabbable: false,\n              selectable: false\n            });\n\n            _this.handleNode.style('z-index', 9007199254740991);\n          });\n        }\n\n        return this;\n      }\n\n      function updateEdge() {\n        var _this2 = this;\n\n        var sourceNode = this.sourceNode,\n            ghostNode = this.ghostNode,\n            cy = this.cy,\n            mx = this.mx,\n            my = this.my,\n            options = this.options;\n        var x = mx;\n        var y = my;\n        var ghostEdge = void 0,\n            ghostEles = void 0; // can't draw a line without having the starting node\n\n        if (!sourceNode) {\n          return;\n        }\n\n        if (!ghostNode || ghostNode.length === 0 || ghostNode.removed()) {\n          ghostEles = this.ghostEles = cy.collection();\n          cy.batch(function () {\n            ghostNode = _this2.ghostNode = cy.add({\n              group: 'nodes',\n              classes: 'eh-ghost eh-ghost-node',\n              position: {\n                x: 0,\n                y: 0\n              }\n            });\n            ghostNode.style({\n              'background-color': 'blue',\n              'width': 0.0001,\n              'height': 0.0001,\n              'opacity': 0,\n              'events': 'no'\n            });\n            var ghostEdgeParams = options.ghostEdgeParams();\n            ghostEdge = cy.add(assign({}, ghostEdgeParams, {\n              group: 'edges',\n              data: assign({}, ghostEdgeParams.data, {\n                source: sourceNode.id(),\n                target: ghostNode.id()\n              }),\n              classes: 'eh-ghost eh-ghost-edge'\n            }));\n            ghostEdge.style({\n              'events': 'no'\n            });\n          });\n          ghostEles.merge(ghostNode).merge(ghostEdge);\n        }\n\n        ghostNode.position({\n          x: x,\n          y: y\n        });\n        return this;\n      }\n\n      module.exports = {\n        makeEdges: makeEdges,\n        makePreview: makePreview,\n        removePreview: removePreview,\n        previewShown: previewShown,\n        updateEdge: updateEdge,\n        handleShown: handleShown,\n        setHandleFor: setHandleFor,\n        removeHandle: removeHandle\n      };\n      /***/\n    },\n    /* 7 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function disableEdgeEvents() {\n        if (this.options.noEdgeEventsInDraw) {\n          this.cy.edges().style('events', 'no');\n        }\n\n        return this;\n      }\n\n      function enableEdgeEvents() {\n        if (this.options.noEdgeEventsInDraw) {\n          this.cy.edges().style('events', '');\n        }\n\n        return this;\n      }\n\n      module.exports = {\n        disableEdgeEvents: disableEdgeEvents,\n        enableEdgeEvents: enableEdgeEvents\n      };\n      /***/\n    },\n    /* 8 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function enable() {\n        this.enabled = true;\n        this.emit('enable');\n        return this;\n      }\n\n      function disable() {\n        this.enabled = false;\n        this.emit('disable');\n        return this;\n      }\n\n      module.exports = {\n        enable: enable,\n        disable: disable\n      };\n      /***/\n    },\n    /* 9 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var memoize = __webpack_require__(13);\n\n      var sqrt2 = Math.sqrt(2);\n\n      function canStartOn(node) {\n        var options = this.options,\n            previewEles = this.previewEles,\n            ghostEles = this.ghostEles,\n            handleNode = this.handleNode;\n\n        var isPreview = function isPreview(el) {\n          return previewEles.anySame(el);\n        };\n\n        var isGhost = function isGhost(el) {\n          return ghostEles.anySame(el);\n        };\n\n        var userFilter = function userFilter(el) {\n          return el.filter(options.handleNodes).length > 0;\n        };\n\n        var isHandle = function isHandle(el) {\n          return handleNode.same(el);\n        };\n\n        var isTemp = function isTemp(el) {\n          return isPreview(el) || isHandle(el) || isGhost(el);\n        };\n\n        var enabled = this.enabled,\n            active = this.active,\n            grabbingNode = this.grabbingNode;\n        return enabled && !active && !grabbingNode && (node == null || !isTemp(node) && userFilter(node));\n      }\n\n      function canStartDrawModeOn(node) {\n        return this.canStartOn(node) && this.drawMode;\n      }\n\n      function canStartNonDrawModeOn(node) {\n        return this.canStartOn(node) && !this.drawMode;\n      }\n\n      function show(node) {\n        var options = this.options,\n            drawMode = this.drawMode;\n\n        if (!this.canStartOn(node) || drawMode && !options.handleInDrawMode) {\n          return;\n        }\n\n        this.sourceNode = node;\n        this.setHandleFor(node);\n        this.emit('show', this.hp(), this.sourceNode);\n        return this;\n      }\n\n      function hide() {\n        this.removeHandle();\n        this.emit('hide', this.hp(), this.sourceNode);\n        return this;\n      }\n\n      function start(node) {\n        if (!this.canStartOn(node)) {\n          return;\n        }\n\n        this.active = true;\n        this.sourceNode = node;\n        this.sourceNode.addClass('eh-source');\n        this.disableGestures();\n        this.disableEdgeEvents();\n        this.emit('start', this.hp(), node);\n      }\n\n      function update(pos) {\n        if (!this.active) {\n          return;\n        }\n\n        var p = pos;\n        this.mx = p.x;\n        this.my = p.y;\n        this.updateEdge();\n        this.throttledSnap();\n        return this;\n      }\n\n      function snap() {\n        if (!this.active || !this.options.snap) {\n          return false;\n        }\n\n        var cy = this.cy;\n        var tgt = this.targetNode;\n        var threshold = this.options.snapThreshold;\n        var mousePos = this.mp();\n        var handleNode = this.handleNode,\n            previewEles = this.previewEles,\n            ghostNode = this.ghostNode;\n\n        var radius = function radius(n) {\n          return sqrt2 * Math.max(n.outerWidth(), n.outerHeight()) / 2;\n        }; // worst-case enclosure of bb by circle\n\n\n        var sqDist = function sqDist(x1, y1, x2, y2) {\n          var dx = x2 - x1;\n          var dy = y2 - y1;\n          return dx * dx + dy * dy;\n        };\n\n        var sqDistByPt = function sqDistByPt(p1, p2) {\n          return sqDist(p1.x, p1.y, p2.x, p2.y);\n        };\n\n        var nodeSqDist = function nodeSqDist(n) {\n          return sqDistByPt(n.position(), mousePos);\n        };\n\n        var sqThreshold = function sqThreshold(n) {\n          var r = radius(n);\n          var t = r + threshold;\n          return t * t;\n        };\n\n        var isWithinTheshold = function isWithinTheshold(n) {\n          return nodeSqDist(n) <= sqThreshold(n);\n        };\n\n        var bbSqDist = function bbSqDist(n) {\n          var p = n.position();\n          var halfW = n.outerWidth() / 2;\n          var halfH = n.outerHeight() / 2; // node and mouse positions, line is formed from node to mouse\n\n          var nx = p.x;\n          var ny = p.y;\n          var mx = mousePos.x;\n          var my = mousePos.y; // bounding box\n\n          var x1 = nx - halfW;\n          var x2 = nx + halfW;\n          var y1 = ny - halfH;\n          var y2 = ny + halfH;\n          var insideXBounds = x1 <= mx && mx <= x2;\n          var insideYBounds = y1 <= my && my <= y2;\n\n          if (insideXBounds && insideYBounds) {\n            // inside box\n            return 0;\n          } else if (insideXBounds) {\n            // perpendicular distance to box, top or bottom\n            var dy1 = my - y1;\n            var dy2 = my - y2;\n            return Math.min(dy1 * dy1, dy2 * dy2);\n          } else if (insideYBounds) {\n            // perpendicular distance to box, left or right\n            var dx1 = mx - x1;\n            var dx2 = mx - x2;\n            return Math.min(dx1 * dx1, dx2 * dx2);\n          } else if (mx < x1 && my < y1) {\n            // top-left corner distance\n            return sqDist(mx, my, x1, y1);\n          } else if (mx > x2 && my < y1) {\n            // top-right corner distance\n            return sqDist(mx, my, x2, y1);\n          } else if (mx < x1 && my > y2) {\n            // bottom-left corner distance\n            return sqDist(mx, my, x1, y2);\n          } else {\n            // bottom-right corner distance\n            return sqDist(mx, my, x2, y2);\n          }\n        };\n\n        var cmpBbSqDist = function cmpBbSqDist(n1, n2) {\n          return bbSqDist(n1) - bbSqDist(n2);\n        };\n\n        var cmp = cmpBbSqDist;\n        var allowHoverDelay = false;\n\n        var mouseIsInside = function mouseIsInside(n) {\n          var mp = mousePos;\n          var w = n.outerWidth();\n          var halfW = w / 2;\n          var h = n.outerHeight();\n          var halfH = h / 2;\n          var p = n.position();\n          var x1 = p.x - halfW;\n          var x2 = p.x + halfW;\n          var y1 = p.y - halfH;\n          var y2 = p.y + halfH;\n          return x1 <= mp.x && mp.x <= x2 && y1 <= mp.y && mp.y <= y2;\n        };\n\n        var isEhEle = function isEhEle(n) {\n          return n.same(handleNode) || n.same(previewEles) || n.same(ghostNode);\n        };\n\n        var nodesByDist = cy.nodes(function (n) {\n          return !isEhEle(n) && isWithinTheshold(n);\n        }).sort(cmp);\n        var snapped = false;\n\n        if (tgt.nonempty() && !isWithinTheshold(tgt)) {\n          this.unpreview(tgt);\n        }\n\n        for (var i = 0; i < nodesByDist.length; i++) {\n          var n = nodesByDist[i]; // skip a parent node when the mouse is inside it\n\n          if (n.isParent() && mouseIsInside(n)) {\n            continue;\n          } // skip a child node when the mouse is not inside the parent\n\n\n          if (n.isChild() && !mouseIsInside(n.parent())) {\n            continue;\n          }\n\n          if (n.same(tgt) || this.preview(n, allowHoverDelay)) {\n            snapped = true;\n            break;\n          }\n        }\n\n        return snapped;\n      }\n\n      function preview(target) {\n        var _this = this;\n\n        var allowHoverDelay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        var options = this.options,\n            sourceNode = this.sourceNode,\n            ghostNode = this.ghostNode,\n            ghostEles = this.ghostEles,\n            presumptiveTargets = this.presumptiveTargets,\n            previewEles = this.previewEles,\n            active = this.active;\n        var source = sourceNode;\n        var isLoop = target.same(source);\n        var loopAllowed = options.loopAllowed(target);\n        var isGhost = target.same(ghostNode);\n        var noEdge = !options.edgeType(source, target);\n        var isHandle = target.same(this.handleNode);\n        var isExistingTgt = target.same(this.targetNode);\n\n        if (!active || isHandle || isGhost || noEdge || isExistingTgt || isLoop && !loopAllowed // || (target.isParent())\n        ) {\n            return false;\n          }\n\n        if (this.targetNode.nonempty()) {\n          this.unpreview(this.targetNode);\n        }\n\n        clearTimeout(this.previewTimeout);\n\n        var applyPreview = function applyPreview() {\n          _this.targetNode = target;\n          presumptiveTargets.merge(target);\n          target.addClass('eh-presumptive-target');\n          target.addClass('eh-target');\n\n          _this.emit('hoverover', _this.mp(), source, target);\n\n          if (options.preview) {\n            target.addClass('eh-preview');\n            ghostEles.addClass('eh-preview-active');\n            sourceNode.addClass('eh-preview-active');\n            target.addClass('eh-preview-active');\n\n            _this.makePreview();\n\n            _this.emit('previewon', _this.mp(), source, target, previewEles);\n          }\n        };\n\n        if (allowHoverDelay && options.hoverDelay > 0) {\n          this.previewTimeout = setTimeout(applyPreview, options.hoverDelay);\n        } else {\n          applyPreview();\n        }\n\n        return true;\n      }\n\n      function unpreview(target) {\n        if (!this.active || target.same(this.handleNode)) {\n          return;\n        }\n\n        var previewTimeout = this.previewTimeout,\n            sourceNode = this.sourceNode,\n            previewEles = this.previewEles,\n            ghostEles = this.ghostEles,\n            cy = this.cy;\n        clearTimeout(previewTimeout);\n        this.previewTimeout = null;\n        var source = sourceNode;\n        target.removeClass('eh-preview eh-target eh-presumptive-target eh-preview-active');\n        ghostEles.removeClass('eh-preview-active');\n        sourceNode.removeClass('eh-preview-active');\n        this.targetNode = cy.collection();\n        this.removePreview(source, target);\n        this.emit('hoverout', this.mp(), source, target);\n        this.emit('previewoff', this.mp(), source, target, previewEles);\n        return this;\n      }\n\n      function stop() {\n        if (!this.active) {\n          return;\n        }\n\n        var sourceNode = this.sourceNode,\n            targetNode = this.targetNode,\n            ghostEles = this.ghostEles,\n            presumptiveTargets = this.presumptiveTargets;\n        clearTimeout(this.previewTimeout);\n        sourceNode.removeClass('eh-source');\n        targetNode.removeClass('eh-target eh-preview eh-hover');\n        presumptiveTargets.removeClass('eh-presumptive-target');\n        this.makeEdges();\n        this.removeHandle();\n        ghostEles.remove();\n        this.clearCollections();\n        this.resetGestures();\n        this.enableEdgeEvents();\n        this.active = false;\n        this.emit('stop', this.mp(), sourceNode);\n        return this;\n      }\n\n      module.exports = {\n        show: show,\n        hide: hide,\n        start: start,\n        update: update,\n        preview: preview,\n        unpreview: unpreview,\n        stop: stop,\n        snap: snap,\n        canStartOn: canStartOn,\n        canStartDrawModeOn: canStartDrawModeOn,\n        canStartNonDrawModeOn: canStartNonDrawModeOn\n      };\n      /***/\n    },\n    /* 10 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var defaults = __webpack_require__(4);\n\n      var assign = __webpack_require__(0);\n\n      var throttle = __webpack_require__(14);\n\n      var cyGesturesToggle = __webpack_require__(2);\n\n      var cyListeners = __webpack_require__(3);\n\n      var drawMode = __webpack_require__(5);\n\n      var drawing = __webpack_require__(6);\n\n      var enabling = __webpack_require__(8);\n\n      var gestureLifecycle = __webpack_require__(9);\n\n      var listeners = __webpack_require__(11);\n\n      var edgeEvents = __webpack_require__(7);\n\n      function Edgehandles(options) {\n        var cy = options.cy;\n        this.cy = cy;\n        this.listeners = []; // edgehandles gesture state\n\n        this.enabled = true;\n        this.drawMode = false;\n        this.active = false;\n        this.grabbingNode = false; // edgehandles elements\n\n        this.handleNode = cy.collection();\n        this.clearCollections(); // handle\n\n        this.hx = 0;\n        this.hy = 0;\n        this.hr = 0; // mouse position\n\n        this.mx = 0;\n        this.my = 0;\n        this.options = assign({}, defaults, options);\n        this.saveGestureState();\n        this.addListeners();\n        this.throttledSnap = throttle(this.snap.bind(this), 1000 / options.snapFrequency);\n\n        this.preventDefault = function (e) {\n          return e.preventDefault();\n        };\n\n        var supportsPassive = false;\n\n        try {\n          var opts = Object.defineProperty({}, 'passive', {\n            get: function get() {\n              supportsPassive = true;\n            }\n          });\n          window.addEventListener('test', null, opts);\n        } catch (err) {}\n\n        if (supportsPassive) {\n          this.windowListenerOptions = {\n            capture: true,\n            passive: false\n          };\n        } else {\n          this.windowListenerOptions = true;\n        }\n      }\n\n      var proto = Edgehandles.prototype = {};\n\n      var extend = function extend(obj) {\n        return assign(proto, obj);\n      };\n\n      proto.destroy = function () {\n        this.removeListeners();\n      };\n\n      proto.setOptions = function (options) {\n        assign(this.options, options);\n      };\n\n      proto.mp = function () {\n        return {\n          x: this.mx,\n          y: this.my\n        };\n      };\n\n      proto.hp = function () {\n        return {\n          x: this.hx,\n          y: this.hy\n        };\n      };\n\n      proto.clearCollections = function () {\n        var cy = this.cy;\n        this.previewEles = cy.collection();\n        this.ghostEles = cy.collection();\n        this.ghostNode = cy.collection();\n        this.sourceNode = cy.collection();\n        this.targetNode = cy.collection();\n        this.presumptiveTargets = cy.collection();\n      };\n\n      [cyGesturesToggle, cyListeners, drawMode, drawing, enabling, gestureLifecycle, listeners, edgeEvents].forEach(extend);\n      module.exports = Edgehandles;\n      /***/\n    },\n    /* 11 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n        return typeof obj;\n      } : function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n      };\n\n      function addListeners() {\n        var _this = this;\n\n        this.addCytoscapeListeners();\n        this.addListener(this.cy, 'destroy', function () {\n          return _this.destroy();\n        });\n        return this;\n      }\n\n      function removeListeners() {\n        for (var i = this.listeners.length - 1; i >= 0; i--) {\n          var l = this.listeners[i];\n          this.removeListener(l.target, l.event, l.selector, l.callback, l.options);\n        }\n\n        return this;\n      }\n\n      function getListener(target, event, selector, callback, options) {\n        if ((typeof selector === 'undefined' ? 'undefined' : _typeof(selector)) !== _typeof('')) {\n          callback = selector;\n          options = callback;\n          selector = null;\n        }\n\n        if (options == null) {\n          options = false;\n        }\n\n        return {\n          target: target,\n          event: event,\n          selector: selector,\n          callback: callback,\n          options: options\n        };\n      }\n\n      function isDom(target) {\n        return target instanceof Element;\n      }\n\n      function addListener(target, event, selector, callback, options) {\n        var l = getListener(target, event, selector, callback, options);\n        this.listeners.push(l);\n\n        if (isDom(l.target)) {\n          l.target.addEventListener(l.event, l.callback, l.options);\n        } else {\n          if (l.selector) {\n            l.target.addListener(l.event, l.selector, l.callback, l.options);\n          } else {\n            l.target.addListener(l.event, l.callback, l.options);\n          }\n        }\n\n        return this;\n      }\n\n      function removeListener(target, event, selector, callback, options) {\n        var l = getListener(target, event, selector, callback, options);\n\n        for (var i = this.listeners.length - 1; i >= 0; i--) {\n          var l2 = this.listeners[i];\n\n          if (l.target === l2.target && l.event === l2.event && (l.selector == null || l.selector === l2.selector) && (l.callback == null || l.callback === l2.callback)) {\n            this.listeners.splice(i, 1);\n\n            if (isDom(l.target)) {\n              l.target.removeEventListener(l.event, l.callback, l.options);\n            } else {\n              if (l.selector) {\n                l.target.removeListener(l.event, l.selector, l.callback, l.options);\n              } else {\n                l.target.removeListener(l.event, l.callback, l.options);\n              }\n            }\n\n            break;\n          }\n        }\n\n        return this;\n      }\n\n      function emit(type, position) {\n        var options = this.options,\n            cy = this.cy;\n\n        for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n          args[_key - 2] = arguments[_key];\n        }\n\n        cy.emit({\n          type: 'eh' + type,\n          position: position\n        }, args);\n        var handler = options[type];\n\n        if (handler != null) {\n          handler.apply(undefined, args);\n        }\n\n        return this;\n      }\n\n      module.exports = {\n        addListener: addListener,\n        addListeners: addListeners,\n        removeListener: removeListener,\n        removeListeners: removeListeners,\n        emit: emit\n      };\n      /***/\n    },\n    /* 12 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var impl = __webpack_require__(1); // registers the extension on a cytoscape lib ref\n\n\n      var register = function register(cytoscape) {\n        if (!cytoscape) {\n          return;\n        } // can't register if cytoscape unspecified\n\n\n        cytoscape('core', 'edgehandles', impl); // register with cytoscape.js\n      };\n\n      if (typeof cytoscape !== 'undefined') {\n        // expose to global cytoscape (i.e. window.cytoscape)\n        register(cytoscape); // eslint-disable-line no-undef\n      }\n\n      module.exports = register;\n      /***/\n    },\n    /* 13 */\n\n    /***/\n    function (module, exports) {\n      module.exports = __WEBPACK_EXTERNAL_MODULE_13__;\n      /***/\n    },\n    /* 14 */\n\n    /***/\n    function (module, exports) {\n      module.exports = __WEBPACK_EXTERNAL_MODULE_14__;\n      /***/\n    }])\n  );\n});","map":null,"metadata":{},"sourceType":"script"}