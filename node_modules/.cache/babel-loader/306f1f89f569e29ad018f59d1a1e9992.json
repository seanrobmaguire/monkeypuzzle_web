{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar PairingHeap = function () {\n  function PairingHeap(elem) {\n    this.elem = elem;\n    this.subheaps = [];\n  }\n\n  PairingHeap.prototype.toString = function (selector) {\n    var str = \"\",\n        needComma = false;\n\n    for (var i = 0; i < this.subheaps.length; ++i) {\n      var subheap = this.subheaps[i];\n\n      if (!subheap.elem) {\n        needComma = false;\n        continue;\n      }\n\n      if (needComma) {\n        str = str + \",\";\n      }\n\n      str = str + subheap.toString(selector);\n      needComma = true;\n    }\n\n    if (str !== \"\") {\n      str = \"(\" + str + \")\";\n    }\n\n    return (this.elem ? selector(this.elem) : \"\") + str;\n  };\n\n  PairingHeap.prototype.forEach = function (f) {\n    if (!this.empty()) {\n      f(this.elem, this);\n      this.subheaps.forEach(function (s) {\n        return s.forEach(f);\n      });\n    }\n  };\n\n  PairingHeap.prototype.count = function () {\n    return this.empty() ? 0 : 1 + this.subheaps.reduce(function (n, h) {\n      return n + h.count();\n    }, 0);\n  };\n\n  PairingHeap.prototype.min = function () {\n    return this.elem;\n  };\n\n  PairingHeap.prototype.empty = function () {\n    return this.elem == null;\n  };\n\n  PairingHeap.prototype.contains = function (h) {\n    if (this === h) return true;\n\n    for (var i = 0; i < this.subheaps.length; i++) {\n      if (this.subheaps[i].contains(h)) return true;\n    }\n\n    return false;\n  };\n\n  PairingHeap.prototype.isHeap = function (lessThan) {\n    var _this = this;\n\n    return this.subheaps.every(function (h) {\n      return lessThan(_this.elem, h.elem) && h.isHeap(lessThan);\n    });\n  };\n\n  PairingHeap.prototype.insert = function (obj, lessThan) {\n    return this.merge(new PairingHeap(obj), lessThan);\n  };\n\n  PairingHeap.prototype.merge = function (heap2, lessThan) {\n    if (this.empty()) return heap2;else if (heap2.empty()) return this;else if (lessThan(this.elem, heap2.elem)) {\n      this.subheaps.push(heap2);\n      return this;\n    } else {\n      heap2.subheaps.push(this);\n      return heap2;\n    }\n  };\n\n  PairingHeap.prototype.removeMin = function (lessThan) {\n    if (this.empty()) return null;else return this.mergePairs(lessThan);\n  };\n\n  PairingHeap.prototype.mergePairs = function (lessThan) {\n    if (this.subheaps.length == 0) return new PairingHeap(null);else if (this.subheaps.length == 1) {\n      return this.subheaps[0];\n    } else {\n      var firstPair = this.subheaps.pop().merge(this.subheaps.pop(), lessThan);\n      var remaining = this.mergePairs(lessThan);\n      return firstPair.merge(remaining, lessThan);\n    }\n  };\n\n  PairingHeap.prototype.decreaseKey = function (subheap, newValue, setHeapNode, lessThan) {\n    var newHeap = subheap.removeMin(lessThan);\n    subheap.elem = newHeap.elem;\n    subheap.subheaps = newHeap.subheaps;\n\n    if (setHeapNode !== null && newHeap.elem !== null) {\n      setHeapNode(subheap.elem, subheap);\n    }\n\n    var pairingNode = new PairingHeap(newValue);\n\n    if (setHeapNode !== null) {\n      setHeapNode(newValue, pairingNode);\n    }\n\n    return this.merge(pairingNode, lessThan);\n  };\n\n  return PairingHeap;\n}();\n\nexports.PairingHeap = PairingHeap;\n\nvar PriorityQueue = function () {\n  function PriorityQueue(lessThan) {\n    this.lessThan = lessThan;\n  }\n\n  PriorityQueue.prototype.top = function () {\n    if (this.empty()) {\n      return null;\n    }\n\n    return this.root.elem;\n  };\n\n  PriorityQueue.prototype.push = function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    var pairingNode;\n\n    for (var i = 0, arg; arg = args[i]; ++i) {\n      pairingNode = new PairingHeap(arg);\n      this.root = this.empty() ? pairingNode : this.root.merge(pairingNode, this.lessThan);\n    }\n\n    return pairingNode;\n  };\n\n  PriorityQueue.prototype.empty = function () {\n    return !this.root || !this.root.elem;\n  };\n\n  PriorityQueue.prototype.isHeap = function () {\n    return this.root.isHeap(this.lessThan);\n  };\n\n  PriorityQueue.prototype.forEach = function (f) {\n    this.root.forEach(f);\n  };\n\n  PriorityQueue.prototype.pop = function () {\n    if (this.empty()) {\n      return null;\n    }\n\n    var obj = this.root.min();\n    this.root = this.root.removeMin(this.lessThan);\n    return obj;\n  };\n\n  PriorityQueue.prototype.reduceKey = function (heapNode, newKey, setHeapNode) {\n    if (setHeapNode === void 0) {\n      setHeapNode = null;\n    }\n\n    this.root = this.root.decreaseKey(heapNode, newKey, setHeapNode, this.lessThan);\n  };\n\n  PriorityQueue.prototype.toString = function (selector) {\n    return this.root.toString(selector);\n  };\n\n  PriorityQueue.prototype.count = function () {\n    return this.root.count();\n  };\n\n  return PriorityQueue;\n}();\n\nexports.PriorityQueue = PriorityQueue;","map":null,"metadata":{},"sourceType":"script"}