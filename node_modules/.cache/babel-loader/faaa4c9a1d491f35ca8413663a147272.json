{"ast":null,"code":"/*var sd = {};\n\n//values from defaults.cfg\nvar a_name = \"A user\";\nvar a_email = \"user@email.address\";\nvar f_name = \"data\";\n*/\nvar sadface = {\n  add_argument: function (con_text, prem_text, con_id, prem_id) {\n    /*\n    Syntactic sugar to create an argument structure from a set of texts.\n    Given a conclusion text & a list of premise texts, create an intermediate,\n    default \"support\" scheme.\n     This makes it easier to build a SADFace document without manually creating\n    and organising individual nodes.\n     Returns an argument dict, e.g.\n     {\n        \"conclusion\": atom,\n        \"scheme\": atom,\n        \"premises\": [atom(s)]\n    }\n     Returns: a dict\n    */\n    if ((con_text !== null && con_text !== undefined || con_id !== null && con_id !== undefined) && (prem_text !== null && prem_text !== undefined || prem_id !== null && prem_id !== undefined)) {\n      var c;\n      var s;\n      var p_list = [];\n      var atom;\n      var arg = {};\n\n      if (con_text !== null) {\n        c = add_atom(con_text);\n      } else {\n        c = get_atom(con_id);\n      }\n\n      s = add_scheme(\"support\");\n\n      try {\n        add_edge(s.id, c.id);\n      } catch (ex) {\n        console.log(ex);\n        throw \"Could not create new argument\";\n      }\n\n      if (prem_text !== null) {\n        prem_text.forEach(function (text) {\n          atom = add_atom(text);\n          p_list.push(atom.id);\n\n          try {\n            add_edge(atom.id, s.id);\n          } catch (ex) {\n            console.log(ex);\n            throw \"Could not create new argument\";\n          }\n        });\n      }\n\n      if (prem_id !== null) {\n        prem_id.forEach(function (atom_id) {\n          atom = get_atom(atom_id);\n          p_list.push(atom.id);\n\n          try {\n            add_edge(atom.id, s.id);\n          } catch (ex) {\n            console.log(ex);\n            throw \"Could not create new argument\";\n          }\n        });\n      }\n\n      arg = {\n        \"conclusion\": c,\n        \"scheme\": s,\n        \"premises\": p_list\n      };\n      return arg;\n    }\n\n    return;\n  },\n  add_conflict: function (arg_text, arg_id, conflict_text, conflict_id) {\n    /*\n        Conflicts play an important role in arguments. We depict conflict\n    through the use of schemes that represent the conflict relationship. This\n    function will instantiate a conflict scheme between two nodes (either\n    pre-existing & identifed by node IDs or created from supplied texts, or a\n    mixture of the two).\n     Returns a conflict dict, e.g.\n     {\n        \"argument\": atom,\n        \"scheme\": atom,\n        \"conflict\": atom\n    }\n    (where the scheme just happens to depict a conflict)\n     Returns: a dict\n    */\n    if ((arg_text !== null && arg_text !== undefined || arg_id !== null && arg_id !== undefined) && (conflict_text !== null && conflict_id !== null || conflict_text !== undefined && conflict_id !== undefined)) {\n      var c;\n      var s;\n      var a;\n      var arg = {};\n\n      if (arg_text !== null || arg_text !== undefined) {\n        a = add_atom(arg_text);\n      } else {\n        a = get_atom(arg_id);\n      }\n\n      s = add_scheme(\"conflict\");\n\n      try {\n        add_edge(s.id, a.id);\n      } catch (ex) {\n        console.log(ex);\n        throw \"Could not create new argument\";\n      }\n\n      if (conflict_text !== null || conflict_text !== undefined) {\n        c = add_atom(conflict_text);\n      } else {\n        c = get_atom(conflict_id);\n      }\n\n      try {\n        add_edge(c.id, s.id);\n      } catch (ex) {\n        console.log(ex);\n        throw \"Could not create new argument\";\n      }\n\n      arg = {\n        \"argument\": a,\n        \"scheme\": s,\n        \"conflict\": c\n      };\n      return arg;\n    }\n\n    return;\n  },\n  add_edge: function (source_id, target_id) {\n    /*\n    Given a source atom ID & a target atom ID, create an \n    edge linking the two and add it to the sadface doc,\n    \"sd\" & return the dict representing the edge. If\n    either of source or target IDs is invalid then an\n    exception is raised.\n     Returns: a dict \n    */\n    if (source_id && target_id) {\n      if (get_node(source_id) !== null && get_node(target_id) !== null) {\n        var edge = new_edge(source_id, target_id);\n        sd.edges.push(edge);\n        return edge;\n      }\n\n      throw \"Could not create new edge between: \" + source_id + \" & \" + target_id;\n    }\n  },\n  add_atom: function (text) {\n    /*    \n    Create a new argument atom using the supplied text\n     Returns: the new atom dict\n    */\n    if (text) {\n      var atom = new_atom(text);\n      sd.nodes.push(atom);\n      return atom;\n    }\n  },\n  add_atom_metadata: function (atom_id, key, value) {\n    /*\n    Add metadata, a key:value pair to the atom dict identified\n    by the supplied atom ID.\n    */\n    if (atom_id && key && value) {\n      sd.nodes.forEach(function (node) {\n        if (\"atom\" === node.type) {\n          if (atom_id === node.id) {\n            node.metadata[key] = value;\n          }\n        }\n      });\n    }\n  },\n  add_resource: function (content) {\n    /*\n    Create a new resource dict using the supplied content string\n    then add to the resourses list of the sadface doc\n     Returns: the new resource dict\n    */\n    if (content) {\n      var res = new_resource(content);\n      sd.resources.push(res);\n      return res;\n    }\n  },\n  add_resource_metadata: function (resource_id, key, value) {\n    /*\n    Add metadata, a key:value pair to the resource dict identified\n    by the supplied atom ID.    \n    */\n    if (resource_id && key && value) {\n      sd.resources.forEach(function (res) {\n        if (res.id === resource_id) {\n          res.metadata[key] = value;\n        }\n      });\n    }\n  },\n  add_sadface_metadata: function (key, value) {\n    /*\n    Add metadata, a key:value pair to the base sadface doc\n    */\n    if (key && value) {\n      sd.metadata[key] = value;\n    }\n  },\n  add_scheme: function (name) {\n    /*\n    Add a new scheme node dict to the sadface document. The scheme type\n    is identified by the supplied name\n     Returns: The new scheme dict\n    */\n    if (name) {\n      var scheme = new_scheme(name);\n      sd.nodes.push(scheme);\n      return scheme;\n    }\n  },\n  add_source: function (atom_id, resource_id, text, offset, length) {\n    /*\n    Add a new source dict to the atom identified by the supplied\n    atom ID. The new source refers to the an existing resource that\n    is identified by the supplied resource ID. The source identifies\n    text string in the resource dict that it references as well as\n    the offset & length of the text from the beginning of the resource\n     Returns: The new source dict\n    */\n    if (atom_id && resource_id && text !== null && offset !== null && length !== null && text !== undefined && offset !== undefined && length !== undefined) {\n      var source = new_source(resource_id, text, offset, length);\n      sd.nodes.forEach(function (node) {\n        if (\"atom\" === node.type) {\n          if (atom_id === node.id) {\n            node.sources.push(source);\n          }\n        }\n      });\n      return source;\n    }\n  },\n  delete_atom: function (atom_id) {\n    /*\n    Remove the atom from the sadface document identified by the\n    supplied atom ID\n    */\n    if (atom_id) {\n      var atom = get_atom(atom_id);\n\n      if (atom !== null && atom !== undefined) {\n        var size = Object.keys(sd.nodes).length;\n\n        for (var i = 0; i < size; ++i) {\n          if (sd.nodes[i].id === atom.id) {\n            delete sd.nodes[i];\n            sd.nodes = remove_falsy(sd.nodes);\n            return;\n          }\n        }\n      }\n    }\n  },\n  delete_edge: function (edge_id) {\n    /*\n    Remove the edge from the sadface document identified by the\n    supplied edge ID\n    */\n    if (edge_id) {\n      var del_edge = get_edge(edge_id);\n      var size = Object.keys(sd.edges).length;\n\n      for (var i = 0; i < size; ++i) {\n        if (sd.edges[i].id === del_edge.id) {\n          delete sd.edges[i];\n          sd.edges = remove_falsy(sd.edges);\n          return;\n        }\n      }\n    }\n  },\n  delete_source: function (atom_id, resource_id) {\n    /*\n    Remove a source from the atom identified by the\n    supplied atom ID & resource ID respectively\n    */\n    if (atom_id && resource_id) {\n      var source = get_source(atom_id, resource_id);\n      var size = Object.keys(sd.nodes).length;\n\n      for (var i = 0; i < size; ++i) {\n        if (sd.nodes[i].atom.sources.resource_id === source.id) {\n          delete sd.nodes[i].atom_id.sources.resource_id;\n          sd.nodes[i].atom_id.sources = remove_falsy(sd.nodes);\n          return;\n        }\n      }\n    }\n  },\n  delete_resource: function (resource_id) {\n    /*\n    Remove the resource from the sadface document identified by the\n    supplied resource ID\n    */\n    if (resource_id) {\n      var resource = get_resource(resource_id);\n\n      if (resource !== null && resource !== undefined) {\n        var size = Object.keys(sd.resources).length;\n\n        for (var i = 0; i < size; ++i) {\n          if (sd.resources[i].id === resource.id) {\n            delete sd.resources[i];\n            sd.resources = remove_falsy(sd.resources);\n            return;\n          }\n        }\n      }\n    }\n  },\n  delete_scheme: function (scheme_id) {\n    /*\n    Remove the schemee from the sadface document identified by the\n    supplied scheme ID\n    */\n    if (scheme_id) {\n      var scheme = get_scheme(scheme_id);\n\n      if (scheme !== null && scheme !== undefined) {\n        var size = Object.keys(sd.nodes).length;\n\n        for (var i = 0; i < size; ++i) {\n          if (sd.nodes[i].id === scheme.id) {\n            delete sd.nodes[i];\n            sd.nodes = remove_falsy(sd.nodes);\n            return;\n          }\n        }\n      }\n    }\n  },\n  export_cytoscape: function (sadface) {\n    /*\n    Cytoscape.js is a useful graph visualisation library for Javascript. However\n    it uses some slightly different keynames and includes description of visual\n    elements, useful to Cytoscape\"s visualisation, but having no place in SADFace.\n     Both nodes & edges in a Cytoscape graph are collated together into a single\n    elements object so we need to do that to the SADFace nodes & edges. Furthermore,\n    each node and edge object must contain a data object. After that conversion is\n    a relatively straightforward mapping:\n     EDGES\n        id -> id\n        source_id -> source\n        target_id -> target\n         e.g. \n        {\n            \"data\": {\n                \"source\": \"a1\",\n                \"id\": \"a1s1\",\n                \"target\": \"s1\"\n            }\n        }\n     NODES - ATOMS    \n        id -> id\n        type -> type\n        text -> content\n        + \"classes\":\"atom-label\"\n        + \"typeshape\":\"roundrectangle\"\n         e.g.\n        {\n            \"classes\": \"atom-label\",\n            \"data\": {\n                \"content\": \"Every person is going to die\",\n                \"type\": \"atom\",\n                \"id\": \"a1\",\n                \"typeshape\": \"roundrectangle\"\n            }\n        }\n      NODES - SCHEMES\n        id -> id\n        type -> type\n        name -> content\n        + \"classes\":\"scheme-label\"\n        + \"typeshape\":\"diamond\"\n        \n        e.g.\n        {\n            \"classes\": \"scheme-label\",\n            \"data\": {\n                \"content\": \"Default\\nSupport\",\n                \"type\": \"scheme\",\n                \"id\": \"s1\",\n                \"typeshape\": \"diamond\"\n            }\n        }\n     */\n    //allows export_cytoscape to take a value such as a loaded sadface file and return a cytoscape visualisation\n    if (sadface === null || sadface === undefined) {\n      sadface = sd;\n    }\n\n    var cy = {};\n    cy.nodes = [];\n    cy.edges = [];\n    sadface.edges.forEach(function (edge) {\n      var e = {};\n      e.data = {};\n      e.data.id = edge.id;\n      e.data.source = edge.source_id;\n      e.data.target = edge.target_id;\n      cy.edges.push(e);\n    });\n    sadface.nodes.forEach(function (node) {\n      var n = {};\n      n.data = {};\n      n.data.id = node.id;\n      n.data.type = node.type;\n\n      if (n.data.type === \"atom\") {\n        n.classes = \"atom-label\";\n        n.data.typeshape = \"roundrectangle\";\n        n.data.content = node.text;\n      } else {\n        n.classes = \"scheme-label\";\n        n.data.typeshape = \"diamond\";\n        n.data.content = node.name;\n      }\n\n      cy.nodes.push(n);\n    });\n    return JSON.stringify(cy);\n  },\n  export_dot: function () {\n    /*\n    Exports a subset of SADFace to the DOT graph description language\n     Returns: String-encoded DOT document\n    */\n    var max_length = 25;\n    var edge_str = \" -> \";\n    var dot = \"digraph SADFace {\";\n    dot += \"node [style=\\\"filled\\\"]\";\n    sd.nodes.forEach(function (node) {\n      var line;\n\n      if (node.indexof(\"text\")) {\n        var txt = node.text;\n\n        if (txt.length > max_length) {\n          txt = \"\\r\\n\".join(textwrap(txt, max_length));\n        }\n\n        line = \"\\\"{}\\\"\".format(node.id) + \"[label=\\\"\" + txt + \"\\\"]\" + \" [shape=box, style=diamond];\\n\";\n        dot += line;\n      } else if (node.indexof(\"name\")) {\n        line = \"\\\"{}\\\"\".format(node.id) + \" [label=\\\"\" + node.name + \"\\\"]\" + \" [shape=diamond];\\n\";\n        dot += line;\n      }\n    });\n    sd.edges.forEach(function (edge) {\n      var source = get_node(edge.source_id);\n      var target = get_node(edge.target_id);\n\n      if (\"atom\" === source.type) {\n        dot += \"\\\"{}\\\"\".format(source.id);\n      } else if (\"scheme\" === source.type) {\n        dot += \"\\\"{}\\\"\".format(source.id);\n      }\n\n      dot += edge_str;\n\n      if (\"atom\" === target.type) {\n        dot += \"\\\"{}\\\"\".format(target.id);\n      } else if (\"scheme\" === target.type) {\n        dot += \"\\\"{}\\\"\".format(target.id);\n      }\n\n      dot += \";\\n\";\n    });\n    dot += \"}\";\n  },\n  export_json: function () {\n    /*\n    Dump the current sadface document to a JSON string\n     Returns: String-encoded JSON\n    */\n    return JSON.stringify(sd);\n  },\n  get_atom: function (atom_id) {\n    /*\n    Retrieve the atom dict identified by the supplied atom ID\n     Returns: An atom dict\n    */\n    if (atom_id) {\n      var node;\n      var size = Object.keys(sd.nodes).length;\n\n      for (var i = 0; i < size; ++i) {\n        node = sd.nodes[i];\n\n        if (node.id === atom_id) {\n          return node;\n        }\n      }\n    }\n  },\n  get_atom_metadata: function (atom_id) {\n    /*\n    Retrieve the metadata associated with the supplied atom ID.\n    */\n    if (atom_id) {\n      var atom = get_atom(atom_id);\n      return atom.metadata;\n    }\n  },\n  get_edge: function (edge_id) {\n    /*\n    Retrieve the edge dict identified by the supplied edge ID\n     Returns: An edge dict\n    */\n    if (edge_id) {\n      var edge;\n      var size = Object.keys(sd.edges).length;\n\n      for (var i = 0; i < size; ++i) {\n        edge = sd.edges[i];\n\n        if (edge.id === edge_id) {\n          return edge;\n        }\n      }\n    }\n  },\n  get_node: function (node_id) {\n    /*\n    Given a node\"s ID but no indication of node type, return the node if \n    it exists or else indicate that it doesn\"t to the caller.\n     Returns: A node dict or None\n    */\n    if (node_id) {\n      var node;\n      var size = Object.keys(sd.nodes).length;\n\n      for (var i = 0; i < size; ++i) {\n        node = sd.nodes[i];\n\n        if (node.id === node_id) {\n          return node;\n        }\n      }\n    }\n  },\n  get_resource: function (resource_id) {\n    /*\n    Retrieve the resource dict identified by the supplied resource ID\n     Returns: An resource dict\n    */\n    if (resource_id) {\n      var resource;\n      var size = Object.keys(sd.resources).length;\n\n      for (var i = 0; i < size; ++i) {\n        resource = sd.resources[i];\n\n        if (resource.id === resource_id) {\n          return resource;\n        }\n      }\n    }\n  },\n  get_scheme: function (scheme_id) {\n    /*\n    Retrieve the scheme dict identified by the supplied scheme ID\n     Returns: A scheme dict\n    */\n    if (scheme_id) {\n      var node;\n      var size = Object.keys(sd.nodes).length;\n\n      for (var i = 0; i < size; ++i) {\n        node = sd.nodes[i];\n\n        if (node.id === scheme_id) {\n          return node;\n        }\n      }\n    }\n  },\n  //get source returns an array of two values since Javascript doesn\"t support multiple return values\n  get_source: function (atom_id, resource_id) {\n    /*\n    Retrieve the source dict identified by the supplied source ID\n     Returns: An source dict\n    */\n    if (atom_id && resource_id) {\n      var sourced = [];\n      var atom = get_atom(atom_id);\n      var source;\n      var size = Object.keys(atom.sources).length;\n\n      for (var i = 0; i < size; ++i) {\n        source = atom.sources[i];\n\n        if (source.resource_id === resource_id) {\n          sourced[0] = atom;\n          sourced[1] = source;\n          return sourced;\n        }\n      }\n    }\n  },\n  import_json: function (json_string) {\n    /*\n    Take a string-encoded JSON document and loads it into a dict\n     Returns: the loaded dict\n    */\n    if (json_string) {\n      sd = JSON.parse(json_string);\n      return sd;\n    }\n  },\n  // the try/catch in sadface.py is not needed as javascript cannot read local files without making an http request (which means app can\"t be run without server), cfg values have been hardcoded\n  init: function () {\n    /*\n    Reads the config file from the supplied location then uses the data\n    contained therein to personalise a new SADFace document\n     Returns: A dict representing the new SADFace document\n    */\n    return new_sadface();\n  },\n  new_atom: function (text) {\n    /*\n    Creates a new SADFace atom node (dict) using the supplied text\n     Returns: A dict representing the new SADFace atom\n    */\n    if (text) {\n      var new_atom = {\n        \"id\": new_uuid(),\n        \"type\": \"atom\",\n        \"text\": text,\n        \"sources\": [],\n        \"metadata\": {}\n      };\n      return new_atom;\n    }\n  },\n  new_edge: function (source_id, target_id) {\n    /*\n    Creates & returns a new edge dict using the supplied source & \n    target IDs\n     Returns: A dict representing the new edge\n    */\n    if (source_id && target_id) {\n      var new_edge = {\n        \"id\": new_uuid(),\n        \"source_id\": source_id,\n        \"target_id\": target_id\n      };\n      return new_edge;\n    }\n  },\n  new_sadface: function () {\n    /*\n    Creates & returns a new SADFace document\n     Returns: A dict representing the new SADFace document\n    */\n    var new_doc = {\n      \"id\": new_uuid(),\n      \"analyst_name\": a_name,\n      \"analyst_email\": a_email,\n      \"created\": now(),\n      \"edited\": now(),\n      \"metadata\": {},\n      \"resources\": [],\n      \"nodes\": [],\n      \"edges\": []\n    };\n    return new_doc;\n  },\n  new_resource: function (content) {\n    /*\n    Given the supplied content (String), create a new resource dict\n     The arguments that SADFace describes are either constructed directly in a tool that writes\n    them to this format, or else are sourced from elsewhere, e.g. an argumentative text or\n    webpage, or else perhaps another medium, such as audio or video. Currently SADFace supports\n    textual resources which are stored in the content key. Optionally a \n        \"url\":\"some web location\"\n    pair can be added to the metadata to indicate a specific web location. Alternatively:\n        \"doi\":\"digital object identifier\" - resolvable by dx.doi.org\n        \"magnet-link\":\"a torrent file\"\n        \"isbn\":\"for books\"\n    Metadata may also store additional bibliographic or referencing/citation information\n    as defined in bibtex formats.\n     Returns: A dict representing the new SADFace resource\n    */\n    if (content) {\n      var new_resource = {\n        \"id\": new_uuid(),\n        \"content\": content,\n        \"type\": \"text\",\n        \"metadata\": {}\n      };\n      return new_resource;\n    }\n  },\n  new_scheme: function (name) {\n    /*\n    Create a new SADFace scheme (Python dict) using the supplied scheme name. The scheme\n    name should refer to an existing scheme from a known schemeset\n     Returns: A Python dict representing the new SADFace scheme\n    */\n    if (name) {\n      var new_scheme = {\n        \"id\": new_uuid(),\n        \"type\": \"scheme\",\n        \"name\": name\n      };\n      return new_scheme;\n    }\n  },\n  new_source: function (resource_id, text, offset, length) {\n    /*\n    Create a new SADFace source (Python dict) using the supplied resource ID (a source always\n    refers to an existing resource object) and identifying a section of text in the resource \n    as well as an offset & segment length for locating the text in the original resource.\n     As the resource object is enhanced to account for newer \"types\" of resource, so the\n    source object must be enhanced to keep track and enable sources to index sub-parts of\n    resources.\n     Returns: A Python dict representing the new SADFace source\n    */\n    if (resource_id && text !== null && text !== undefined && offset !== null && offset !== undefined && length !== null && length !== undefined) {\n      var new_source = {\n        \"resource_id\": resource_id,\n        \"text\": text,\n        \"offset\": offset,\n        \"length\": length\n      };\n      return new_source;\n    }\n  },\n  //uuid function from https://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript\n  new_uuid: function () {\n    /*\n    Utility method to generate a new universally unique ID. Used througout to uniquely\n    identify various items such as atoms, schemes, resources, & edges\n     Returns: A string\n    */\n    return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c => (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16));\n  },\n  now: function () {\n    /*\n    Utility method to produce timestamps in ISO format without the microsecond\n    portion, e.g. 2017-07-05T17:21:11\n     Returns: A String\n    */\n    var d = new Date(); //removes microseconds and Z from the ISO string\n\n    return d.toISOString().split(\".\")[0];\n  },\n  prettyprint: function (doc) {\n    /*\n    Print nicely formatted output of the passed in string or\n    otherwise the SADFace document encoded as a String\n     Returns: A String\n    */\n    var string;\n\n    if (doc !== null || doc !== undefined) {\n      string = sd;\n    } else {\n      string = doc;\n    }\n\n    return JSON.stringify(string, null, 2);\n  },\n  saveSADFace: function (filename, filetype) {\n    /*\n    Write the prettyprinted SADFace document to a JSON file and download\n    */\n    var f = filename;\n    var text;\n\n    if (f === null || f === undefined) {\n      f = f_name;\n    }\n\n    if (\"dot\" === filetype) {\n      f += \".dot\";\n      text = export_dot();\n    } else if (\"cytoscape\" === filetype) {\n      f += \".json\";\n      text = prettyprint(JSON.parse(export_cytoscape(null)));\n    } else {\n      f += \".json\";\n      text = JSON.stringify(sd, null, 2);\n    }\n\n    download(f, text);\n  },\n  loadSADFace: function (file) {\n    /*\n    Create a read for a JSON file\n    */\n    if (file) {\n      var reader = new FileReader();\n      reader.readAsText(file);\n      return reader;\n    }\n  },\n  download: function (filename, text) {\n    /*\n    Downloads a file given its filename and its text using utf-8 charset\n    */\n    console.log(\"Downloading \" + filename);\n    var outfile = document.createElement(\"a\");\n    outfile.setAttribute(\"href\", \"data:text/plain;charset=utf-8,\" + encodeURIComponent(text));\n    outfile.setAttribute(\"download\", filename);\n    outfile.style.display = \"none\";\n    document.body.appendChild(outfile);\n    outfile.click();\n    document.body.removeChild(outfile);\n  },\n  update: function () {\n    /*\n    Updates the last edited timestamp for the SADFace doc to now\n    */\n    sd.edited = now();\n  },\n  update_analyst_email: function (analystemail) {\n    /*\n    Updates the name of the argument analyst in the SADFace doc to the supplied name\n    */\n    if (analystemail) {\n      sd.analyst_email = analystemail;\n    }\n  },\n  update_analyst_name: function (analystname) {\n    /*\n    Updates the name of the argument analyst in the SADFace doc to the supplied name\n    */\n    if (analystname) {\n      sd.analyst_name = analystname;\n    }\n  },\n  update_atom_text: function (atom_id, new_text) {\n    /* \n    An atoms text key:value pair is the canonical representation of a portion of text \n    that exists in an argument. This should be updatable so that the overall document \n    makes sense. Links to original source texts are maintained via the source list \n    which indexes original text portions of linked resources.\n     Returns: The updated atom dict\n    */\n    if (atom_id && new_text) {\n      var atom = get_atom(atom_id);\n\n      if (atom !== null || atom !== undefined) {\n        atom.text = new_text;\n        return atom;\n      } else {\n        throw \"Could not update the text value for atom: \" + atom_id;\n      }\n    }\n  },\n  update_atom_metadata: function (atom_id, metadata) {\n    /*\n    Given an atoms ID and a dict object containing its metadata, updates the atom with\n    new set of metadata.\n    \n    Returns: The updated atom dict\n    */\n    if (atom_id && metadata) {\n      var atom = get_atom(atom_id);\n\n      if (atom !== null || atom !== undefined) {\n        atom.metadata = metadata;\n        return atom;\n      } else {\n        throw \"Could not update the metadata for atom: \" + atom_id;\n      }\n    }\n  },\n  update_created: function (timestamp) {\n    /*\n        Updates the creation timestamp for the SADFace document to the supplied timestamp.\n    This can be useful when moving analysed argument data between formats whilst\n    maintaining original metadata.\n    */\n    if (timestamp) {\n      sd.timestamp = timestamp;\n    }\n  },\n  update_id: function (id) {\n    /*\n    Update the SADFace document ID to match the supplied ID. This can be useful when \n    moving analysed argument data between formats whilst maintaining original metadata.\n    */\n    if (id) {\n      sd.id = id;\n    }\n  },\n  update_edited: function (timestamp) {\n    /*\n    Update the last edited timestamp for the SADFace doc to match the supplied\n    timestamp. This can be useful when moving analysed argument data between formats \n    whilst maintaining original metadata.\n    */\n    if (timestamp) {\n      sd.edited = timestamp;\n    }\n  },\n  update_scheme: function (scheme_id, scheme_name) {\n    /*\n    Given an ID for an existing scheme node, update the name associated with it and return the scheme node.\n    \n    Returns: Updated scheme dict\n    */\n    if (scheme_id && scheme_name) {\n      var scheme = get_scheme(scheme_id);\n\n      if (scheme !== null || scheme !== undefined) {\n        scheme.name = scheme_name;\n        return scheme;\n      } else {\n        throw \"Could not update the name of scheme: \" + scheme_id;\n      }\n    }\n  },\n  update_resource: function (resource_id, content, title) {\n    /*\n    Given an ID for an existing resource, update the content and metadata of the resource.\n    Updates the resource in sd;\n    */\n    if (resource_id && (content || title)) {\n      var resource = get_resource(resource_id);\n\n      if (resource !== null && resource !== undefined) {\n        if (content !== null && content !== undefined) {\n          resource.content = content;\n        }\n\n        if (title !== null && title !== undefined) {\n          resource.metadata.title = title;\n        }\n\n        sd.resources.forEach(res => {\n          if (res.id === resource_id) {\n            res = resource;\n          }\n        });\n      } else {\n        throw \"Could not update the resource: \" + resource_id;\n      }\n    }\n  },\n  get_sd: function () {\n    /*\n    Function to get the current state of SD\n    \n    Returns: Current state of SD\n    */\n    return sd;\n  },\n\n  /*\n  *\n  *   JS Specific Utility Functions\n  *\n  */\n\n  /*\n  String.prototype.format = () => {\n    var i = 0, args = arguments;\n    return this.replace(/{}/g, () => {\n      return typeof args[i] !== \"undefined\" ? args[i++] : \"\";\n    });\n  };\n  \n  */\n  //COME BACK to this\n\n  /*\n  const remove_falsy = (obj) => {\n      /*\n      The delete function in javascript tends to replace deleted objects with\n      null values. This function removes those from an object after something within it is deleted.\n      \n      if (obj) {\n          var newObj = [];\n          Object.keys(obj).forEach((prop) => {\n              if (obj[prop]) { \n                  newObj.push(obj[prop]); \n              }\n          });\n          return newObj;\n      } else {\n          return obj;\n      }\n  };\n  */\n  //textwrap function from https://gist.github.com/bgrayburn/44fa018b94222590f618\n  textwrap: function (long_string, max_char) {\n    if (long_string && max_char) {\n      var sum_length_of_words = word_array => {\n        var out = 0;\n\n        if (word_array.length !== 0) {\n          for (var i = 0; i < word_array.length; i++) {\n            var word = word_array[i];\n            out = out + word.length;\n          }\n        }\n\n        return out;\n      };\n\n      var split_out = [[]];\n      var split_string = long_string.split(\" \");\n\n      for (var i = 0; i < split_string.length; i++) {\n        var word = split_string[i];\n\n        if (sum_length_of_words(split_out[split_out.length - 1]) + word.length > max_char) {\n          split_out = split_out.concat([[]]);\n        }\n\n        split_out[split_out.length - 1] = split_out[split_out.length - 1].concat(word);\n      }\n\n      for (i = 0; i < split_out.length; i++) {\n        split_out[i] = split_out[i].join(\" \");\n      }\n\n      return split_out;\n    }\n  }\n};\nmodule.exports = sadface;","map":{"version":3,"sources":["/Users/gareth/Desktop/monkeypuzzle/src/lib/Sadface.js"],"names":["sadface","add_argument","con_text","prem_text","con_id","prem_id","undefined","c","s","p_list","atom","arg","add_atom","get_atom","add_scheme","add_edge","id","ex","console","log","forEach","text","push","atom_id","add_conflict","arg_text","arg_id","conflict_text","conflict_id","a","source_id","target_id","get_node","edge","new_edge","sd","edges","new_atom","nodes","add_atom_metadata","key","value","node","type","metadata","add_resource","content","res","new_resource","resources","add_resource_metadata","resource_id","add_sadface_metadata","name","scheme","new_scheme","add_source","offset","length","source","new_source","sources","delete_atom","size","Object","keys","i","remove_falsy","delete_edge","edge_id","del_edge","get_edge","delete_source","get_source","delete_resource","resource","get_resource","delete_scheme","scheme_id","get_scheme","export_cytoscape","cy","e","data","target","n","classes","typeshape","JSON","stringify","export_dot","max_length","edge_str","dot","line","indexof","txt","join","textwrap","format","export_json","get_atom_metadata","node_id","sourced","import_json","json_string","parse","init","new_sadface","new_uuid","new_doc","a_name","a_email","now","replace","crypto","getRandomValues","Uint8Array","toString","d","Date","toISOString","split","prettyprint","doc","string","saveSADFace","filename","filetype","f","f_name","download","loadSADFace","file","reader","FileReader","readAsText","outfile","document","createElement","setAttribute","encodeURIComponent","style","display","body","appendChild","click","removeChild","update","edited","update_analyst_email","analystemail","analyst_email","update_analyst_name","analystname","analyst_name","update_atom_text","new_text","update_atom_metadata","update_created","timestamp","update_id","update_edited","update_scheme","scheme_name","update_resource","title","get_sd","long_string","max_char","sum_length_of_words","word_array","out","word","split_out","split_string","concat","module","exports"],"mappings":"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","sourcesContent":["\n/*var sd = {};\n\n//values from defaults.cfg\nvar a_name = \"A user\";\nvar a_email = \"user@email.address\";\nvar f_name = \"data\";\n*/\nvar sadface = {\n\n add_argument: function(con_text, prem_text, con_id, prem_id) {\n    /*\n    Syntactic sugar to create an argument structure from a set of texts.\n    Given a conclusion text & a list of premise texts, create an intermediate,\n    default \"support\" scheme.\n\n    This makes it easier to build a SADFace document without manually creating\n    and organising individual nodes.\n\n    Returns an argument dict, e.g.\n\n    {\n        \"conclusion\": atom,\n        \"scheme\": atom,\n        \"premises\": [atom(s)]\n    }\n\n    Returns: a dict\n    */\n    if(((con_text !== null && con_text !== undefined) || (con_id !== null && con_id !== undefined)) && ((prem_text !== null && prem_text !== undefined) || (prem_id !== null && prem_id !== undefined))) {\n        \n        var c;\n        var s;\n        var p_list = [];\n        var atom;\n        var arg = {};\n        \n        if(con_text !== null) {\n            c = add_atom(con_text);\n        } else {\n            c = get_atom(con_id);\n        }\n        s = add_scheme(\"support\");\n        try  {\n            add_edge(s.id, c.id);\n        }\n        catch(ex) {\n            console.log(ex);\n            throw (\"Could not create new argument\");\n        }\n        \n        \n        if(prem_text !== null) {\n            prem_text.forEach(function(text) {\n                atom = add_atom(text);\n                p_list.push(atom.id);\n                try {\n                    add_edge(atom.id, s.id);\n                }\n                catch (ex) {\n                    console.log(ex);\n                    throw (\"Could not create new argument\");\n                }\n            });\n        }\n        if(prem_id !== null) {\n            prem_id.forEach(function(atom_id) {\n                atom = get_atom(atom_id);\n                p_list.push(atom.id);\n                try {\n                    add_edge(atom.id, s.id);\n                }\n                catch (ex) {\n                    console.log(ex);\n                    throw (\"Could not create new argument\");\n                } \n            });\n        }\n        arg = {\"conclusion\":c, \"scheme\":s, \"premises\":p_list};\n        return arg;\n    }\n    return;\n},\n\n add_conflict: function (arg_text, arg_id, conflict_text, conflict_id) {\n    /*\n        Conflicts play an important role in arguments. We depict conflict\n    through the use of schemes that represent the conflict relationship. This\n    function will instantiate a conflict scheme between two nodes (either\n    pre-existing & identifed by node IDs or created from supplied texts, or a\n    mixture of the two).\n\n    Returns a conflict dict, e.g.\n\n    {\n        \"argument\": atom,\n        \"scheme\": atom,\n        \"conflict\": atom\n    }\n    (where the scheme just happens to depict a conflict)\n\n    Returns: a dict\n    */\n    if(((arg_text !== null && arg_text !== undefined) || (arg_id !== null && arg_id !== undefined )) && ((conflict_text !== null && conflict_id !== null) || (conflict_text !== undefined && conflict_id !== undefined))) {\n        \n        var c;\n        var s;\n        var a;\n        var arg = {};\n        \n        if (arg_text!==null || arg_text !==undefined) {\n            a = add_atom(arg_text);\n        } else {\n            a = get_atom(arg_id);\n        }\n        s = add_scheme(\"conflict\");\n        \n        try {\n            add_edge(s.id, a.id);\n        }\n        catch(ex) {\n            console.log(ex);\n            throw (\"Could not create new argument\");\n        }\n        \n        if (conflict_text !== null || conflict_text !== undefined) {\n            c = add_atom(conflict_text);\n        } else {\n            c = get_atom(conflict_id);\n        }\n        \n        try {\n            add_edge(c.id, s.id);\n        }\n        catch(ex) {\n            console.log(ex);\n            throw(\"Could not create new argument\");\n        }\n        \n        arg = {\"argument\":a, \"scheme\":s, \"conflict\":c};\n        return arg;\n    }\n    return;\n},\n\n  add_edge: function(source_id, target_id) {\n    /*\n    Given a source atom ID & a target atom ID, create an \n    edge linking the two and add it to the sadface doc,\n    \"sd\" & return the dict representing the edge. If\n    either of source or target IDs is invalid then an\n    exception is raised.\n\n    Returns: a dict \n    */\n    if (source_id && target_id) {\n        if ((get_node(source_id) !== null) && (get_node(target_id) !== null)) {\n            var edge = new_edge(source_id, target_id);\n            sd.edges.push(edge);\n            return edge;\n        }\n        throw(\"Could not create new edge between: \" +source_id+\" & \"+target_id);\n    }\n},\n add_atom: function(text) {\n    /*    \n    Create a new argument atom using the supplied text\n\n    Returns: the new atom dict\n    */\n    if (text) {\n        var atom = new_atom(text);\n        sd.nodes.push(atom);\n        return atom;\n    }\n},\n\n add_atom_metadata: function(atom_id, key, value) {\n    /*\n    Add metadata, a key:value pair to the atom dict identified\n    by the supplied atom ID.\n    */\n    if (atom_id && key && value) {\n        sd.nodes.forEach(function(node) {\n            if(\"atom\" === node.type) {\n                if (atom_id === node.id) {\n                    node.metadata[key] = value;\n                }\n            }\n        });\n    }\n},\n\n add_resource: function(content) {\n    /*\n    Create a new resource dict using the supplied content string\n    then add to the resourses list of the sadface doc\n\n    Returns: the new resource dict\n    */\n    if (content) {\n        var res = new_resource(content);\n        sd.resources.push(res);\n        return res;\n    }\n},\n\n add_resource_metadata: function(resource_id, key, value) {\n    /*\n    Add metadata, a key:value pair to the resource dict identified\n    by the supplied atom ID.    \n    */\n    if (resource_id && key && value) {\n        sd.resources.forEach(function(res) {\n            if(res.id === resource_id) {\n                res.metadata[key] = value;\n            }\n        });\n    }\n},\n\n\n add_sadface_metadata: function(key, value) {\n    /*\n    Add metadata, a key:value pair to the base sadface doc\n    */\n    if (key && value) {\n        sd.metadata[key] = value;\n    }\n},\n\n\n add_scheme: function(name) {\n    /*\n    Add a new scheme node dict to the sadface document. The scheme type\n    is identified by the supplied name\n\n    Returns: The new scheme dict\n    */\n    if (name) {\n        var scheme = new_scheme(name);\n        sd.nodes.push(scheme);\n        return scheme;\n    }\n},\n\n\n add_source: function(atom_id, resource_id, text, offset, length) {\n    /*\n    Add a new source dict to the atom identified by the supplied\n    atom ID. The new source refers to the an existing resource that\n    is identified by the supplied resource ID. The source identifies\n    text string in the resource dict that it references as well as\n    the offset & length of the text from the beginning of the resource\n\n    Returns: The new source dict\n    */\n    if (atom_id && resource_id && text !== null && offset !== null && length !== null && text !== undefined && offset !== undefined && length !== undefined) {\n        var source = new_source(resource_id, text, offset, length);\n        sd.nodes.forEach(function(node) {\n            if (\"atom\" === node.type) {\n                if (atom_id === node.id) {\n                    node.sources.push(source);\n                }\n            }\n        });\n        return source;\n    }\n},\n\n\n delete_atom: function(atom_id) {\n    /*\n    Remove the atom from the sadface document identified by the\n    supplied atom ID\n    */\n    if (atom_id) {\n        var atom = get_atom(atom_id);\n        if (atom !== null && atom !== undefined) {\n            var size = Object.keys(sd.nodes).length;\n            for (var i = 0; i < size; ++i) {\n                if (sd.nodes[i].id === atom.id) {\n                    delete sd.nodes[i];\n                    sd.nodes = remove_falsy(sd.nodes);\n                    return;\n                }\n            }\n        }\n    }\n},\n\n\n delete_edge: function(edge_id)\n{\n    /*\n    Remove the edge from the sadface document identified by the\n    supplied edge ID\n    */\n    if (edge_id) {\n        var del_edge = get_edge(edge_id);\n        var size = Object.keys(sd.edges).length;\n        for (var i = 0; i < size; ++i) {\n            if (sd.edges[i].id === del_edge.id) {\n                delete sd.edges[i];\n                sd.edges = remove_falsy(sd.edges);\n                return;\n            }\n        }\n    }\n},\n\n\n delete_source: function(atom_id, resource_id) {\n    /*\n    Remove a source from the atom identified by the\n    supplied atom ID & resource ID respectively\n    */\n    if (atom_id && resource_id) {\n        var source = get_source(atom_id, resource_id);\n        var size = Object.keys(sd.nodes).length;\n        for (var i = 0; i < size; ++i) {\n            if (sd.nodes[i].atom.sources.resource_id === source.id) {\n                delete sd.nodes[i].atom_id.sources.resource_id;\n                sd.nodes[i].atom_id.sources = remove_falsy(sd.nodes);\n                return;\n            }\n        }\n    }\n},\n\n\n delete_resource: function(resource_id) {\n    /*\n    Remove the resource from the sadface document identified by the\n    supplied resource ID\n    */\n    if (resource_id) {\n        var resource = get_resource(resource_id);\n        if (resource !== null && resource !== undefined) {\n            var size = Object.keys(sd.resources).length;\n            for (var i = 0; i < size; ++i) {\n                if (sd.resources[i].id === resource.id) {\n                    delete sd.resources[i];\n                    sd.resources = remove_falsy(sd.resources);\n                    return;\n                } \n            }\n        }\n    }\n},\n\n\n delete_scheme: function(scheme_id) {\n    /*\n    Remove the schemee from the sadface document identified by the\n    supplied scheme ID\n    */\n    if (scheme_id) {\n        var scheme = get_scheme(scheme_id);\n        if (scheme !== null && scheme !== undefined) {\n            var size = Object.keys(sd.nodes).length;\n            for (var i = 0; i < size; ++i) {\n                if (sd.nodes[i].id === scheme.id) {\n                    delete sd.nodes[i];\n                    sd.nodes = remove_falsy(sd.nodes);\n                    return;\n                } \n            }\n        }\n    }\n},\n\n\n  export_cytoscape: function(sadface) {\n    /*\n    Cytoscape.js is a useful graph visualisation library for Javascript. However\n    it uses some slightly different keynames and includes description of visual\n    elements, useful to Cytoscape\"s visualisation, but having no place in SADFace.\n\n    Both nodes & edges in a Cytoscape graph are collated together into a single\n    elements object so we need to do that to the SADFace nodes & edges. Furthermore,\n    each node and edge object must contain a data object. After that conversion is\n    a relatively straightforward mapping:\n\n    EDGES\n        id -> id\n        source_id -> source\n        target_id -> target\n\n        e.g. \n        {\n            \"data\": {\n                \"source\": \"a1\",\n                \"id\": \"a1s1\",\n                \"target\": \"s1\"\n            }\n        }\n\n    NODES - ATOMS    \n        id -> id\n        type -> type\n        text -> content\n        + \"classes\":\"atom-label\"\n        + \"typeshape\":\"roundrectangle\"\n\n        e.g.\n        {\n            \"classes\": \"atom-label\",\n            \"data\": {\n                \"content\": \"Every person is going to die\",\n                \"type\": \"atom\",\n                \"id\": \"a1\",\n                \"typeshape\": \"roundrectangle\"\n            }\n        }\n\n\n    NODES - SCHEMES\n        id -> id\n        type -> type\n        name -> content\n        + \"classes\":\"scheme-label\"\n        + \"typeshape\":\"diamond\"\n        \n        e.g.\n        {\n            \"classes\": \"scheme-label\",\n            \"data\": {\n                \"content\": \"Default\\nSupport\",\n                \"type\": \"scheme\",\n                \"id\": \"s1\",\n                \"typeshape\": \"diamond\"\n            }\n        }\n\n    */\n    //allows export_cytoscape to take a value such as a loaded sadface file and return a cytoscape visualisation\n    if (sadface === null || sadface === undefined)\n    {\n        sadface = sd;\n    }\n    var cy = {};\n    cy.nodes = [];\n    cy.edges = [];\n\n    sadface.edges.forEach(function(edge) {\n        var e = {};\n        e.data = {};\n        e.data.id = edge.id;\n        e.data.source = edge.source_id;\n        e.data.target = edge.target_id;\n        cy.edges.push(e);\n    });\n    \n    sadface.nodes.forEach(function(node) {\n        var n = {};\n        n.data = {};\n        n.data.id = node.id;\n        n.data.type = node.type;\n\n        if (n.data.type === \"atom\") {\n            n.classes = \"atom-label\";\n            n.data.typeshape = \"roundrectangle\";\n            n.data.content = node.text;\n        } else {\n            n.classes = \"scheme-label\";\n            n.data.typeshape = \"diamond\";\n            n.data.content = node.name;\n        }\n        \n        cy.nodes.push(n);\n    });\n    return JSON.stringify(cy);\n},\n\n export_dot: function() {\n    /*\n    Exports a subset of SADFace to the DOT graph description language\n\n    Returns: String-encoded DOT document\n    */\n    var max_length = 25;\n    var edge_str = \" -> \";\n    var dot = \"digraph SADFace {\";\n    dot += \"node [style=\\\"filled\\\"]\";\n\n    sd.nodes.forEach(function(node) {\n        var line;\n        if (node.indexof(\"text\")) {\n            var txt = node.text;\n            if (txt.length > max_length) {\n                txt = \"\\r\\n\".join(textwrap(txt,max_length));\n            }\n            line = \"\\\"{}\\\"\".format(node.id) + \"[label=\\\"\" + txt + \"\\\"]\" + \" [shape=box, style=diamond];\\n\";\n            dot += line;\n        } else if (node.indexof(\"name\")) {\n            line = \"\\\"{}\\\"\".format(node.id) + \" [label=\\\"\" + node.name + \"\\\"]\" + \" [shape=diamond];\\n\";\n            dot += line;\n        }\n    });\n    \n    sd.edges.forEach(function(edge) {\n        var source = get_node(edge.source_id);\n        var target = get_node(edge.target_id);\n        \n        if(\"atom\" === source.type) {\n            dot += \"\\\"{}\\\"\".format(source.id);\n        } else if (\"scheme\" === source.type){\n            dot += \"\\\"{}\\\"\".format(source.id);\n        }\n        \n        dot += edge_str;\n        \n        if(\"atom\" === target.type) {\n            dot += \"\\\"{}\\\"\".format(target.id);\n        } else if (\"scheme\" === target.type){\n            dot += \"\\\"{}\\\"\".format(target.id);\n        }\n        \n        dot += \";\\n\";    \n    });\n    dot += \"}\";\n},\n\n export_json: function() {\n    /*\n    Dump the current sadface document to a JSON string\n\n    Returns: String-encoded JSON\n    */\n    return JSON.stringify(sd);\n},\n\n get_atom: function(atom_id) {\n    /*\n    Retrieve the atom dict identified by the supplied atom ID\n\n    Returns: An atom dict\n    */\n    if (atom_id) {\n        var node;\n        var size = Object.keys(sd.nodes).length;\n        for (var i = 0; i < size; ++i) {\n            node = sd.nodes[i];\n            if (node.id === atom_id) {\n                return node;\n            } \n        }\n    }\n},\n\n get_atom_metadata: function(atom_id) {\n    /*\n    Retrieve the metadata associated with the supplied atom ID.\n    */\n    if (atom_id) {\n        var atom = get_atom(atom_id);\n        return atom.metadata;\n\n    }\n},\n\n get_edge: function(edge_id) {\n    /*\n    Retrieve the edge dict identified by the supplied edge ID\n\n    Returns: An edge dict\n    */\n    if (edge_id) {\n        var edge;\n        var size = Object.keys(sd.edges).length;\n        for (var i = 0; i < size; ++i) {\n            edge = sd.edges[i];\n            if (edge.id === edge_id) {\n                return edge;\n            } \n        }\n    }\n},\n\n get_node: function(node_id) {\n    /*\n    Given a node\"s ID but no indication of node type, return the node if \n    it exists or else indicate that it doesn\"t to the caller.\n\n    Returns: A node dict or None\n    */\n    if (node_id) {\n        var node;\n        var size = Object.keys(sd.nodes).length;\n        for (var i = 0; i < size; ++i) {\n            node = sd.nodes[i];\n            if (node.id === node_id) {\n                return node;\n            } \n        }\n    }\n},\n\n get_resource: function(resource_id) {\n    /*\n    Retrieve the resource dict identified by the supplied resource ID\n\n    Returns: An resource dict\n    */\n    if (resource_id) {\n        var resource;\n        var size = Object.keys(sd.resources).length;\n        for (var i = 0; i < size; ++i) {\n            resource = sd.resources[i];\n            if (resource.id === resource_id) {\n                return resource;\n            } \n        }\n    }\n},\n\n get_scheme: function(scheme_id) {\n    /*\n    Retrieve the scheme dict identified by the supplied scheme ID\n\n    Returns: A scheme dict\n    */\n    if (scheme_id) {\n        var node;\n        var size = Object.keys(sd.nodes).length;\n        for (var i = 0; i < size; ++i) {\n            node = sd.nodes[i];\n            if (node.id === scheme_id) {\n                return node;\n            } \n        }\n    }\n},\n\n//get source returns an array of two values since Javascript doesn\"t support multiple return values\n get_source: function(atom_id, resource_id) {\n    /*\n    Retrieve the source dict identified by the supplied source ID\n\n    Returns: An source dict\n    */\n    if (atom_id && resource_id) {\n        var sourced = [];\n        var atom = get_atom(atom_id);\n        var source;\n        var size = Object.keys(atom.sources).length;\n        for (var i = 0; i < size; ++i) {\n            source = atom.sources[i];\n            if (source.resource_id === resource_id) {\n                sourced[0] = atom;\n                sourced[1] = source;\n                return sourced;\n            } \n        }\n    }\n},\n\n import_json: function(json_string) {\n    /*\n    Take a string-encoded JSON document and loads it into a dict\n\n    Returns: the loaded dict\n    */\n    if (json_string) {\n        sd = JSON.parse(json_string);\n        return sd;\n    }\n},\n\n// the try/catch in sadface.py is not needed as javascript cannot read local files without making an http request (which means app can\"t be run without server), cfg values have been hardcoded\n init: function() {\n    /*\n    Reads the config file from the supplied location then uses the data\n    contained therein to personalise a new SADFace document\n\n    Returns: A dict representing the new SADFace document\n    */\n    return new_sadface();\n},\n\n new_atom: function(text) {\n    /*\n    Creates a new SADFace atom node (dict) using the supplied text\n\n    Returns: A dict representing the new SADFace atom\n    */\n    if (text) {\n        var new_atom = {\"id\":new_uuid(), \"type\":\"atom\", \"text\":text, \"sources\":[], \"metadata\":{}};\n        return new_atom;\n    }\n},\n\n new_edge: function(source_id, target_id) {\n    /*\n    Creates & returns a new edge dict using the supplied source & \n    target IDs\n\n    Returns: A dict representing the new edge\n    */\n    if (source_id && target_id) {\n        var new_edge = {\"id\":new_uuid(), \"source_id\":source_id, \"target_id\":target_id};\n        return new_edge;\n    }\n},\n\n new_sadface: function() {\n    /*\n    Creates & returns a new SADFace document\n\n    Returns: A dict representing the new SADFace document\n    */\n    var new_doc = {\"id\":new_uuid(), \"analyst_name\":a_name, \"analyst_email\":a_email, \"created\":now(), \"edited\":now(), \"metadata\":{}, \"resources\":[], \"nodes\":[], \"edges\":[]};\n    return new_doc;\n},\n\n new_resource: function(content) {\n    /*\n    Given the supplied content (String), create a new resource dict\n\n    The arguments that SADFace describes are either constructed directly in a tool that writes\n    them to this format, or else are sourced from elsewhere, e.g. an argumentative text or\n    webpage, or else perhaps another medium, such as audio or video. Currently SADFace supports\n    textual resources which are stored in the content key. Optionally a \n        \"url\":\"some web location\"\n    pair can be added to the metadata to indicate a specific web location. Alternatively:\n        \"doi\":\"digital object identifier\" - resolvable by dx.doi.org\n        \"magnet-link\":\"a torrent file\"\n        \"isbn\":\"for books\"\n    Metadata may also store additional bibliographic or referencing/citation information\n    as defined in bibtex formats.\n\n    Returns: A dict representing the new SADFace resource\n    */\n    if (content) {\n        var new_resource = {\"id\":new_uuid(), \"content\":content, \"type\":\"text\", \"metadata\":{}};\n        return new_resource;\n    }\n},\n\n new_scheme: function(name) {\n    /*\n    Create a new SADFace scheme (Python dict) using the supplied scheme name. The scheme\n    name should refer to an existing scheme from a known schemeset\n\n    Returns: A Python dict representing the new SADFace scheme\n    */\n    if (name) {\n        var new_scheme = {\"id\":new_uuid(), \"type\":\"scheme\", \"name\":name};\n        return new_scheme;\n    }\n},\n\n new_source: function(resource_id, text, offset, length) {\n    /*\n    Create a new SADFace source (Python dict) using the supplied resource ID (a source always\n    refers to an existing resource object) and identifying a section of text in the resource \n    as well as an offset & segment length for locating the text in the original resource.\n\n    As the resource object is enhanced to account for newer \"types\" of resource, so the\n    source object must be enhanced to keep track and enable sources to index sub-parts of\n    resources.\n\n    Returns: A Python dict representing the new SADFace source\n    */\n    if (resource_id && text !== null && text !== undefined && offset !== null && offset !== undefined && length !== null && length !== undefined) {\n        var new_source = {\"resource_id\":resource_id, \"text\":text, \"offset\":offset, \"length\":length};\n        return new_source;\n    }\n},\n\n//uuid function from https://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript\n new_uuid: function() {\n    /*\n    Utility method to generate a new universally unique ID. Used througout to uniquely\n    identify various items such as atoms, schemes, resources, & edges\n\n    Returns: A string\n    */\n    return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>\n        (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)\n    );\n},\n\n now: function() {\n    /*\n    Utility method to produce timestamps in ISO format without the microsecond\n    portion, e.g. 2017-07-05T17:21:11\n\n    Returns: A String\n    */\n    var d = new Date();\n    //removes microseconds and Z from the ISO string\n    return d.toISOString().split(\".\")[0];\n},\n\n prettyprint: function(doc) {\n    /*\n    Print nicely formatted output of the passed in string or\n    otherwise the SADFace document encoded as a String\n\n    Returns: A String\n    */\n    var string;\n    if (doc !== null || doc !== undefined) {\n        string = sd;\n    } else {\n        string = doc;\n    }\n    return JSON.stringify(string, null, 2);\n},\n\n saveSADFace: function(filename, filetype) {\n    /*\n    Write the prettyprinted SADFace document to a JSON file and download\n    */\n    var f = filename;\n    var text;\n    if (f === null || f === undefined) {\n        f = f_name;\n    }\n    \n    if (\"dot\" === filetype) {\n        f += \".dot\";\n        text = export_dot();\n    } else if (\"cytoscape\" === filetype) {\n        f += \".json\";\n        text = prettyprint(JSON.parse(export_cytoscape(null)));\n    } else {\n        f += \".json\";\n        text = JSON.stringify(sd, null, 2);\n    }\n    download(f, text);\n},\n\n loadSADFace: function(file) {\n    /*\n    Create a read for a JSON file\n    */\n    if (file) {\n        var reader = new FileReader();    \n        reader.readAsText(file);\n        \n        return reader;\n    }\n},\n\n download: function(filename, text) {\n    /*\n    Downloads a file given its filename and its text using utf-8 charset\n    */\n    console.log(\"Downloading \"+filename);\n    var outfile = document.createElement(\"a\");\n    outfile.setAttribute(\"href\", \"data:text/plain;charset=utf-8,\" + encodeURIComponent(text));\n    outfile.setAttribute(\"download\", filename);\n\n    outfile.style.display = \"none\";\n    document.body.appendChild(outfile);\n\n    outfile.click();\n\n    document.body.removeChild(outfile);\n},\n\n update: function() {\n    /*\n    Updates the last edited timestamp for the SADFace doc to now\n    */\n    sd.edited = now();\n},\n\n update_analyst_email: function(analystemail) {\n    /*\n    Updates the name of the argument analyst in the SADFace doc to the supplied name\n    */\n    if (analystemail) {\n        sd.analyst_email = analystemail;\n    }\n},\n\n update_analyst_name: function(analystname) {\n    /*\n    Updates the name of the argument analyst in the SADFace doc to the supplied name\n    */\n    if (analystname) {\n        sd.analyst_name = analystname;\n    }\n},\n\n update_atom_text: function(atom_id, new_text) {\n    /* \n    An atoms text key:value pair is the canonical representation of a portion of text \n    that exists in an argument. This should be updatable so that the overall document \n    makes sense. Links to original source texts are maintained via the source list \n    which indexes original text portions of linked resources.\n\n    Returns: The updated atom dict\n    */\n    if (atom_id && new_text) {\n        var atom = get_atom(atom_id);\n        if (atom !== null || atom !== undefined) {\n            atom.text = new_text;\n            return atom;\n        } else {\n            throw (\"Could not update the text value for atom: \"+atom_id);\n        }\n    }\n},\n\n update_atom_metadata: function(atom_id, metadata) {\n    /*\n    Given an atoms ID and a dict object containing its metadata, updates the atom with\n    new set of metadata.\n    \n    Returns: The updated atom dict\n    */\n    if (atom_id && metadata) {\n        var atom = get_atom(atom_id);\n        if (atom !== null || atom !== undefined) {\n            atom.metadata = metadata;\n            return atom;\n        } else {\n            throw (\"Could not update the metadata for atom: \"+atom_id);\n        }\n    }\n},\n\n update_created: function(timestamp) {\n    /*\n        Updates the creation timestamp for the SADFace document to the supplied timestamp.\n    This can be useful when moving analysed argument data between formats whilst\n    maintaining original metadata.\n    */\n    if (timestamp) {\n        sd.timestamp = timestamp;\n    }\n},\n\n update_id: function(id) {\n    /*\n    Update the SADFace document ID to match the supplied ID. This can be useful when \n    moving analysed argument data between formats whilst maintaining original metadata.\n    */\n    if (id) {\n        sd.id = id;\n    }\n},\n\n update_edited: function(timestamp) {\n    /*\n    Update the last edited timestamp for the SADFace doc to match the supplied\n    timestamp. This can be useful when moving analysed argument data between formats \n    whilst maintaining original metadata.\n    */\n    if (timestamp) {\n        sd.edited = timestamp;\n    }\n},\n\n update_scheme: function(scheme_id, scheme_name) {\n    /*\n    Given an ID for an existing scheme node, update the name associated with it and return the scheme node.\n    \n    Returns: Updated scheme dict\n    */\n    if (scheme_id && scheme_name) {\n        var scheme = get_scheme(scheme_id);\n        if (scheme !== null || scheme !== undefined) {\n            scheme.name = scheme_name;\n            return scheme;\n        } else {\n            throw (\"Could not update the name of scheme: \"+scheme_id);\n        }\n    }\n},\n\n update_resource: function(resource_id, content, title) {\n    /*\n    Given an ID for an existing resource, update the content and metadata of the resource.\n    Updates the resource in sd;\n    */\n\n    if (resource_id && (content || title)) {\n        var resource = get_resource(resource_id);\n        if (resource !== null && resource !== undefined) {\n            if (content !== null && content !== undefined) {\n                resource.content = content;\n            }\n            if (title !== null && title !== undefined) {\n                resource.metadata.title = title;\n            }\n            sd.resources.forEach((res) => {\n                if(res.id === resource_id) {\n                    res = resource;\n                }\n            });\n        } else {\n            throw (\"Could not update the resource: \"+resource_id);\n        }\n    }\n},\n\n get_sd: function() {\n    /*\n    Function to get the current state of SD\n    \n    Returns: Current state of SD\n    */\n    return sd;\n},\n\n\n/*\n*\n*   JS Specific Utility Functions\n*\n*/\n\n/*\nString.prototype.format = () => {\n  var i = 0, args = arguments;\n  return this.replace(/{}/g, () => {\n    return typeof args[i] !== \"undefined\" ? args[i++] : \"\";\n  });\n};\n\n*/\n//COME BACK to this\n/*\nconst remove_falsy = (obj) => {\n    /*\n    The delete function in javascript tends to replace deleted objects with\n    null values. This function removes those from an object after something within it is deleted.\n    \n    if (obj) {\n        var newObj = [];\n        Object.keys(obj).forEach((prop) => {\n            if (obj[prop]) { \n                newObj.push(obj[prop]); \n            }\n        });\n        return newObj;\n    } else {\n        return obj;\n    }\n};\n*/\n\n//textwrap function from https://gist.github.com/bgrayburn/44fa018b94222590f618\n textwrap: function (long_string, max_char){\n    if (long_string && max_char) {\n        var sum_length_of_words = (word_array) => {\n            var out = 0;\n            if (word_array.length!==0){\n              for (var i=0; i<word_array.length; i++){\n                var word = word_array[i];\n                out = out + word.length;\n              }\n            }\n            return out;\n        };\n\n        var split_out = [[]];\n        var split_string = long_string.split(\" \");\n        for (var i=0; i<split_string.length; i++){\n            var word = split_string[i];\n            \n            if ((sum_length_of_words(split_out[split_out.length-1]) + word.length) > max_char){\n              split_out = split_out.concat([[]]);\n            }\n            \n            split_out[split_out.length-1] = split_out[split_out.length-1].concat(word);\n        }\n      \n        for (i=0; i<split_out.length; i++){\n            split_out[i] = split_out[i].join(\" \");\n        }\n        return split_out;\n    }\n}\n\n}\nmodule.exports = sadface;\n"]},"metadata":{},"sourceType":"module"}