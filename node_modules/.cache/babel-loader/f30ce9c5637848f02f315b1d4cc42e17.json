{"ast":null,"code":"(function webpackUniversalModuleDefinition(root, factory) {\n  if (typeof exports === 'object' && typeof module === 'object') module.exports = factory(require(\"dagre\"));else if (typeof define === 'function' && define.amd) define([\"dagre\"], factory);else if (typeof exports === 'object') exports[\"cytoscapeDagre\"] = factory(require(\"dagre\"));else root[\"cytoscapeDagre\"] = factory(root[\"dagre\"]);\n})(this, function (__WEBPACK_EXTERNAL_MODULE_4__) {\n  return (\n    /******/\n    function (modules) {\n      // webpackBootstrap\n\n      /******/\n      // The module cache\n\n      /******/\n      var installedModules = {};\n      /******/\n\n      /******/\n      // The require function\n\n      /******/\n\n      function __webpack_require__(moduleId) {\n        /******/\n\n        /******/\n        // Check if module is in cache\n\n        /******/\n        if (installedModules[moduleId]) {\n          /******/\n          return installedModules[moduleId].exports;\n          /******/\n        }\n        /******/\n        // Create a new module (and put it into the cache)\n\n        /******/\n\n\n        var module = installedModules[moduleId] = {\n          /******/\n          i: moduleId,\n\n          /******/\n          l: false,\n\n          /******/\n          exports: {}\n          /******/\n\n        };\n        /******/\n\n        /******/\n        // Execute the module function\n\n        /******/\n\n        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n        /******/\n\n        /******/\n        // Flag the module as loaded\n\n        /******/\n\n        module.l = true;\n        /******/\n\n        /******/\n        // Return the exports of the module\n\n        /******/\n\n        return module.exports;\n        /******/\n      }\n      /******/\n\n      /******/\n\n      /******/\n      // expose the modules object (__webpack_modules__)\n\n      /******/\n\n\n      __webpack_require__.m = modules;\n      /******/\n\n      /******/\n      // expose the module cache\n\n      /******/\n\n      __webpack_require__.c = installedModules;\n      /******/\n\n      /******/\n      // identity function for calling harmony imports with the correct context\n\n      /******/\n\n      __webpack_require__.i = function (value) {\n        return value;\n      };\n      /******/\n\n      /******/\n      // define getter function for harmony exports\n\n      /******/\n\n\n      __webpack_require__.d = function (exports, name, getter) {\n        /******/\n        if (!__webpack_require__.o(exports, name)) {\n          /******/\n          Object.defineProperty(exports, name, {\n            /******/\n            configurable: false,\n\n            /******/\n            enumerable: true,\n\n            /******/\n            get: getter\n            /******/\n\n          });\n          /******/\n        }\n        /******/\n\n      };\n      /******/\n\n      /******/\n      // getDefaultExport function for compatibility with non-harmony modules\n\n      /******/\n\n\n      __webpack_require__.n = function (module) {\n        /******/\n        var getter = module && module.__esModule ?\n        /******/\n        function getDefault() {\n          return module['default'];\n        } :\n        /******/\n        function getModuleExports() {\n          return module;\n        };\n        /******/\n\n        __webpack_require__.d(getter, 'a', getter);\n        /******/\n\n\n        return getter;\n        /******/\n      };\n      /******/\n\n      /******/\n      // Object.prototype.hasOwnProperty.call\n\n      /******/\n\n\n      __webpack_require__.o = function (object, property) {\n        return Object.prototype.hasOwnProperty.call(object, property);\n      };\n      /******/\n\n      /******/\n      // __webpack_public_path__\n\n      /******/\n\n\n      __webpack_require__.p = \"\";\n      /******/\n\n      /******/\n      // Load entry module and return exports\n\n      /******/\n\n      return __webpack_require__(__webpack_require__.s = 3);\n      /******/\n    }(\n    /************************************************************************/\n\n    /******/\n    [\n    /* 0 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n        return typeof obj;\n      } : function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n      };\n\n      var isFunction = function isFunction(o) {\n        return typeof o === 'function';\n      };\n\n      var defaults = __webpack_require__(2);\n\n      var assign = __webpack_require__(1);\n\n      var dagre = __webpack_require__(4); // constructor\n      // options : object containing layout options\n\n\n      function DagreLayout(options) {\n        this.options = assign({}, defaults, options);\n      } // runs the layout\n\n\n      DagreLayout.prototype.run = function () {\n        var options = this.options;\n        var layout = this;\n        var cy = options.cy; // cy is automatically populated for us in the constructor\n\n        var eles = options.eles;\n\n        var getVal = function getVal(ele, val) {\n          return isFunction(val) ? val.apply(ele, [ele]) : val;\n        };\n\n        var bb = options.boundingBox || {\n          x1: 0,\n          y1: 0,\n          w: cy.width(),\n          h: cy.height()\n        };\n\n        if (bb.x2 === undefined) {\n          bb.x2 = bb.x1 + bb.w;\n        }\n\n        if (bb.w === undefined) {\n          bb.w = bb.x2 - bb.x1;\n        }\n\n        if (bb.y2 === undefined) {\n          bb.y2 = bb.y1 + bb.h;\n        }\n\n        if (bb.h === undefined) {\n          bb.h = bb.y2 - bb.y1;\n        }\n\n        var g = new dagre.graphlib.Graph({\n          multigraph: true,\n          compound: true\n        });\n        var gObj = {};\n\n        var setGObj = function setGObj(name, val) {\n          if (val != null) {\n            gObj[name] = val;\n          }\n        };\n\n        setGObj('nodesep', options.nodeSep);\n        setGObj('edgesep', options.edgeSep);\n        setGObj('ranksep', options.rankSep);\n        setGObj('rankdir', options.rankDir);\n        setGObj('ranker', options.ranker);\n        g.setGraph(gObj);\n        g.setDefaultEdgeLabel(function () {\n          return {};\n        });\n        g.setDefaultNodeLabel(function () {\n          return {};\n        }); // add nodes to dagre\n\n        var nodes = eles.nodes();\n\n        for (var i = 0; i < nodes.length; i++) {\n          var node = nodes[i];\n          var nbb = node.layoutDimensions(options);\n          g.setNode(node.id(), {\n            width: nbb.w,\n            height: nbb.h,\n            name: node.id()\n          }); // console.log( g.node(node.id()) );\n        } // set compound parents\n\n\n        for (var _i = 0; _i < nodes.length; _i++) {\n          var _node = nodes[_i];\n\n          if (_node.isChild()) {\n            g.setParent(_node.id(), _node.parent().id());\n          }\n        } // add edges to dagre\n\n\n        var edges = eles.edges().stdFilter(function (edge) {\n          return !edge.source().isParent() && !edge.target().isParent(); // dagre can't handle edges on compound nodes\n        });\n\n        for (var _i2 = 0; _i2 < edges.length; _i2++) {\n          var edge = edges[_i2];\n          g.setEdge(edge.source().id(), edge.target().id(), {\n            minlen: getVal(edge, options.minLen),\n            weight: getVal(edge, options.edgeWeight),\n            name: edge.id()\n          }, edge.id()); // console.log( g.edge(edge.source().id(), edge.target().id(), edge.id()) );\n        }\n\n        dagre.layout(g);\n        var gNodeIds = g.nodes();\n\n        for (var _i3 = 0; _i3 < gNodeIds.length; _i3++) {\n          var id = gNodeIds[_i3];\n          var n = g.node(id);\n          cy.getElementById(id).scratch().dagre = n;\n        }\n\n        var dagreBB = void 0;\n\n        if (options.boundingBox) {\n          dagreBB = {\n            x1: Infinity,\n            x2: -Infinity,\n            y1: Infinity,\n            y2: -Infinity\n          };\n          nodes.forEach(function (node) {\n            var dModel = node.scratch().dagre;\n            dagreBB.x1 = Math.min(dagreBB.x1, dModel.x);\n            dagreBB.x2 = Math.max(dagreBB.x2, dModel.x);\n            dagreBB.y1 = Math.min(dagreBB.y1, dModel.y);\n            dagreBB.y2 = Math.max(dagreBB.y2, dModel.y);\n          });\n          dagreBB.w = dagreBB.x2 - dagreBB.x1;\n          dagreBB.h = dagreBB.y2 - dagreBB.y1;\n        } else {\n          dagreBB = bb;\n        }\n\n        var constrainPos = function constrainPos(p) {\n          if (options.boundingBox) {\n            var xPct = dagreBB.w === 0 ? 0 : (p.x - dagreBB.x1) / dagreBB.w;\n            var yPct = dagreBB.h === 0 ? 0 : (p.y - dagreBB.y1) / dagreBB.h;\n            return {\n              x: bb.x1 + xPct * bb.w,\n              y: bb.y1 + yPct * bb.h\n            };\n          } else {\n            return p;\n          }\n        };\n\n        nodes.layoutPositions(layout, options, function (ele) {\n          ele = (typeof ele === 'undefined' ? 'undefined' : _typeof(ele)) === \"object\" ? ele : this;\n          var dModel = ele.scratch().dagre;\n          return constrainPos({\n            x: dModel.x,\n            y: dModel.y\n          });\n        });\n        return this; // chaining\n      };\n\n      module.exports = DagreLayout;\n      /***/\n    },\n    /* 1 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\"; // Simple, internal Object.assign() polyfill for options objects etc.\n\n      module.exports = Object.assign != null ? Object.assign.bind(Object) : function (tgt) {\n        for (var _len = arguments.length, srcs = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          srcs[_key - 1] = arguments[_key];\n        }\n\n        srcs.forEach(function (src) {\n          Object.keys(src).forEach(function (k) {\n            return tgt[k] = src[k];\n          });\n        });\n        return tgt;\n      };\n      /***/\n    },\n    /* 2 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var defaults = {\n        // dagre algo options, uses default value on undefined\n        nodeSep: undefined,\n        // the separation between adjacent nodes in the same rank\n        edgeSep: undefined,\n        // the separation between adjacent edges in the same rank\n        rankSep: undefined,\n        // the separation between adjacent nodes in the same rank\n        rankDir: undefined,\n        // 'TB' for top to bottom flow, 'LR' for left to right,\n        ranker: undefined,\n        // Type of algorithm to assigns a rank to each node in the input graph.\n        // Possible values: network-simplex, tight-tree or longest-path\n        minLen: function minLen(edge) {\n          return 1;\n        },\n        // number of ranks to keep between the source and target of the edge\n        edgeWeight: function edgeWeight(edge) {\n          return 1;\n        },\n        // higher weight edges are generally made shorter and straighter than lower weight edges\n        // general layout options\n        fit: true,\n        // whether to fit to viewport\n        padding: 30,\n        // fit padding\n        spacingFactor: undefined,\n        // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up\n        nodeDimensionsIncludeLabels: false,\n        // whether labels should be included in determining the space used by a node\n        animate: false,\n        // whether to transition the node positions\n        animateFilter: function animateFilter(node, i) {\n          return true;\n        },\n        // whether to animate specific nodes when animation is on; non-animated nodes immediately go to their final positions\n        animationDuration: 500,\n        // duration of animation in ms if enabled\n        animationEasing: undefined,\n        // easing of animation if enabled\n        boundingBox: undefined,\n        // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n        transform: function transform(node, pos) {\n          return pos;\n        },\n        // a function that applies a transform to the final node position\n        ready: function ready() {},\n        // on layoutready\n        stop: function stop() {} // on layoutstop\n\n      };\n      module.exports = defaults;\n      /***/\n    },\n    /* 3 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var impl = __webpack_require__(0); // registers the extension on a cytoscape lib ref\n\n\n      var register = function register(cytoscape) {\n        if (!cytoscape) {\n          return;\n        } // can't register if cytoscape unspecified\n\n\n        cytoscape('layout', 'dagre', impl); // register with cytoscape.js\n      };\n\n      if (typeof cytoscape !== 'undefined') {\n        // expose to global cytoscape (i.e. window.cytoscape)\n        register(cytoscape);\n      }\n\n      module.exports = register;\n      /***/\n    },\n    /* 4 */\n\n    /***/\n    function (module, exports) {\n      module.exports = __WEBPACK_EXTERNAL_MODULE_4__;\n      /***/\n    }])\n  );\n});","map":null,"metadata":{},"sourceType":"script"}