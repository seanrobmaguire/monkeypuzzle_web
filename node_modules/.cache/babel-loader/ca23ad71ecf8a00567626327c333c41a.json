{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction unionCount(a, b) {\n  var u = {};\n\n  for (var i in a) u[i] = {};\n\n  for (var i in b) u[i] = {};\n\n  return Object.keys(u).length;\n}\n\nfunction intersectionCount(a, b) {\n  var n = 0;\n\n  for (var i in a) if (typeof b[i] !== 'undefined') ++n;\n\n  return n;\n}\n\nfunction getNeighbours(links, la) {\n  var neighbours = {};\n\n  var addNeighbours = function (u, v) {\n    if (typeof neighbours[u] === 'undefined') neighbours[u] = {};\n    neighbours[u][v] = {};\n  };\n\n  links.forEach(function (e) {\n    var u = la.getSourceIndex(e),\n        v = la.getTargetIndex(e);\n    addNeighbours(u, v);\n    addNeighbours(v, u);\n  });\n  return neighbours;\n}\n\nfunction computeLinkLengths(links, w, f, la) {\n  var neighbours = getNeighbours(links, la);\n  links.forEach(function (l) {\n    var a = neighbours[la.getSourceIndex(l)];\n    var b = neighbours[la.getTargetIndex(l)];\n    la.setLength(l, 1 + w * f(a, b));\n  });\n}\n\nfunction symmetricDiffLinkLengths(links, la, w) {\n  if (w === void 0) {\n    w = 1;\n  }\n\n  computeLinkLengths(links, w, function (a, b) {\n    return Math.sqrt(unionCount(a, b) - intersectionCount(a, b));\n  }, la);\n}\n\nexports.symmetricDiffLinkLengths = symmetricDiffLinkLengths;\n\nfunction jaccardLinkLengths(links, la, w) {\n  if (w === void 0) {\n    w = 1;\n  }\n\n  computeLinkLengths(links, w, function (a, b) {\n    return Math.min(Object.keys(a).length, Object.keys(b).length) < 1.1 ? 0 : intersectionCount(a, b) / unionCount(a, b);\n  }, la);\n}\n\nexports.jaccardLinkLengths = jaccardLinkLengths;\n\nfunction generateDirectedEdgeConstraints(n, links, axis, la) {\n  var components = stronglyConnectedComponents(n, links, la);\n  var nodes = {};\n  components.forEach(function (c, i) {\n    return c.forEach(function (v) {\n      return nodes[v] = i;\n    });\n  });\n  var constraints = [];\n  links.forEach(function (l) {\n    var ui = la.getSourceIndex(l),\n        vi = la.getTargetIndex(l),\n        u = nodes[ui],\n        v = nodes[vi];\n\n    if (u !== v) {\n      constraints.push({\n        axis: axis,\n        left: ui,\n        right: vi,\n        gap: la.getMinSeparation(l)\n      });\n    }\n  });\n  return constraints;\n}\n\nexports.generateDirectedEdgeConstraints = generateDirectedEdgeConstraints;\n\nfunction stronglyConnectedComponents(numVertices, edges, la) {\n  var nodes = [];\n  var index = 0;\n  var stack = [];\n  var components = [];\n\n  function strongConnect(v) {\n    v.index = v.lowlink = index++;\n    stack.push(v);\n    v.onStack = true;\n\n    for (var _i = 0, _a = v.out; _i < _a.length; _i++) {\n      var w = _a[_i];\n\n      if (typeof w.index === 'undefined') {\n        strongConnect(w);\n        v.lowlink = Math.min(v.lowlink, w.lowlink);\n      } else if (w.onStack) {\n        v.lowlink = Math.min(v.lowlink, w.index);\n      }\n    }\n\n    if (v.lowlink === v.index) {\n      var component = [];\n\n      while (stack.length) {\n        w = stack.pop();\n        w.onStack = false;\n        component.push(w);\n        if (w === v) break;\n      }\n\n      components.push(component.map(function (v) {\n        return v.id;\n      }));\n    }\n  }\n\n  for (var i = 0; i < numVertices; i++) {\n    nodes.push({\n      id: i,\n      out: []\n    });\n  }\n\n  for (var _i = 0, edges_1 = edges; _i < edges_1.length; _i++) {\n    var e = edges_1[_i];\n    var v_1 = nodes[la.getSourceIndex(e)],\n        w = nodes[la.getTargetIndex(e)];\n    v_1.out.push(w);\n  }\n\n  for (var _a = 0, nodes_1 = nodes; _a < nodes_1.length; _a++) {\n    var v = nodes_1[_a];\n    if (typeof v.index === 'undefined') strongConnect(v);\n  }\n\n  return components;\n}\n\nexports.stronglyConnectedComponents = stronglyConnectedComponents;","map":null,"metadata":{},"sourceType":"script"}