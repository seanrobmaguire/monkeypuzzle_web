{"ast":null,"code":"(function webpackUniversalModuleDefinition(root, factory) {\n  if (typeof exports === 'object' && typeof module === 'object') module.exports = factory(require(\"webcola\"));else if (typeof define === 'function' && define.amd) define([\"webcola\"], factory);else if (typeof exports === 'object') exports[\"cytoscapeCola\"] = factory(require(\"webcola\"));else root[\"cytoscapeCola\"] = factory(root[\"webcola\"]);\n})(this, function (__WEBPACK_EXTERNAL_MODULE_5__) {\n  return (\n    /******/\n    function (modules) {\n      // webpackBootstrap\n\n      /******/\n      // The module cache\n\n      /******/\n      var installedModules = {};\n      /******/\n\n      /******/\n      // The require function\n\n      /******/\n\n      function __webpack_require__(moduleId) {\n        /******/\n\n        /******/\n        // Check if module is in cache\n\n        /******/\n        if (installedModules[moduleId]) {\n          /******/\n          return installedModules[moduleId].exports;\n          /******/\n        }\n        /******/\n        // Create a new module (and put it into the cache)\n\n        /******/\n\n\n        var module = installedModules[moduleId] = {\n          /******/\n          i: moduleId,\n\n          /******/\n          l: false,\n\n          /******/\n          exports: {}\n          /******/\n\n        };\n        /******/\n\n        /******/\n        // Execute the module function\n\n        /******/\n\n        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n        /******/\n\n        /******/\n        // Flag the module as loaded\n\n        /******/\n\n        module.l = true;\n        /******/\n\n        /******/\n        // Return the exports of the module\n\n        /******/\n\n        return module.exports;\n        /******/\n      }\n      /******/\n\n      /******/\n\n      /******/\n      // expose the modules object (__webpack_modules__)\n\n      /******/\n\n\n      __webpack_require__.m = modules;\n      /******/\n\n      /******/\n      // expose the module cache\n\n      /******/\n\n      __webpack_require__.c = installedModules;\n      /******/\n\n      /******/\n      // identity function for calling harmony imports with the correct context\n\n      /******/\n\n      __webpack_require__.i = function (value) {\n        return value;\n      };\n      /******/\n\n      /******/\n      // define getter function for harmony exports\n\n      /******/\n\n\n      __webpack_require__.d = function (exports, name, getter) {\n        /******/\n        if (!__webpack_require__.o(exports, name)) {\n          /******/\n          Object.defineProperty(exports, name, {\n            /******/\n            configurable: false,\n\n            /******/\n            enumerable: true,\n\n            /******/\n            get: getter\n            /******/\n\n          });\n          /******/\n        }\n        /******/\n\n      };\n      /******/\n\n      /******/\n      // getDefaultExport function for compatibility with non-harmony modules\n\n      /******/\n\n\n      __webpack_require__.n = function (module) {\n        /******/\n        var getter = module && module.__esModule ?\n        /******/\n        function getDefault() {\n          return module['default'];\n        } :\n        /******/\n        function getModuleExports() {\n          return module;\n        };\n        /******/\n\n        __webpack_require__.d(getter, 'a', getter);\n        /******/\n\n\n        return getter;\n        /******/\n      };\n      /******/\n\n      /******/\n      // Object.prototype.hasOwnProperty.call\n\n      /******/\n\n\n      __webpack_require__.o = function (object, property) {\n        return Object.prototype.hasOwnProperty.call(object, property);\n      };\n      /******/\n\n      /******/\n      // __webpack_public_path__\n\n      /******/\n\n\n      __webpack_require__.p = \"\";\n      /******/\n\n      /******/\n      // Load entry module and return exports\n\n      /******/\n\n      return __webpack_require__(__webpack_require__.s = 3);\n      /******/\n    }(\n    /************************************************************************/\n\n    /******/\n    [\n    /* 0 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n        return typeof obj;\n      } : function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n      };\n\n      var assign = __webpack_require__(1);\n\n      var defaults = __webpack_require__(2);\n\n      var cola = __webpack_require__(5) || (typeof window !== 'undefined' ? window.cola : null);\n\n      var raf = __webpack_require__(4);\n\n      var isString = function isString(o) {\n        return (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === _typeof('');\n      };\n\n      var isNumber = function isNumber(o) {\n        return (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === _typeof(0);\n      };\n\n      var isObject = function isObject(o) {\n        return o != null && (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === _typeof({});\n      };\n\n      var isFunction = function isFunction(o) {\n        return o != null && (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === _typeof(function () {});\n      };\n\n      var nop = function nop() {};\n\n      var getOptVal = function getOptVal(val, ele) {\n        if (isFunction(val)) {\n          var fn = val;\n          return fn.apply(ele, [ele]);\n        } else {\n          return val;\n        }\n      }; // constructor\n      // options : object containing layout options\n\n\n      function ColaLayout(options) {\n        this.options = assign({}, defaults, options);\n      } // runs the layout\n\n\n      ColaLayout.prototype.run = function () {\n        var layout = this;\n        var options = this.options;\n        layout.manuallyStopped = false;\n        var cy = options.cy; // cy is automatically populated for us in the constructor\n\n        var eles = options.eles;\n        var nodes = eles.nodes();\n        var edges = eles.edges();\n        var ready = false;\n\n        var isParent = function isParent(ele) {\n          return ele.isParent();\n        };\n\n        var parentNodes = nodes.filter(isParent);\n        var nonparentNodes = nodes.subtract(parentNodes);\n        var bb = options.boundingBox || {\n          x1: 0,\n          y1: 0,\n          w: cy.width(),\n          h: cy.height()\n        };\n\n        if (bb.x2 === undefined) {\n          bb.x2 = bb.x1 + bb.w;\n        }\n\n        if (bb.w === undefined) {\n          bb.w = bb.x2 - bb.x1;\n        }\n\n        if (bb.y2 === undefined) {\n          bb.y2 = bb.y1 + bb.h;\n        }\n\n        if (bb.h === undefined) {\n          bb.h = bb.y2 - bb.y1;\n        }\n\n        var updateNodePositions = function updateNodePositions() {\n          for (var i = 0; i < nodes.length; i++) {\n            var node = nodes[i];\n            var dimensions = node.layoutDimensions(options);\n            var scratch = node.scratch('cola'); // update node dims\n\n            if (!scratch.updatedDims) {\n              var padding = getOptVal(options.nodeSpacing, node);\n              scratch.width = dimensions.w + 2 * padding;\n              scratch.height = dimensions.h + 2 * padding;\n            }\n          }\n\n          nodes.positions(function (node) {\n            var scratch = node.scratch().cola;\n            var retPos = void 0;\n\n            if (!node.grabbed() && nonparentNodes.contains(node)) {\n              retPos = {\n                x: bb.x1 + scratch.x,\n                y: bb.y1 + scratch.y\n              };\n\n              if (!isNumber(retPos.x) || !isNumber(retPos.y)) {\n                retPos = undefined;\n              }\n            }\n\n            return retPos;\n          });\n          nodes.updateCompoundBounds(); // because the way this layout sets positions is buggy for some reason; ref #878\n\n          if (!ready) {\n            onReady();\n            ready = true;\n          }\n\n          if (options.fit) {\n            cy.fit(options.padding);\n          }\n        };\n\n        var onDone = function onDone() {\n          if (options.ungrabifyWhileSimulating) {\n            grabbableNodes.grabify();\n          }\n\n          cy.off('destroy', destroyHandler);\n          nodes.off('grab free position', grabHandler);\n          nodes.off('lock unlock', lockHandler); // trigger layoutstop when the layout stops (e.g. finishes)\n\n          layout.one('layoutstop', options.stop);\n          layout.trigger({\n            type: 'layoutstop',\n            layout: layout\n          });\n        };\n\n        var onReady = function onReady() {\n          // trigger layoutready when each node has had its position set at least once\n          layout.one('layoutready', options.ready);\n          layout.trigger({\n            type: 'layoutready',\n            layout: layout\n          });\n        };\n\n        var ticksPerFrame = options.refresh;\n\n        if (options.refresh < 0) {\n          ticksPerFrame = 1;\n        } else {\n          ticksPerFrame = Math.max(1, ticksPerFrame); // at least 1\n        }\n\n        var adaptor = layout.adaptor = cola.adaptor({\n          trigger: function trigger(e) {\n            // on sim event\n            var TICK = cola.EventType ? cola.EventType.tick : null;\n            var END = cola.EventType ? cola.EventType.end : null;\n\n            switch (e.type) {\n              case 'tick':\n              case TICK:\n                if (options.animate) {\n                  updateNodePositions();\n                }\n\n                break;\n\n              case 'end':\n              case END:\n                updateNodePositions();\n\n                if (!options.infinite) {\n                  onDone();\n                }\n\n                break;\n            }\n          },\n          kick: function kick() {\n            // kick off the simulation\n            //let skip = 0;\n            var firstTick = true;\n\n            var inftick = function inftick() {\n              if (layout.manuallyStopped) {\n                onDone();\n                return true;\n              }\n\n              var ret = adaptor.tick();\n\n              if (!options.infinite && !firstTick) {\n                adaptor.convergenceThreshold(options.convergenceThreshold);\n              }\n\n              firstTick = false;\n\n              if (ret && options.infinite) {\n                // resume layout if done\n                adaptor.resume(); // resume => new kick\n              }\n\n              return ret; // allow regular finish b/c of new kick\n            };\n\n            var multitick = function multitick() {\n              // multiple ticks in a row\n              var ret = void 0;\n\n              for (var i = 0; i < ticksPerFrame && !ret; i++) {\n                ret = ret || inftick(); // pick up true ret vals => sim done\n              }\n\n              return ret;\n            };\n\n            if (options.animate) {\n              var frame = function frame() {\n                if (multitick()) {\n                  return;\n                }\n\n                raf(frame);\n              };\n\n              raf(frame);\n            } else {\n              while (!inftick()) {// keep going...\n              }\n            }\n          },\n          on: nop,\n          // dummy; not needed\n          drag: nop // not needed for our case\n\n        });\n        layout.adaptor = adaptor; // if set no grabbing during layout\n\n        var grabbableNodes = nodes.filter(':grabbable');\n\n        if (options.ungrabifyWhileSimulating) {\n          grabbableNodes.ungrabify();\n        }\n\n        var destroyHandler = void 0;\n        cy.one('destroy', destroyHandler = function destroyHandler() {\n          layout.stop();\n        }); // handle node dragging\n\n        var grabHandler = void 0;\n        nodes.on('grab free position', grabHandler = function grabHandler(e) {\n          var node = this;\n          var scrCola = node.scratch().cola;\n          var pos = node.position();\n          var nodeIsTarget = e.cyTarget === node || e.target === node;\n\n          if (!nodeIsTarget) {\n            return;\n          }\n\n          switch (e.type) {\n            case 'grab':\n              adaptor.dragstart(scrCola);\n              break;\n\n            case 'free':\n              adaptor.dragend(scrCola);\n              break;\n\n            case 'position':\n              // only update when different (i.e. manual .position() call or drag) so we don't loop needlessly\n              if (scrCola.px !== pos.x - bb.x1 || scrCola.py !== pos.y - bb.y1) {\n                scrCola.px = pos.x - bb.x1;\n                scrCola.py = pos.y - bb.y1;\n              }\n\n              break;\n          }\n        });\n        var lockHandler = void 0;\n        nodes.on('lock unlock', lockHandler = function lockHandler() {\n          var node = this;\n          var scrCola = node.scratch().cola;\n          scrCola.fixed = node.locked();\n\n          if (node.locked()) {\n            adaptor.dragstart(scrCola);\n          } else {\n            adaptor.dragend(scrCola);\n          }\n        }); // add nodes to cola\n\n        adaptor.nodes(nonparentNodes.map(function (node, i) {\n          var padding = getOptVal(options.nodeSpacing, node);\n          var pos = node.position();\n          var dimensions = node.layoutDimensions(options);\n          var struct = node.scratch().cola = {\n            x: options.randomize || pos.x === undefined ? Math.round(Math.random() * bb.w) : pos.x,\n            y: options.randomize || pos.y === undefined ? Math.round(Math.random() * bb.h) : pos.y,\n            width: dimensions.w + 2 * padding,\n            height: dimensions.h + 2 * padding,\n            index: i,\n            fixed: node.locked()\n          };\n          return struct;\n        })); // the constraints to be added on nodes\n\n        var constraints = [];\n\n        if (options.alignment) {\n          // then set alignment constraints\n          var offsetsX = [];\n          var offsetsY = [];\n          nonparentNodes.forEach(function (node) {\n            var align = getOptVal(options.alignment, node);\n            var scrCola = node.scratch().cola;\n            var index = scrCola.index;\n\n            if (!align) {\n              return;\n            }\n\n            if (align.x != null) {\n              offsetsX.push({\n                node: index,\n                offset: align.x\n              });\n            }\n\n            if (align.y != null) {\n              offsetsY.push({\n                node: index,\n                offset: align.y\n              });\n            }\n          });\n\n          if (offsetsX.length > 0) {\n            constraints.push({\n              type: 'alignment',\n              axis: 'x',\n              offsets: offsetsX\n            });\n          }\n\n          if (offsetsY.length > 0) {\n            constraints.push({\n              type: 'alignment',\n              axis: 'y',\n              offsets: offsetsY\n            });\n          }\n        } // if gapInequalities variable is set add each inequality constraint to list of constraints\n\n\n        if (options.gapInequalities) {\n          options.gapInequalities.forEach(function (inequality) {\n            // for the constraints to be passed to cola layout adaptor use indices of nodes,\n            // not the nodes themselves\n            var leftIndex = inequality.left.scratch().cola.index;\n            var rightIndex = inequality.right.scratch().cola.index;\n            constraints.push({\n              axis: inequality.axis,\n              left: leftIndex,\n              right: rightIndex,\n              gap: inequality.gap,\n              equality: inequality.equality\n            });\n          });\n        } // add constraints if any\n\n\n        if (constraints.length > 0) {\n          adaptor.constraints(constraints);\n        } // add compound nodes to cola\n\n\n        adaptor.groups(parentNodes.map(function (node, i) {\n          // add basic group incl leaf nodes\n          var optPadding = getOptVal(options.nodeSpacing, node);\n\n          var getPadding = function getPadding(d) {\n            return parseFloat(node.style('padding-' + d));\n          };\n\n          var pleft = getPadding('left') + optPadding;\n          var pright = getPadding('right') + optPadding;\n          var ptop = getPadding('top') + optPadding;\n          var pbottom = getPadding('bottom') + optPadding;\n          node.scratch().cola = {\n            index: i,\n            padding: Math.max(pleft, pright, ptop, pbottom),\n            // leaves should only contain direct descendants (children),\n            // not the leaves of nested compound nodes or any nodes that are compounds themselves\n            leaves: node.children().intersection(nonparentNodes).map(function (child) {\n              return child[0].scratch().cola.index;\n            }),\n            fixed: node.locked()\n          };\n          return node;\n        }).map(function (node) {\n          // add subgroups\n          node.scratch().cola.groups = node.children().intersection(parentNodes).map(function (child) {\n            return child.scratch().cola.index;\n          });\n          return node.scratch().cola;\n        })); // get the edge length setting mechanism\n\n        var length = void 0;\n        var lengthFnName = void 0;\n\n        if (options.edgeLength != null) {\n          length = options.edgeLength;\n          lengthFnName = 'linkDistance';\n        } else if (options.edgeSymDiffLength != null) {\n          length = options.edgeSymDiffLength;\n          lengthFnName = 'symmetricDiffLinkLengths';\n        } else if (options.edgeJaccardLength != null) {\n          length = options.edgeJaccardLength;\n          lengthFnName = 'jaccardLinkLengths';\n        } else {\n          length = 100;\n          lengthFnName = 'linkDistance';\n        }\n\n        var lengthGetter = function lengthGetter(link) {\n          return link.calcLength;\n        }; // add the edges to cola\n\n\n        adaptor.links(edges.stdFilter(function (edge) {\n          return nonparentNodes.contains(edge.source()) && nonparentNodes.contains(edge.target());\n        }).map(function (edge) {\n          var c = edge.scratch().cola = {\n            source: edge.source()[0].scratch().cola.index,\n            target: edge.target()[0].scratch().cola.index\n          };\n\n          if (length != null) {\n            c.calcLength = getOptVal(length, edge);\n          }\n\n          return c;\n        }));\n        adaptor.size([bb.w, bb.h]);\n\n        if (length != null) {\n          adaptor[lengthFnName](lengthGetter);\n        } // set the flow of cola\n\n\n        if (options.flow) {\n          var flow = void 0;\n          var defAxis = 'y';\n          var defMinSep = 50;\n\n          if (isString(options.flow)) {\n            flow = {\n              axis: options.flow,\n              minSeparation: defMinSep\n            };\n          } else if (isNumber(options.flow)) {\n            flow = {\n              axis: defAxis,\n              minSeparation: options.flow\n            };\n          } else if (isObject(options.flow)) {\n            flow = options.flow;\n            flow.axis = flow.axis || defAxis;\n            flow.minSeparation = flow.minSeparation != null ? flow.minSeparation : defMinSep;\n          } else {\n            // e.g. options.flow: true\n            flow = {\n              axis: defAxis,\n              minSeparation: defMinSep\n            };\n          }\n\n          adaptor.flowLayout(flow.axis, flow.minSeparation);\n        }\n\n        layout.trigger({\n          type: 'layoutstart',\n          layout: layout\n        });\n        adaptor.avoidOverlaps(options.avoidOverlap).handleDisconnected(options.handleDisconnected).start(options.unconstrIter, options.userConstIter, options.allConstIter);\n\n        if (!options.infinite) {\n          setTimeout(function () {\n            if (!layout.manuallyStopped) {\n              adaptor.stop();\n            }\n          }, options.maxSimulationTime);\n        }\n\n        return this; // chaining\n      }; // called on continuous layouts to stop them before they finish\n\n\n      ColaLayout.prototype.stop = function () {\n        if (this.adaptor) {\n          this.manuallyStopped = true;\n          this.adaptor.stop();\n        }\n\n        return this; // chaining\n      };\n\n      module.exports = ColaLayout;\n      /***/\n    },\n    /* 1 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\"; // Simple, internal Object.assign() polyfill for options objects etc.\n\n      module.exports = Object.assign != null ? Object.assign.bind(Object) : function (tgt) {\n        for (var _len = arguments.length, srcs = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          srcs[_key - 1] = arguments[_key];\n        }\n\n        srcs.filter(function (src) {\n          return src != null;\n        }).forEach(function (src) {\n          Object.keys(src).forEach(function (k) {\n            return tgt[k] = src[k];\n          });\n        });\n        return tgt;\n      };\n      /***/\n    },\n    /* 2 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\"; // default layout options\n\n      var defaults = {\n        animate: true,\n        // whether to show the layout as it's running\n        refresh: 1,\n        // number of ticks per frame; higher is faster but more jerky\n        maxSimulationTime: 4000,\n        // max length in ms to run the layout\n        ungrabifyWhileSimulating: false,\n        // so you can't drag nodes during layout\n        fit: true,\n        // on every layout reposition of nodes, fit the viewport\n        padding: 30,\n        // padding around the simulation\n        boundingBox: undefined,\n        // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n        nodeDimensionsIncludeLabels: false,\n        // whether labels should be included in determining the space used by a node\n        // layout event callbacks\n        ready: function ready() {},\n        // on layoutready\n        stop: function stop() {},\n        // on layoutstop\n        // positioning options\n        randomize: false,\n        // use random node positions at beginning of layout\n        avoidOverlap: true,\n        // if true, prevents overlap of node bounding boxes\n        handleDisconnected: true,\n        // if true, avoids disconnected components from overlapping\n        convergenceThreshold: 0.01,\n        // when the alpha value (system energy) falls below this value, the layout stops\n        nodeSpacing: function nodeSpacing(node) {\n          return 10;\n        },\n        // extra spacing around nodes\n        flow: undefined,\n        // use DAG/tree flow layout if specified, e.g. { axis: 'y', minSeparation: 30 }\n        alignment: undefined,\n        // relative alignment constraints on nodes, e.g. function( node ){ return { x: 0, y: 1 } }\n        gapInequalities: undefined,\n        // list of inequality constraints for the gap between the nodes, e.g. [{\"axis\":\"y\", \"left\":node1, \"right\":node2, \"gap\":25}]\n        // different methods of specifying edge length\n        // each can be a constant numerical value or a function like `function( edge ){ return 2; }`\n        edgeLength: undefined,\n        // sets edge length directly in simulation\n        edgeSymDiffLength: undefined,\n        // symmetric diff edge length in simulation\n        edgeJaccardLength: undefined,\n        // jaccard edge length in simulation\n        // iterations of cola algorithm; uses default values on undefined\n        unconstrIter: undefined,\n        // unconstrained initial layout iterations\n        userConstIter: undefined,\n        // initial layout iterations with user-specified constraints\n        allConstIter: undefined,\n        // initial layout iterations with all constraints including non-overlap\n        // infinite layout options\n        infinite: false // overrides all other options for a forces-all-the-time mode\n\n      };\n      module.exports = defaults;\n      /***/\n    },\n    /* 3 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var impl = __webpack_require__(0); // registers the extension on a cytoscape lib ref\n\n\n      var register = function register(cytoscape) {\n        if (!cytoscape) {\n          return;\n        } // can't register if cytoscape unspecified\n\n\n        cytoscape('layout', 'cola', impl); // register with cytoscape.js\n      };\n\n      if (typeof cytoscape !== 'undefined') {\n        // expose to global cytoscape (i.e. window.cytoscape)\n        register(cytoscape);\n      }\n\n      module.exports = register;\n      /***/\n    },\n    /* 4 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n        return typeof obj;\n      } : function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n      };\n\n      var raf = void 0;\n\n      if ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) !== (true ? \"undefined\" : _typeof(undefined))) {\n        raf = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || function (fn) {\n          return setTimeout(fn, 16);\n        };\n      } else {\n        // if not available, all you get is immediate calls\n        raf = function raf(cb) {\n          cb();\n        };\n      }\n\n      module.exports = raf;\n      /***/\n    },\n    /* 5 */\n\n    /***/\n    function (module, exports) {\n      module.exports = __WEBPACK_EXTERNAL_MODULE_5__;\n      /***/\n    }])\n  );\n});","map":null,"metadata":{},"sourceType":"script"}