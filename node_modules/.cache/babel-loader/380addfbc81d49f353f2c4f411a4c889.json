{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar vpsc_1 = require(\"./vpsc\");\n\nvar rbtree_1 = require(\"./rbtree\");\n\nfunction computeGroupBounds(g) {\n  g.bounds = typeof g.leaves !== \"undefined\" ? g.leaves.reduce(function (r, c) {\n    return c.bounds.union(r);\n  }, Rectangle.empty()) : Rectangle.empty();\n  if (typeof g.groups !== \"undefined\") g.bounds = g.groups.reduce(function (r, c) {\n    return computeGroupBounds(c).union(r);\n  }, g.bounds);\n  g.bounds = g.bounds.inflate(g.padding);\n  return g.bounds;\n}\n\nexports.computeGroupBounds = computeGroupBounds;\n\nvar Rectangle = function () {\n  function Rectangle(x, X, y, Y) {\n    this.x = x;\n    this.X = X;\n    this.y = y;\n    this.Y = Y;\n  }\n\n  Rectangle.empty = function () {\n    return new Rectangle(Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY);\n  };\n\n  Rectangle.prototype.cx = function () {\n    return (this.x + this.X) / 2;\n  };\n\n  Rectangle.prototype.cy = function () {\n    return (this.y + this.Y) / 2;\n  };\n\n  Rectangle.prototype.overlapX = function (r) {\n    var ux = this.cx(),\n        vx = r.cx();\n    if (ux <= vx && r.x < this.X) return this.X - r.x;\n    if (vx <= ux && this.x < r.X) return r.X - this.x;\n    return 0;\n  };\n\n  Rectangle.prototype.overlapY = function (r) {\n    var uy = this.cy(),\n        vy = r.cy();\n    if (uy <= vy && r.y < this.Y) return this.Y - r.y;\n    if (vy <= uy && this.y < r.Y) return r.Y - this.y;\n    return 0;\n  };\n\n  Rectangle.prototype.setXCentre = function (cx) {\n    var dx = cx - this.cx();\n    this.x += dx;\n    this.X += dx;\n  };\n\n  Rectangle.prototype.setYCentre = function (cy) {\n    var dy = cy - this.cy();\n    this.y += dy;\n    this.Y += dy;\n  };\n\n  Rectangle.prototype.width = function () {\n    return this.X - this.x;\n  };\n\n  Rectangle.prototype.height = function () {\n    return this.Y - this.y;\n  };\n\n  Rectangle.prototype.union = function (r) {\n    return new Rectangle(Math.min(this.x, r.x), Math.max(this.X, r.X), Math.min(this.y, r.y), Math.max(this.Y, r.Y));\n  };\n\n  Rectangle.prototype.lineIntersections = function (x1, y1, x2, y2) {\n    var sides = [[this.x, this.y, this.X, this.y], [this.X, this.y, this.X, this.Y], [this.X, this.Y, this.x, this.Y], [this.x, this.Y, this.x, this.y]];\n    var intersections = [];\n\n    for (var i = 0; i < 4; ++i) {\n      var r = Rectangle.lineIntersection(x1, y1, x2, y2, sides[i][0], sides[i][1], sides[i][2], sides[i][3]);\n      if (r !== null) intersections.push({\n        x: r.x,\n        y: r.y\n      });\n    }\n\n    return intersections;\n  };\n\n  Rectangle.prototype.rayIntersection = function (x2, y2) {\n    var ints = this.lineIntersections(this.cx(), this.cy(), x2, y2);\n    return ints.length > 0 ? ints[0] : null;\n  };\n\n  Rectangle.prototype.vertices = function () {\n    return [{\n      x: this.x,\n      y: this.y\n    }, {\n      x: this.X,\n      y: this.y\n    }, {\n      x: this.X,\n      y: this.Y\n    }, {\n      x: this.x,\n      y: this.Y\n    }];\n  };\n\n  Rectangle.lineIntersection = function (x1, y1, x2, y2, x3, y3, x4, y4) {\n    var dx12 = x2 - x1,\n        dx34 = x4 - x3,\n        dy12 = y2 - y1,\n        dy34 = y4 - y3,\n        denominator = dy34 * dx12 - dx34 * dy12;\n    if (denominator == 0) return null;\n    var dx31 = x1 - x3,\n        dy31 = y1 - y3,\n        numa = dx34 * dy31 - dy34 * dx31,\n        a = numa / denominator,\n        numb = dx12 * dy31 - dy12 * dx31,\n        b = numb / denominator;\n\n    if (a >= 0 && a <= 1 && b >= 0 && b <= 1) {\n      return {\n        x: x1 + a * dx12,\n        y: y1 + a * dy12\n      };\n    }\n\n    return null;\n  };\n\n  Rectangle.prototype.inflate = function (pad) {\n    return new Rectangle(this.x - pad, this.X + pad, this.y - pad, this.Y + pad);\n  };\n\n  return Rectangle;\n}();\n\nexports.Rectangle = Rectangle;\n\nfunction makeEdgeBetween(source, target, ah) {\n  var si = source.rayIntersection(target.cx(), target.cy()) || {\n    x: source.cx(),\n    y: source.cy()\n  },\n      ti = target.rayIntersection(source.cx(), source.cy()) || {\n    x: target.cx(),\n    y: target.cy()\n  },\n      dx = ti.x - si.x,\n      dy = ti.y - si.y,\n      l = Math.sqrt(dx * dx + dy * dy),\n      al = l - ah;\n  return {\n    sourceIntersection: si,\n    targetIntersection: ti,\n    arrowStart: {\n      x: si.x + al * dx / l,\n      y: si.y + al * dy / l\n    }\n  };\n}\n\nexports.makeEdgeBetween = makeEdgeBetween;\n\nfunction makeEdgeTo(s, target, ah) {\n  var ti = target.rayIntersection(s.x, s.y);\n  if (!ti) ti = {\n    x: target.cx(),\n    y: target.cy()\n  };\n  var dx = ti.x - s.x,\n      dy = ti.y - s.y,\n      l = Math.sqrt(dx * dx + dy * dy);\n  return {\n    x: ti.x - ah * dx / l,\n    y: ti.y - ah * dy / l\n  };\n}\n\nexports.makeEdgeTo = makeEdgeTo;\n\nvar Node = function () {\n  function Node(v, r, pos) {\n    this.v = v;\n    this.r = r;\n    this.pos = pos;\n    this.prev = makeRBTree();\n    this.next = makeRBTree();\n  }\n\n  return Node;\n}();\n\nvar Event = function () {\n  function Event(isOpen, v, pos) {\n    this.isOpen = isOpen;\n    this.v = v;\n    this.pos = pos;\n  }\n\n  return Event;\n}();\n\nfunction compareEvents(a, b) {\n  if (a.pos > b.pos) {\n    return 1;\n  }\n\n  if (a.pos < b.pos) {\n    return -1;\n  }\n\n  if (a.isOpen) {\n    return -1;\n  }\n\n  if (b.isOpen) {\n    return 1;\n  }\n\n  return 0;\n}\n\nfunction makeRBTree() {\n  return new rbtree_1.RBTree(function (a, b) {\n    return a.pos - b.pos;\n  });\n}\n\nvar xRect = {\n  getCentre: function (r) {\n    return r.cx();\n  },\n  getOpen: function (r) {\n    return r.y;\n  },\n  getClose: function (r) {\n    return r.Y;\n  },\n  getSize: function (r) {\n    return r.width();\n  },\n  makeRect: function (open, close, center, size) {\n    return new Rectangle(center - size / 2, center + size / 2, open, close);\n  },\n  findNeighbours: findXNeighbours\n};\nvar yRect = {\n  getCentre: function (r) {\n    return r.cy();\n  },\n  getOpen: function (r) {\n    return r.x;\n  },\n  getClose: function (r) {\n    return r.X;\n  },\n  getSize: function (r) {\n    return r.height();\n  },\n  makeRect: function (open, close, center, size) {\n    return new Rectangle(open, close, center - size / 2, center + size / 2);\n  },\n  findNeighbours: findYNeighbours\n};\n\nfunction generateGroupConstraints(root, f, minSep, isContained) {\n  if (isContained === void 0) {\n    isContained = false;\n  }\n\n  var padding = root.padding,\n      gn = typeof root.groups !== 'undefined' ? root.groups.length : 0,\n      ln = typeof root.leaves !== 'undefined' ? root.leaves.length : 0,\n      childConstraints = !gn ? [] : root.groups.reduce(function (ccs, g) {\n    return ccs.concat(generateGroupConstraints(g, f, minSep, true));\n  }, []),\n      n = (isContained ? 2 : 0) + ln + gn,\n      vs = new Array(n),\n      rs = new Array(n),\n      i = 0,\n      add = function (r, v) {\n    rs[i] = r;\n    vs[i++] = v;\n  };\n\n  if (isContained) {\n    var b = root.bounds,\n        c = f.getCentre(b),\n        s = f.getSize(b) / 2,\n        open = f.getOpen(b),\n        close = f.getClose(b),\n        min = c - s + padding / 2,\n        max = c + s - padding / 2;\n    root.minVar.desiredPosition = min;\n    add(f.makeRect(open, close, min, padding), root.minVar);\n    root.maxVar.desiredPosition = max;\n    add(f.makeRect(open, close, max, padding), root.maxVar);\n  }\n\n  if (ln) root.leaves.forEach(function (l) {\n    return add(l.bounds, l.variable);\n  });\n  if (gn) root.groups.forEach(function (g) {\n    var b = g.bounds;\n    add(f.makeRect(f.getOpen(b), f.getClose(b), f.getCentre(b), f.getSize(b)), g.minVar);\n  });\n  var cs = generateConstraints(rs, vs, f, minSep);\n\n  if (gn) {\n    vs.forEach(function (v) {\n      v.cOut = [], v.cIn = [];\n    });\n    cs.forEach(function (c) {\n      c.left.cOut.push(c), c.right.cIn.push(c);\n    });\n    root.groups.forEach(function (g) {\n      var gapAdjustment = (g.padding - f.getSize(g.bounds)) / 2;\n      g.minVar.cIn.forEach(function (c) {\n        return c.gap += gapAdjustment;\n      });\n      g.minVar.cOut.forEach(function (c) {\n        c.left = g.maxVar;\n        c.gap += gapAdjustment;\n      });\n    });\n  }\n\n  return childConstraints.concat(cs);\n}\n\nfunction generateConstraints(rs, vars, rect, minSep) {\n  var i,\n      n = rs.length;\n  var N = 2 * n;\n  console.assert(vars.length >= n);\n  var events = new Array(N);\n\n  for (i = 0; i < n; ++i) {\n    var r = rs[i];\n    var v = new Node(vars[i], r, rect.getCentre(r));\n    events[i] = new Event(true, v, rect.getOpen(r));\n    events[i + n] = new Event(false, v, rect.getClose(r));\n  }\n\n  events.sort(compareEvents);\n  var cs = new Array();\n  var scanline = makeRBTree();\n\n  for (i = 0; i < N; ++i) {\n    var e = events[i];\n    var v = e.v;\n\n    if (e.isOpen) {\n      scanline.insert(v);\n      rect.findNeighbours(v, scanline);\n    } else {\n      scanline.remove(v);\n\n      var makeConstraint = function (l, r) {\n        var sep = (rect.getSize(l.r) + rect.getSize(r.r)) / 2 + minSep;\n        cs.push(new vpsc_1.Constraint(l.v, r.v, sep));\n      };\n\n      var visitNeighbours = function (forward, reverse, mkcon) {\n        var u,\n            it = v[forward].iterator();\n\n        while ((u = it[forward]()) !== null) {\n          mkcon(u, v);\n          u[reverse].remove(v);\n        }\n      };\n\n      visitNeighbours(\"prev\", \"next\", function (u, v) {\n        return makeConstraint(u, v);\n      });\n      visitNeighbours(\"next\", \"prev\", function (u, v) {\n        return makeConstraint(v, u);\n      });\n    }\n  }\n\n  console.assert(scanline.size === 0);\n  return cs;\n}\n\nfunction findXNeighbours(v, scanline) {\n  var f = function (forward, reverse) {\n    var it = scanline.findIter(v);\n    var u;\n\n    while ((u = it[forward]()) !== null) {\n      var uovervX = u.r.overlapX(v.r);\n\n      if (uovervX <= 0 || uovervX <= u.r.overlapY(v.r)) {\n        v[forward].insert(u);\n        u[reverse].insert(v);\n      }\n\n      if (uovervX <= 0) {\n        break;\n      }\n    }\n  };\n\n  f(\"next\", \"prev\");\n  f(\"prev\", \"next\");\n}\n\nfunction findYNeighbours(v, scanline) {\n  var f = function (forward, reverse) {\n    var u = scanline.findIter(v)[forward]();\n\n    if (u !== null && u.r.overlapX(v.r) > 0) {\n      v[forward].insert(u);\n      u[reverse].insert(v);\n    }\n  };\n\n  f(\"next\", \"prev\");\n  f(\"prev\", \"next\");\n}\n\nfunction generateXConstraints(rs, vars) {\n  return generateConstraints(rs, vars, xRect, 1e-6);\n}\n\nexports.generateXConstraints = generateXConstraints;\n\nfunction generateYConstraints(rs, vars) {\n  return generateConstraints(rs, vars, yRect, 1e-6);\n}\n\nexports.generateYConstraints = generateYConstraints;\n\nfunction generateXGroupConstraints(root) {\n  return generateGroupConstraints(root, xRect, 1e-6);\n}\n\nexports.generateXGroupConstraints = generateXGroupConstraints;\n\nfunction generateYGroupConstraints(root) {\n  return generateGroupConstraints(root, yRect, 1e-6);\n}\n\nexports.generateYGroupConstraints = generateYGroupConstraints;\n\nfunction removeOverlaps(rs) {\n  var vs = rs.map(function (r) {\n    return new vpsc_1.Variable(r.cx());\n  });\n  var cs = generateXConstraints(rs, vs);\n  var solver = new vpsc_1.Solver(vs, cs);\n  solver.solve();\n  vs.forEach(function (v, i) {\n    return rs[i].setXCentre(v.position());\n  });\n  vs = rs.map(function (r) {\n    return new vpsc_1.Variable(r.cy());\n  });\n  cs = generateYConstraints(rs, vs);\n  solver = new vpsc_1.Solver(vs, cs);\n  solver.solve();\n  vs.forEach(function (v, i) {\n    return rs[i].setYCentre(v.position());\n  });\n}\n\nexports.removeOverlaps = removeOverlaps;\n\nvar IndexedVariable = function (_super) {\n  __extends(IndexedVariable, _super);\n\n  function IndexedVariable(index, w) {\n    var _this = _super.call(this, 0, w) || this;\n\n    _this.index = index;\n    return _this;\n  }\n\n  return IndexedVariable;\n}(vpsc_1.Variable);\n\nexports.IndexedVariable = IndexedVariable;\n\nvar Projection = function () {\n  function Projection(nodes, groups, rootGroup, constraints, avoidOverlaps) {\n    var _this = this;\n\n    if (rootGroup === void 0) {\n      rootGroup = null;\n    }\n\n    if (constraints === void 0) {\n      constraints = null;\n    }\n\n    if (avoidOverlaps === void 0) {\n      avoidOverlaps = false;\n    }\n\n    this.nodes = nodes;\n    this.groups = groups;\n    this.rootGroup = rootGroup;\n    this.avoidOverlaps = avoidOverlaps;\n    this.variables = nodes.map(function (v, i) {\n      return v.variable = new IndexedVariable(i, 1);\n    });\n    if (constraints) this.createConstraints(constraints);\n\n    if (avoidOverlaps && rootGroup && typeof rootGroup.groups !== 'undefined') {\n      nodes.forEach(function (v) {\n        if (!v.width || !v.height) {\n          v.bounds = new Rectangle(v.x, v.x, v.y, v.y);\n          return;\n        }\n\n        var w2 = v.width / 2,\n            h2 = v.height / 2;\n        v.bounds = new Rectangle(v.x - w2, v.x + w2, v.y - h2, v.y + h2);\n      });\n      computeGroupBounds(rootGroup);\n      var i = nodes.length;\n      groups.forEach(function (g) {\n        _this.variables[i] = g.minVar = new IndexedVariable(i++, typeof g.stiffness !== \"undefined\" ? g.stiffness : 0.01);\n        _this.variables[i] = g.maxVar = new IndexedVariable(i++, typeof g.stiffness !== \"undefined\" ? g.stiffness : 0.01);\n      });\n    }\n  }\n\n  Projection.prototype.createSeparation = function (c) {\n    return new vpsc_1.Constraint(this.nodes[c.left].variable, this.nodes[c.right].variable, c.gap, typeof c.equality !== \"undefined\" ? c.equality : false);\n  };\n\n  Projection.prototype.makeFeasible = function (c) {\n    var _this = this;\n\n    if (!this.avoidOverlaps) return;\n    var axis = 'x',\n        dim = 'width';\n    if (c.axis === 'x') axis = 'y', dim = 'height';\n    var vs = c.offsets.map(function (o) {\n      return _this.nodes[o.node];\n    }).sort(function (a, b) {\n      return a[axis] - b[axis];\n    });\n    var p = null;\n    vs.forEach(function (v) {\n      if (p) {\n        var nextPos = p[axis] + p[dim];\n\n        if (nextPos > v[axis]) {\n          v[axis] = nextPos;\n        }\n      }\n\n      p = v;\n    });\n  };\n\n  Projection.prototype.createAlignment = function (c) {\n    var _this = this;\n\n    var u = this.nodes[c.offsets[0].node].variable;\n    this.makeFeasible(c);\n    var cs = c.axis === 'x' ? this.xConstraints : this.yConstraints;\n    c.offsets.slice(1).forEach(function (o) {\n      var v = _this.nodes[o.node].variable;\n      cs.push(new vpsc_1.Constraint(u, v, o.offset, true));\n    });\n  };\n\n  Projection.prototype.createConstraints = function (constraints) {\n    var _this = this;\n\n    var isSep = function (c) {\n      return typeof c.type === 'undefined' || c.type === 'separation';\n    };\n\n    this.xConstraints = constraints.filter(function (c) {\n      return c.axis === \"x\" && isSep(c);\n    }).map(function (c) {\n      return _this.createSeparation(c);\n    });\n    this.yConstraints = constraints.filter(function (c) {\n      return c.axis === \"y\" && isSep(c);\n    }).map(function (c) {\n      return _this.createSeparation(c);\n    });\n    constraints.filter(function (c) {\n      return c.type === 'alignment';\n    }).forEach(function (c) {\n      return _this.createAlignment(c);\n    });\n  };\n\n  Projection.prototype.setupVariablesAndBounds = function (x0, y0, desired, getDesired) {\n    this.nodes.forEach(function (v, i) {\n      if (v.fixed) {\n        v.variable.weight = v.fixedWeight ? v.fixedWeight : 1000;\n        desired[i] = getDesired(v);\n      } else {\n        v.variable.weight = 1;\n      }\n\n      var w = (v.width || 0) / 2,\n          h = (v.height || 0) / 2;\n      var ix = x0[i],\n          iy = y0[i];\n      v.bounds = new Rectangle(ix - w, ix + w, iy - h, iy + h);\n    });\n  };\n\n  Projection.prototype.xProject = function (x0, y0, x) {\n    if (!this.rootGroup && !(this.avoidOverlaps || this.xConstraints)) return;\n    this.project(x0, y0, x0, x, function (v) {\n      return v.px;\n    }, this.xConstraints, generateXGroupConstraints, function (v) {\n      return v.bounds.setXCentre(x[v.variable.index] = v.variable.position());\n    }, function (g) {\n      var xmin = x[g.minVar.index] = g.minVar.position();\n      var xmax = x[g.maxVar.index] = g.maxVar.position();\n      var p2 = g.padding / 2;\n      g.bounds.x = xmin - p2;\n      g.bounds.X = xmax + p2;\n    });\n  };\n\n  Projection.prototype.yProject = function (x0, y0, y) {\n    if (!this.rootGroup && !this.yConstraints) return;\n    this.project(x0, y0, y0, y, function (v) {\n      return v.py;\n    }, this.yConstraints, generateYGroupConstraints, function (v) {\n      return v.bounds.setYCentre(y[v.variable.index] = v.variable.position());\n    }, function (g) {\n      var ymin = y[g.minVar.index] = g.minVar.position();\n      var ymax = y[g.maxVar.index] = g.maxVar.position();\n      var p2 = g.padding / 2;\n      g.bounds.y = ymin - p2;\n      ;\n      g.bounds.Y = ymax + p2;\n    });\n  };\n\n  Projection.prototype.projectFunctions = function () {\n    var _this = this;\n\n    return [function (x0, y0, x) {\n      return _this.xProject(x0, y0, x);\n    }, function (x0, y0, y) {\n      return _this.yProject(x0, y0, y);\n    }];\n  };\n\n  Projection.prototype.project = function (x0, y0, start, desired, getDesired, cs, generateConstraints, updateNodeBounds, updateGroupBounds) {\n    this.setupVariablesAndBounds(x0, y0, desired, getDesired);\n\n    if (this.rootGroup && this.avoidOverlaps) {\n      computeGroupBounds(this.rootGroup);\n      cs = cs.concat(generateConstraints(this.rootGroup));\n    }\n\n    this.solve(this.variables, cs, start, desired);\n    this.nodes.forEach(updateNodeBounds);\n\n    if (this.rootGroup && this.avoidOverlaps) {\n      this.groups.forEach(updateGroupBounds);\n      computeGroupBounds(this.rootGroup);\n    }\n  };\n\n  Projection.prototype.solve = function (vs, cs, starting, desired) {\n    var solver = new vpsc_1.Solver(vs, cs);\n    solver.setStartingPositions(starting);\n    solver.setDesiredPositions(desired);\n    solver.solve();\n  };\n\n  return Projection;\n}();\n\nexports.Projection = Projection;","map":null,"metadata":{},"sourceType":"script"}