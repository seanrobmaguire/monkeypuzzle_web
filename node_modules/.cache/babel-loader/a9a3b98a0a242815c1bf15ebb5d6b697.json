{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar rectangle_1 = require(\"./rectangle\");\n\nvar Point = function () {\n  function Point() {}\n\n  return Point;\n}();\n\nexports.Point = Point;\n\nvar LineSegment = function () {\n  function LineSegment(x1, y1, x2, y2) {\n    this.x1 = x1;\n    this.y1 = y1;\n    this.x2 = x2;\n    this.y2 = y2;\n  }\n\n  return LineSegment;\n}();\n\nexports.LineSegment = LineSegment;\n\nvar PolyPoint = function (_super) {\n  __extends(PolyPoint, _super);\n\n  function PolyPoint() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  return PolyPoint;\n}(Point);\n\nexports.PolyPoint = PolyPoint;\n\nfunction isLeft(P0, P1, P2) {\n  return (P1.x - P0.x) * (P2.y - P0.y) - (P2.x - P0.x) * (P1.y - P0.y);\n}\n\nexports.isLeft = isLeft;\n\nfunction above(p, vi, vj) {\n  return isLeft(p, vi, vj) > 0;\n}\n\nfunction below(p, vi, vj) {\n  return isLeft(p, vi, vj) < 0;\n}\n\nfunction ConvexHull(S) {\n  var P = S.slice(0).sort(function (a, b) {\n    return a.x !== b.x ? b.x - a.x : b.y - a.y;\n  });\n  var n = S.length,\n      i;\n  var minmin = 0;\n  var xmin = P[0].x;\n\n  for (i = 1; i < n; ++i) {\n    if (P[i].x !== xmin) break;\n  }\n\n  var minmax = i - 1;\n  var H = [];\n  H.push(P[minmin]);\n\n  if (minmax === n - 1) {\n    if (P[minmax].y !== P[minmin].y) H.push(P[minmax]);\n  } else {\n    var maxmin,\n        maxmax = n - 1;\n    var xmax = P[n - 1].x;\n\n    for (i = n - 2; i >= 0; i--) if (P[i].x !== xmax) break;\n\n    maxmin = i + 1;\n    i = minmax;\n\n    while (++i <= maxmin) {\n      if (isLeft(P[minmin], P[maxmin], P[i]) >= 0 && i < maxmin) continue;\n\n      while (H.length > 1) {\n        if (isLeft(H[H.length - 2], H[H.length - 1], P[i]) > 0) break;else H.length -= 1;\n      }\n\n      if (i != minmin) H.push(P[i]);\n    }\n\n    if (maxmax != maxmin) H.push(P[maxmax]);\n    var bot = H.length;\n    i = maxmin;\n\n    while (--i >= minmax) {\n      if (isLeft(P[maxmax], P[minmax], P[i]) >= 0 && i > minmax) continue;\n\n      while (H.length > bot) {\n        if (isLeft(H[H.length - 2], H[H.length - 1], P[i]) > 0) break;else H.length -= 1;\n      }\n\n      if (i != minmin) H.push(P[i]);\n    }\n  }\n\n  return H;\n}\n\nexports.ConvexHull = ConvexHull;\n\nfunction clockwiseRadialSweep(p, P, f) {\n  P.slice(0).sort(function (a, b) {\n    return Math.atan2(a.y - p.y, a.x - p.x) - Math.atan2(b.y - p.y, b.x - p.x);\n  }).forEach(f);\n}\n\nexports.clockwiseRadialSweep = clockwiseRadialSweep;\n\nfunction nextPolyPoint(p, ps) {\n  if (p.polyIndex === ps.length - 1) return ps[0];\n  return ps[p.polyIndex + 1];\n}\n\nfunction prevPolyPoint(p, ps) {\n  if (p.polyIndex === 0) return ps[ps.length - 1];\n  return ps[p.polyIndex - 1];\n}\n\nfunction tangent_PointPolyC(P, V) {\n  var Vclosed = V.slice(0);\n  Vclosed.push(V[0]);\n  return {\n    rtan: Rtangent_PointPolyC(P, Vclosed),\n    ltan: Ltangent_PointPolyC(P, Vclosed)\n  };\n}\n\nfunction Rtangent_PointPolyC(P, V) {\n  var n = V.length - 1;\n  var a, b, c;\n  var upA, dnC;\n  if (below(P, V[1], V[0]) && !above(P, V[n - 1], V[0])) return 0;\n\n  for (a = 0, b = n;;) {\n    if (b - a === 1) if (above(P, V[a], V[b])) return a;else return b;\n    c = Math.floor((a + b) / 2);\n    dnC = below(P, V[c + 1], V[c]);\n    if (dnC && !above(P, V[c - 1], V[c])) return c;\n    upA = above(P, V[a + 1], V[a]);\n\n    if (upA) {\n      if (dnC) b = c;else {\n        if (above(P, V[a], V[c])) b = c;else a = c;\n      }\n    } else {\n      if (!dnC) a = c;else {\n        if (below(P, V[a], V[c])) b = c;else a = c;\n      }\n    }\n  }\n}\n\nfunction Ltangent_PointPolyC(P, V) {\n  var n = V.length - 1;\n  var a, b, c;\n  var dnA, dnC;\n  if (above(P, V[n - 1], V[0]) && !below(P, V[1], V[0])) return 0;\n\n  for (a = 0, b = n;;) {\n    if (b - a === 1) if (below(P, V[a], V[b])) return a;else return b;\n    c = Math.floor((a + b) / 2);\n    dnC = below(P, V[c + 1], V[c]);\n    if (above(P, V[c - 1], V[c]) && !dnC) return c;\n    dnA = below(P, V[a + 1], V[a]);\n\n    if (dnA) {\n      if (!dnC) b = c;else {\n        if (below(P, V[a], V[c])) b = c;else a = c;\n      }\n    } else {\n      if (dnC) a = c;else {\n        if (above(P, V[a], V[c])) b = c;else a = c;\n      }\n    }\n  }\n}\n\nfunction tangent_PolyPolyC(V, W, t1, t2, cmp1, cmp2) {\n  var ix1, ix2;\n  ix1 = t1(W[0], V);\n  ix2 = t2(V[ix1], W);\n  var done = false;\n\n  while (!done) {\n    done = true;\n\n    while (true) {\n      if (ix1 === V.length - 1) ix1 = 0;\n      if (cmp1(W[ix2], V[ix1], V[ix1 + 1])) break;\n      ++ix1;\n    }\n\n    while (true) {\n      if (ix2 === 0) ix2 = W.length - 1;\n      if (cmp2(V[ix1], W[ix2], W[ix2 - 1])) break;\n      --ix2;\n      done = false;\n    }\n  }\n\n  return {\n    t1: ix1,\n    t2: ix2\n  };\n}\n\nexports.tangent_PolyPolyC = tangent_PolyPolyC;\n\nfunction LRtangent_PolyPolyC(V, W) {\n  var rl = RLtangent_PolyPolyC(W, V);\n  return {\n    t1: rl.t2,\n    t2: rl.t1\n  };\n}\n\nexports.LRtangent_PolyPolyC = LRtangent_PolyPolyC;\n\nfunction RLtangent_PolyPolyC(V, W) {\n  return tangent_PolyPolyC(V, W, Rtangent_PointPolyC, Ltangent_PointPolyC, above, below);\n}\n\nexports.RLtangent_PolyPolyC = RLtangent_PolyPolyC;\n\nfunction LLtangent_PolyPolyC(V, W) {\n  return tangent_PolyPolyC(V, W, Ltangent_PointPolyC, Ltangent_PointPolyC, below, below);\n}\n\nexports.LLtangent_PolyPolyC = LLtangent_PolyPolyC;\n\nfunction RRtangent_PolyPolyC(V, W) {\n  return tangent_PolyPolyC(V, W, Rtangent_PointPolyC, Rtangent_PointPolyC, above, above);\n}\n\nexports.RRtangent_PolyPolyC = RRtangent_PolyPolyC;\n\nvar BiTangent = function () {\n  function BiTangent(t1, t2) {\n    this.t1 = t1;\n    this.t2 = t2;\n  }\n\n  return BiTangent;\n}();\n\nexports.BiTangent = BiTangent;\n\nvar BiTangents = function () {\n  function BiTangents() {}\n\n  return BiTangents;\n}();\n\nexports.BiTangents = BiTangents;\n\nvar TVGPoint = function (_super) {\n  __extends(TVGPoint, _super);\n\n  function TVGPoint() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  return TVGPoint;\n}(Point);\n\nexports.TVGPoint = TVGPoint;\n\nvar VisibilityVertex = function () {\n  function VisibilityVertex(id, polyid, polyvertid, p) {\n    this.id = id;\n    this.polyid = polyid;\n    this.polyvertid = polyvertid;\n    this.p = p;\n    p.vv = this;\n  }\n\n  return VisibilityVertex;\n}();\n\nexports.VisibilityVertex = VisibilityVertex;\n\nvar VisibilityEdge = function () {\n  function VisibilityEdge(source, target) {\n    this.source = source;\n    this.target = target;\n  }\n\n  VisibilityEdge.prototype.length = function () {\n    var dx = this.source.p.x - this.target.p.x;\n    var dy = this.source.p.y - this.target.p.y;\n    return Math.sqrt(dx * dx + dy * dy);\n  };\n\n  return VisibilityEdge;\n}();\n\nexports.VisibilityEdge = VisibilityEdge;\n\nvar TangentVisibilityGraph = function () {\n  function TangentVisibilityGraph(P, g0) {\n    this.P = P;\n    this.V = [];\n    this.E = [];\n\n    if (!g0) {\n      var n = P.length;\n\n      for (var i = 0; i < n; i++) {\n        var p = P[i];\n\n        for (var j = 0; j < p.length; ++j) {\n          var pj = p[j],\n              vv = new VisibilityVertex(this.V.length, i, j, pj);\n          this.V.push(vv);\n          if (j > 0) this.E.push(new VisibilityEdge(p[j - 1].vv, vv));\n        }\n\n        if (p.length > 1) this.E.push(new VisibilityEdge(p[0].vv, p[p.length - 1].vv));\n      }\n\n      for (var i = 0; i < n - 1; i++) {\n        var Pi = P[i];\n\n        for (var j = i + 1; j < n; j++) {\n          var Pj = P[j],\n              t = tangents(Pi, Pj);\n\n          for (var q in t) {\n            var c = t[q],\n                source = Pi[c.t1],\n                target = Pj[c.t2];\n            this.addEdgeIfVisible(source, target, i, j);\n          }\n        }\n      }\n    } else {\n      this.V = g0.V.slice(0);\n      this.E = g0.E.slice(0);\n    }\n  }\n\n  TangentVisibilityGraph.prototype.addEdgeIfVisible = function (u, v, i1, i2) {\n    if (!this.intersectsPolys(new LineSegment(u.x, u.y, v.x, v.y), i1, i2)) {\n      this.E.push(new VisibilityEdge(u.vv, v.vv));\n    }\n  };\n\n  TangentVisibilityGraph.prototype.addPoint = function (p, i1) {\n    var n = this.P.length;\n    this.V.push(new VisibilityVertex(this.V.length, n, 0, p));\n\n    for (var i = 0; i < n; ++i) {\n      if (i === i1) continue;\n      var poly = this.P[i],\n          t = tangent_PointPolyC(p, poly);\n      this.addEdgeIfVisible(p, poly[t.ltan], i1, i);\n      this.addEdgeIfVisible(p, poly[t.rtan], i1, i);\n    }\n\n    return p.vv;\n  };\n\n  TangentVisibilityGraph.prototype.intersectsPolys = function (l, i1, i2) {\n    for (var i = 0, n = this.P.length; i < n; ++i) {\n      if (i != i1 && i != i2 && intersects(l, this.P[i]).length > 0) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  return TangentVisibilityGraph;\n}();\n\nexports.TangentVisibilityGraph = TangentVisibilityGraph;\n\nfunction intersects(l, P) {\n  var ints = [];\n\n  for (var i = 1, n = P.length; i < n; ++i) {\n    var int = rectangle_1.Rectangle.lineIntersection(l.x1, l.y1, l.x2, l.y2, P[i - 1].x, P[i - 1].y, P[i].x, P[i].y);\n    if (int) ints.push(int);\n  }\n\n  return ints;\n}\n\nfunction tangents(V, W) {\n  var m = V.length - 1,\n      n = W.length - 1;\n  var bt = new BiTangents();\n\n  for (var i = 0; i < m; ++i) {\n    for (var j = 0; j < n; ++j) {\n      var v1 = V[i == 0 ? m - 1 : i - 1];\n      var v2 = V[i];\n      var v3 = V[i + 1];\n      var w1 = W[j == 0 ? n - 1 : j - 1];\n      var w2 = W[j];\n      var w3 = W[j + 1];\n      var v1v2w2 = isLeft(v1, v2, w2);\n      var v2w1w2 = isLeft(v2, w1, w2);\n      var v2w2w3 = isLeft(v2, w2, w3);\n      var w1w2v2 = isLeft(w1, w2, v2);\n      var w2v1v2 = isLeft(w2, v1, v2);\n      var w2v2v3 = isLeft(w2, v2, v3);\n\n      if (v1v2w2 >= 0 && v2w1w2 >= 0 && v2w2w3 < 0 && w1w2v2 >= 0 && w2v1v2 >= 0 && w2v2v3 < 0) {\n        bt.ll = new BiTangent(i, j);\n      } else if (v1v2w2 <= 0 && v2w1w2 <= 0 && v2w2w3 > 0 && w1w2v2 <= 0 && w2v1v2 <= 0 && w2v2v3 > 0) {\n        bt.rr = new BiTangent(i, j);\n      } else if (v1v2w2 <= 0 && v2w1w2 > 0 && v2w2w3 <= 0 && w1w2v2 >= 0 && w2v1v2 < 0 && w2v2v3 >= 0) {\n        bt.rl = new BiTangent(i, j);\n      } else if (v1v2w2 >= 0 && v2w1w2 < 0 && v2w2w3 >= 0 && w1w2v2 <= 0 && w2v1v2 > 0 && w2v2v3 <= 0) {\n        bt.lr = new BiTangent(i, j);\n      }\n    }\n  }\n\n  return bt;\n}\n\nexports.tangents = tangents;\n\nfunction isPointInsidePoly(p, poly) {\n  for (var i = 1, n = poly.length; i < n; ++i) if (below(poly[i - 1], poly[i], p)) return false;\n\n  return true;\n}\n\nfunction isAnyPInQ(p, q) {\n  return !p.every(function (v) {\n    return !isPointInsidePoly(v, q);\n  });\n}\n\nfunction polysOverlap(p, q) {\n  if (isAnyPInQ(p, q)) return true;\n  if (isAnyPInQ(q, p)) return true;\n\n  for (var i = 1, n = p.length; i < n; ++i) {\n    var v = p[i],\n        u = p[i - 1];\n    if (intersects(new LineSegment(u.x, u.y, v.x, v.y), q).length > 0) return true;\n  }\n\n  return false;\n}\n\nexports.polysOverlap = polysOverlap;","map":null,"metadata":{},"sourceType":"script"}