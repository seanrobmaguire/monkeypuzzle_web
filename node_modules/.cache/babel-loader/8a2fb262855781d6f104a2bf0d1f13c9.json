{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar powergraph = require(\"./powergraph\");\n\nvar linklengths_1 = require(\"./linklengths\");\n\nvar descent_1 = require(\"./descent\");\n\nvar rectangle_1 = require(\"./rectangle\");\n\nvar shortestpaths_1 = require(\"./shortestpaths\");\n\nvar geom_1 = require(\"./geom\");\n\nvar handledisconnected_1 = require(\"./handledisconnected\");\n\nvar EventType;\n\n(function (EventType) {\n  EventType[EventType[\"start\"] = 0] = \"start\";\n  EventType[EventType[\"tick\"] = 1] = \"tick\";\n  EventType[EventType[\"end\"] = 2] = \"end\";\n})(EventType = exports.EventType || (exports.EventType = {}));\n\n;\n\nfunction isGroup(g) {\n  return typeof g.leaves !== 'undefined' || typeof g.groups !== 'undefined';\n}\n\nvar Layout = function () {\n  function Layout() {\n    var _this = this;\n\n    this._canvasSize = [1, 1];\n    this._linkDistance = 20;\n    this._defaultNodeSize = 10;\n    this._linkLengthCalculator = null;\n    this._linkType = null;\n    this._avoidOverlaps = false;\n    this._handleDisconnected = true;\n    this._running = false;\n    this._nodes = [];\n    this._groups = [];\n    this._rootGroup = null;\n    this._links = [];\n    this._constraints = [];\n    this._distanceMatrix = null;\n    this._descent = null;\n    this._directedLinkConstraints = null;\n    this._threshold = 0.01;\n    this._visibilityGraph = null;\n    this._groupCompactness = 1e-6;\n    this.event = null;\n    this.linkAccessor = {\n      getSourceIndex: Layout.getSourceIndex,\n      getTargetIndex: Layout.getTargetIndex,\n      setLength: Layout.setLinkLength,\n      getType: function (l) {\n        return typeof _this._linkType === \"function\" ? _this._linkType(l) : 0;\n      }\n    };\n  }\n\n  Layout.prototype.on = function (e, listener) {\n    if (!this.event) this.event = {};\n\n    if (typeof e === 'string') {\n      this.event[EventType[e]] = listener;\n    } else {\n      this.event[e] = listener;\n    }\n\n    return this;\n  };\n\n  Layout.prototype.trigger = function (e) {\n    if (this.event && typeof this.event[e.type] !== 'undefined') {\n      this.event[e.type](e);\n    }\n  };\n\n  Layout.prototype.kick = function () {\n    while (!this.tick());\n  };\n\n  Layout.prototype.tick = function () {\n    if (this._alpha < this._threshold) {\n      this._running = false;\n      this.trigger({\n        type: EventType.end,\n        alpha: this._alpha = 0,\n        stress: this._lastStress\n      });\n      return true;\n    }\n\n    var n = this._nodes.length,\n        m = this._links.length;\n    var o, i;\n\n    this._descent.locks.clear();\n\n    for (i = 0; i < n; ++i) {\n      o = this._nodes[i];\n\n      if (o.fixed) {\n        if (typeof o.px === 'undefined' || typeof o.py === 'undefined') {\n          o.px = o.x;\n          o.py = o.y;\n        }\n\n        var p = [o.px, o.py];\n\n        this._descent.locks.add(i, p);\n      }\n    }\n\n    var s1 = this._descent.rungeKutta();\n\n    if (s1 === 0) {\n      this._alpha = 0;\n    } else if (typeof this._lastStress !== 'undefined') {\n      this._alpha = s1;\n    }\n\n    this._lastStress = s1;\n    this.updateNodePositions();\n    this.trigger({\n      type: EventType.tick,\n      alpha: this._alpha,\n      stress: this._lastStress\n    });\n    return false;\n  };\n\n  Layout.prototype.updateNodePositions = function () {\n    var x = this._descent.x[0],\n        y = this._descent.x[1];\n    var o,\n        i = this._nodes.length;\n\n    while (i--) {\n      o = this._nodes[i];\n      o.x = x[i];\n      o.y = y[i];\n    }\n  };\n\n  Layout.prototype.nodes = function (v) {\n    if (!v) {\n      if (this._nodes.length === 0 && this._links.length > 0) {\n        var n = 0;\n\n        this._links.forEach(function (l) {\n          n = Math.max(n, l.source, l.target);\n        });\n\n        this._nodes = new Array(++n);\n\n        for (var i = 0; i < n; ++i) {\n          this._nodes[i] = {};\n        }\n      }\n\n      return this._nodes;\n    }\n\n    this._nodes = v;\n    return this;\n  };\n\n  Layout.prototype.groups = function (x) {\n    var _this = this;\n\n    if (!x) return this._groups;\n    this._groups = x;\n    this._rootGroup = {};\n\n    this._groups.forEach(function (g) {\n      if (typeof g.padding === \"undefined\") g.padding = 1;\n\n      if (typeof g.leaves !== \"undefined\") {\n        g.leaves.forEach(function (v, i) {\n          if (typeof v === 'number') (g.leaves[i] = _this._nodes[v]).parent = g;\n        });\n      }\n\n      if (typeof g.groups !== \"undefined\") {\n        g.groups.forEach(function (gi, i) {\n          if (typeof gi === 'number') (g.groups[i] = _this._groups[gi]).parent = g;\n        });\n      }\n    });\n\n    this._rootGroup.leaves = this._nodes.filter(function (v) {\n      return typeof v.parent === 'undefined';\n    });\n    this._rootGroup.groups = this._groups.filter(function (g) {\n      return typeof g.parent === 'undefined';\n    });\n    return this;\n  };\n\n  Layout.prototype.powerGraphGroups = function (f) {\n    var g = powergraph.getGroups(this._nodes, this._links, this.linkAccessor, this._rootGroup);\n    this.groups(g.groups);\n    f(g);\n    return this;\n  };\n\n  Layout.prototype.avoidOverlaps = function (v) {\n    if (!arguments.length) return this._avoidOverlaps;\n    this._avoidOverlaps = v;\n    return this;\n  };\n\n  Layout.prototype.handleDisconnected = function (v) {\n    if (!arguments.length) return this._handleDisconnected;\n    this._handleDisconnected = v;\n    return this;\n  };\n\n  Layout.prototype.flowLayout = function (axis, minSeparation) {\n    if (!arguments.length) axis = 'y';\n    this._directedLinkConstraints = {\n      axis: axis,\n      getMinSeparation: typeof minSeparation === 'number' ? function () {\n        return minSeparation;\n      } : minSeparation\n    };\n    return this;\n  };\n\n  Layout.prototype.links = function (x) {\n    if (!arguments.length) return this._links;\n    this._links = x;\n    return this;\n  };\n\n  Layout.prototype.constraints = function (c) {\n    if (!arguments.length) return this._constraints;\n    this._constraints = c;\n    return this;\n  };\n\n  Layout.prototype.distanceMatrix = function (d) {\n    if (!arguments.length) return this._distanceMatrix;\n    this._distanceMatrix = d;\n    return this;\n  };\n\n  Layout.prototype.size = function (x) {\n    if (!x) return this._canvasSize;\n    this._canvasSize = x;\n    return this;\n  };\n\n  Layout.prototype.defaultNodeSize = function (x) {\n    if (!x) return this._defaultNodeSize;\n    this._defaultNodeSize = x;\n    return this;\n  };\n\n  Layout.prototype.groupCompactness = function (x) {\n    if (!x) return this._groupCompactness;\n    this._groupCompactness = x;\n    return this;\n  };\n\n  Layout.prototype.linkDistance = function (x) {\n    if (!x) {\n      return this._linkDistance;\n    }\n\n    this._linkDistance = typeof x === \"function\" ? x : +x;\n    this._linkLengthCalculator = null;\n    return this;\n  };\n\n  Layout.prototype.linkType = function (f) {\n    this._linkType = f;\n    return this;\n  };\n\n  Layout.prototype.convergenceThreshold = function (x) {\n    if (!x) return this._threshold;\n    this._threshold = typeof x === \"function\" ? x : +x;\n    return this;\n  };\n\n  Layout.prototype.alpha = function (x) {\n    if (!arguments.length) return this._alpha;else {\n      x = +x;\n\n      if (this._alpha) {\n        if (x > 0) this._alpha = x;else this._alpha = 0;\n      } else if (x > 0) {\n        if (!this._running) {\n          this._running = true;\n          this.trigger({\n            type: EventType.start,\n            alpha: this._alpha = x\n          });\n          this.kick();\n        }\n      }\n\n      return this;\n    }\n  };\n\n  Layout.prototype.getLinkLength = function (link) {\n    return typeof this._linkDistance === \"function\" ? +this._linkDistance(link) : this._linkDistance;\n  };\n\n  Layout.setLinkLength = function (link, length) {\n    link.length = length;\n  };\n\n  Layout.prototype.getLinkType = function (link) {\n    return typeof this._linkType === \"function\" ? this._linkType(link) : 0;\n  };\n\n  Layout.prototype.symmetricDiffLinkLengths = function (idealLength, w) {\n    var _this = this;\n\n    if (w === void 0) {\n      w = 1;\n    }\n\n    this.linkDistance(function (l) {\n      return idealLength * l.length;\n    });\n\n    this._linkLengthCalculator = function () {\n      return linklengths_1.symmetricDiffLinkLengths(_this._links, _this.linkAccessor, w);\n    };\n\n    return this;\n  };\n\n  Layout.prototype.jaccardLinkLengths = function (idealLength, w) {\n    var _this = this;\n\n    if (w === void 0) {\n      w = 1;\n    }\n\n    this.linkDistance(function (l) {\n      return idealLength * l.length;\n    });\n\n    this._linkLengthCalculator = function () {\n      return linklengths_1.jaccardLinkLengths(_this._links, _this.linkAccessor, w);\n    };\n\n    return this;\n  };\n\n  Layout.prototype.start = function (initialUnconstrainedIterations, initialUserConstraintIterations, initialAllConstraintsIterations, gridSnapIterations, keepRunning, centerGraph) {\n    var _this = this;\n\n    if (initialUnconstrainedIterations === void 0) {\n      initialUnconstrainedIterations = 0;\n    }\n\n    if (initialUserConstraintIterations === void 0) {\n      initialUserConstraintIterations = 0;\n    }\n\n    if (initialAllConstraintsIterations === void 0) {\n      initialAllConstraintsIterations = 0;\n    }\n\n    if (gridSnapIterations === void 0) {\n      gridSnapIterations = 0;\n    }\n\n    if (keepRunning === void 0) {\n      keepRunning = true;\n    }\n\n    if (centerGraph === void 0) {\n      centerGraph = true;\n    }\n\n    var i,\n        j,\n        n = this.nodes().length,\n        N = n + 2 * this._groups.length,\n        m = this._links.length,\n        w = this._canvasSize[0],\n        h = this._canvasSize[1];\n    var x = new Array(N),\n        y = new Array(N);\n    var G = null;\n    var ao = this._avoidOverlaps;\n\n    this._nodes.forEach(function (v, i) {\n      v.index = i;\n\n      if (typeof v.x === 'undefined') {\n        v.x = w / 2, v.y = h / 2;\n      }\n\n      x[i] = v.x, y[i] = v.y;\n    });\n\n    if (this._linkLengthCalculator) this._linkLengthCalculator();\n    var distances;\n\n    if (this._distanceMatrix) {\n      distances = this._distanceMatrix;\n    } else {\n      distances = new shortestpaths_1.Calculator(N, this._links, Layout.getSourceIndex, Layout.getTargetIndex, function (l) {\n        return _this.getLinkLength(l);\n      }).DistanceMatrix();\n      G = descent_1.Descent.createSquareMatrix(N, function () {\n        return 2;\n      });\n\n      this._links.forEach(function (l) {\n        if (typeof l.source == \"number\") l.source = _this._nodes[l.source];\n        if (typeof l.target == \"number\") l.target = _this._nodes[l.target];\n      });\n\n      this._links.forEach(function (e) {\n        var u = Layout.getSourceIndex(e),\n            v = Layout.getTargetIndex(e);\n        G[u][v] = G[v][u] = e.weight || 1;\n      });\n    }\n\n    var D = descent_1.Descent.createSquareMatrix(N, function (i, j) {\n      return distances[i][j];\n    });\n\n    if (this._rootGroup && typeof this._rootGroup.groups !== 'undefined') {\n      var i = n;\n\n      var addAttraction = function (i, j, strength, idealDistance) {\n        G[i][j] = G[j][i] = strength;\n        D[i][j] = D[j][i] = idealDistance;\n      };\n\n      this._groups.forEach(function (g) {\n        addAttraction(i, i + 1, _this._groupCompactness, 0.1);\n        x[i] = 0, y[i++] = 0;\n        x[i] = 0, y[i++] = 0;\n      });\n    } else this._rootGroup = {\n      leaves: this._nodes,\n      groups: []\n    };\n\n    var curConstraints = this._constraints || [];\n\n    if (this._directedLinkConstraints) {\n      this.linkAccessor.getMinSeparation = this._directedLinkConstraints.getMinSeparation;\n      curConstraints = curConstraints.concat(linklengths_1.generateDirectedEdgeConstraints(n, this._links, this._directedLinkConstraints.axis, this.linkAccessor));\n    }\n\n    this.avoidOverlaps(false);\n    this._descent = new descent_1.Descent([x, y], D);\n\n    this._descent.locks.clear();\n\n    for (var i = 0; i < n; ++i) {\n      var o = this._nodes[i];\n\n      if (o.fixed) {\n        o.px = o.x;\n        o.py = o.y;\n        var p = [o.x, o.y];\n\n        this._descent.locks.add(i, p);\n      }\n    }\n\n    this._descent.threshold = this._threshold;\n    this.initialLayout(initialUnconstrainedIterations, x, y);\n    if (curConstraints.length > 0) this._descent.project = new rectangle_1.Projection(this._nodes, this._groups, this._rootGroup, curConstraints).projectFunctions();\n\n    this._descent.run(initialUserConstraintIterations);\n\n    this.separateOverlappingComponents(w, h, centerGraph);\n    this.avoidOverlaps(ao);\n\n    if (ao) {\n      this._nodes.forEach(function (v, i) {\n        v.x = x[i], v.y = y[i];\n      });\n\n      this._descent.project = new rectangle_1.Projection(this._nodes, this._groups, this._rootGroup, curConstraints, true).projectFunctions();\n\n      this._nodes.forEach(function (v, i) {\n        x[i] = v.x, y[i] = v.y;\n      });\n    }\n\n    this._descent.G = G;\n\n    this._descent.run(initialAllConstraintsIterations);\n\n    if (gridSnapIterations) {\n      this._descent.snapStrength = 1000;\n      this._descent.snapGridSize = this._nodes[0].width;\n      this._descent.numGridSnapNodes = n;\n      this._descent.scaleSnapByMaxH = n != N;\n      var G0 = descent_1.Descent.createSquareMatrix(N, function (i, j) {\n        if (i >= n || j >= n) return G[i][j];\n        return 0;\n      });\n      this._descent.G = G0;\n\n      this._descent.run(gridSnapIterations);\n    }\n\n    this.updateNodePositions();\n    this.separateOverlappingComponents(w, h, centerGraph);\n    return keepRunning ? this.resume() : this;\n  };\n\n  Layout.prototype.initialLayout = function (iterations, x, y) {\n    if (this._groups.length > 0 && iterations > 0) {\n      var n = this._nodes.length;\n\n      var edges = this._links.map(function (e) {\n        return {\n          source: e.source.index,\n          target: e.target.index\n        };\n      });\n\n      var vs = this._nodes.map(function (v) {\n        return {\n          index: v.index\n        };\n      });\n\n      this._groups.forEach(function (g, i) {\n        vs.push({\n          index: g.index = n + i\n        });\n      });\n\n      this._groups.forEach(function (g, i) {\n        if (typeof g.leaves !== 'undefined') g.leaves.forEach(function (v) {\n          return edges.push({\n            source: g.index,\n            target: v.index\n          });\n        });\n        if (typeof g.groups !== 'undefined') g.groups.forEach(function (gg) {\n          return edges.push({\n            source: g.index,\n            target: gg.index\n          });\n        });\n      });\n\n      new Layout().size(this.size()).nodes(vs).links(edges).avoidOverlaps(false).linkDistance(this.linkDistance()).symmetricDiffLinkLengths(5).convergenceThreshold(1e-4).start(iterations, 0, 0, 0, false);\n\n      this._nodes.forEach(function (v) {\n        x[v.index] = vs[v.index].x;\n        y[v.index] = vs[v.index].y;\n      });\n    } else {\n      this._descent.run(iterations);\n    }\n  };\n\n  Layout.prototype.separateOverlappingComponents = function (width, height, centerGraph) {\n    var _this = this;\n\n    if (centerGraph === void 0) {\n      centerGraph = true;\n    }\n\n    if (!this._distanceMatrix && this._handleDisconnected) {\n      var x_1 = this._descent.x[0],\n          y_1 = this._descent.x[1];\n\n      this._nodes.forEach(function (v, i) {\n        v.x = x_1[i], v.y = y_1[i];\n      });\n\n      var graphs = handledisconnected_1.separateGraphs(this._nodes, this._links);\n      handledisconnected_1.applyPacking(graphs, width, height, this._defaultNodeSize, 1, centerGraph);\n\n      this._nodes.forEach(function (v, i) {\n        _this._descent.x[0][i] = v.x, _this._descent.x[1][i] = v.y;\n\n        if (v.bounds) {\n          v.bounds.setXCentre(v.x);\n          v.bounds.setYCentre(v.y);\n        }\n      });\n    }\n  };\n\n  Layout.prototype.resume = function () {\n    return this.alpha(0.1);\n  };\n\n  Layout.prototype.stop = function () {\n    return this.alpha(0);\n  };\n\n  Layout.prototype.prepareEdgeRouting = function (nodeMargin) {\n    if (nodeMargin === void 0) {\n      nodeMargin = 0;\n    }\n\n    this._visibilityGraph = new geom_1.TangentVisibilityGraph(this._nodes.map(function (v) {\n      return v.bounds.inflate(-nodeMargin).vertices();\n    }));\n  };\n\n  Layout.prototype.routeEdge = function (edge, ah, draw) {\n    if (ah === void 0) {\n      ah = 5;\n    }\n\n    var lineData = [];\n    var vg2 = new geom_1.TangentVisibilityGraph(this._visibilityGraph.P, {\n      V: this._visibilityGraph.V,\n      E: this._visibilityGraph.E\n    }),\n        port1 = {\n      x: edge.source.x,\n      y: edge.source.y\n    },\n        port2 = {\n      x: edge.target.x,\n      y: edge.target.y\n    },\n        start = vg2.addPoint(port1, edge.source.index),\n        end = vg2.addPoint(port2, edge.target.index);\n    vg2.addEdgeIfVisible(port1, port2, edge.source.index, edge.target.index);\n\n    if (typeof draw !== 'undefined') {\n      draw(vg2);\n    }\n\n    var sourceInd = function (e) {\n      return e.source.id;\n    },\n        targetInd = function (e) {\n      return e.target.id;\n    },\n        length = function (e) {\n      return e.length();\n    },\n        spCalc = new shortestpaths_1.Calculator(vg2.V.length, vg2.E, sourceInd, targetInd, length),\n        shortestPath = spCalc.PathFromNodeToNode(start.id, end.id);\n\n    if (shortestPath.length === 1 || shortestPath.length === vg2.V.length) {\n      var route = rectangle_1.makeEdgeBetween(edge.source.innerBounds, edge.target.innerBounds, ah);\n      lineData = [route.sourceIntersection, route.arrowStart];\n    } else {\n      var n = shortestPath.length - 2,\n          p = vg2.V[shortestPath[n]].p,\n          q = vg2.V[shortestPath[0]].p,\n          lineData = [edge.source.innerBounds.rayIntersection(p.x, p.y)];\n\n      for (var i = n; i >= 0; --i) lineData.push(vg2.V[shortestPath[i]].p);\n\n      lineData.push(rectangle_1.makeEdgeTo(q, edge.target.innerBounds, ah));\n    }\n\n    return lineData;\n  };\n\n  Layout.getSourceIndex = function (e) {\n    return typeof e.source === 'number' ? e.source : e.source.index;\n  };\n\n  Layout.getTargetIndex = function (e) {\n    return typeof e.target === 'number' ? e.target : e.target.index;\n  };\n\n  Layout.linkId = function (e) {\n    return Layout.getSourceIndex(e) + \"-\" + Layout.getTargetIndex(e);\n  };\n\n  Layout.dragStart = function (d) {\n    if (isGroup(d)) {\n      Layout.storeOffset(d, Layout.dragOrigin(d));\n    } else {\n      Layout.stopNode(d);\n      d.fixed |= 2;\n    }\n  };\n\n  Layout.stopNode = function (v) {\n    v.px = v.x;\n    v.py = v.y;\n  };\n\n  Layout.storeOffset = function (d, origin) {\n    if (typeof d.leaves !== 'undefined') {\n      d.leaves.forEach(function (v) {\n        v.fixed |= 2;\n        Layout.stopNode(v);\n        v._dragGroupOffsetX = v.x - origin.x;\n        v._dragGroupOffsetY = v.y - origin.y;\n      });\n    }\n\n    if (typeof d.groups !== 'undefined') {\n      d.groups.forEach(function (g) {\n        return Layout.storeOffset(g, origin);\n      });\n    }\n  };\n\n  Layout.dragOrigin = function (d) {\n    if (isGroup(d)) {\n      return {\n        x: d.bounds.cx(),\n        y: d.bounds.cy()\n      };\n    } else {\n      return d;\n    }\n  };\n\n  Layout.drag = function (d, position) {\n    if (isGroup(d)) {\n      if (typeof d.leaves !== 'undefined') {\n        d.leaves.forEach(function (v) {\n          d.bounds.setXCentre(position.x);\n          d.bounds.setYCentre(position.y);\n          v.px = v._dragGroupOffsetX + position.x;\n          v.py = v._dragGroupOffsetY + position.y;\n        });\n      }\n\n      if (typeof d.groups !== 'undefined') {\n        d.groups.forEach(function (g) {\n          return Layout.drag(g, position);\n        });\n      }\n    } else {\n      d.px = position.x;\n      d.py = position.y;\n    }\n  };\n\n  Layout.dragEnd = function (d) {\n    if (isGroup(d)) {\n      if (typeof d.leaves !== 'undefined') {\n        d.leaves.forEach(function (v) {\n          Layout.dragEnd(v);\n          delete v._dragGroupOffsetX;\n          delete v._dragGroupOffsetY;\n        });\n      }\n\n      if (typeof d.groups !== 'undefined') {\n        d.groups.forEach(Layout.dragEnd);\n      }\n    } else {\n      d.fixed &= ~6;\n    }\n  };\n\n  Layout.mouseOver = function (d) {\n    d.fixed |= 4;\n    d.px = d.x, d.py = d.y;\n  };\n\n  Layout.mouseOut = function (d) {\n    d.fixed &= ~4;\n  };\n\n  return Layout;\n}();\n\nexports.Layout = Layout;","map":null,"metadata":{},"sourceType":"script"}